import {
  AddIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  ChevronSmallDownIcon,
  ChevronSmallUpIcon,
  DocumentIcon,
  EyeCloseIcon,
  EyeIcon,
  LinkIcon,
  SubtractIcon,
  UndoIcon,
  VideoIcon,
  ZoomIcon,
  ZoomOutIcon,
  ZoomResetIcon,
  __commonJS as __commonJS2,
  __toESM as __toESM2,
  getControlId,
  getControlSetterButtonId
} from "./chunk-RRIU7CNV.js";
import {
  Ao,
  At,
  Bu,
  Dl,
  JT,
  Mt,
  Ne,
  Ol,
  P,
  Tr,
  UI,
  Xs,
  _m,
  b1,
  bB,
  du,
  ee,
  gc,
  j,
  jt,
  lu,
  pc,
  pu,
  qI,
  qT,
  uJ,
  w1,
  wL,
  z5,
  zr
} from "./chunk-XXKW6GZG.js";
import {
  stringify
} from "./chunk-R4CSN7ZA.js";
import {
  dedent
} from "./chunk-JLBFQ2EK.js";
import {
  index_modern_default
} from "./chunk-2ZWQISP4.js";
import {
  require_memoizerific
} from "./chunk-OUTWTJUF.js";
import {
  curriedDarken$1,
  curriedLighten$1,
  curriedOpacify$1,
  curriedTransparentize$1,
  rgba
} from "./chunk-ERYYX37B.js";
import {
  require_pickBy
} from "./chunk-IRMLJZE6.js";
import {
  require_uniq
} from "./chunk-STZ2UJQ4.js";
import "./chunk-UTPU4J6B.js";
import "./chunk-NO3VKNK3.js";
import "./chunk-UVNTVOC6.js";
import "./chunk-6JAZYESB.js";
import "./chunk-I7NQWNNG.js";
import "./chunk-MNU4BWTR.js";
import "./chunk-IKGJFUTV.js";
import "./chunk-AD5XTJKA.js";
import {
  require_cloneDeep
} from "./chunk-CNEXFNKZ.js";
import "./chunk-2S5QAF5T.js";
import "./chunk-KT7C7O3P.js";
import "./chunk-HANRDNMR.js";
import "./chunk-BH77QIYK.js";
import "./chunk-K35XZJFD.js";
import "./chunk-5QTR2NPO.js";
import "./chunk-GM3SEOBC.js";
import "./chunk-YXJDUNLM.js";
import "./chunk-LIUQHJQF.js";
import "./chunk-5MYVVEJS.js";
import "./chunk-FXZYPVRL.js";
import "./chunk-GMADAPVT.js";
import "./chunk-J6L2KFPR.js";
import "./chunk-WWOWP5FH.js";
import "./chunk-CN4Y6LVA.js";
import "./chunk-X3EIENMP.js";
import "./chunk-UDCKICQF.js";
import "./chunk-ZHZVNHID.js";
import {
  renderElement,
  require_global,
  require_preview_api,
  unmountElement
} from "./chunk-FO3N74Z7.js";
import "./chunk-RZYIQUBH.js";
import "./chunk-MWSGYS3J.js";
import {
  require_react
} from "./chunk-USEVLOEB.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/.cache/sb-vite-plugin-externals/storybook/internal/client-logger.js
var require_client_logger = __commonJS({
  "node_modules/.cache/sb-vite-plugin-externals/storybook/internal/client-logger.js"(exports, module) {
    module.exports = __STORYBOOK_MODULE_CLIENT_LOGGER__;
  }
});

// node_modules/.cache/sb-vite-plugin-externals/@storybook/core/preview-errors.js
var require_preview_errors = __commonJS({
  "node_modules/.cache/sb-vite-plugin-externals/@storybook/core/preview-errors.js"(exports, module) {
    module.exports = __STORYBOOK_MODULE_CORE_EVENTS_PREVIEW_ERRORS__;
  }
});

// node_modules/.cache/sb-vite-plugin-externals/@storybook/core/preview-api.js
var require_preview_api2 = __commonJS({
  "node_modules/.cache/sb-vite-plugin-externals/@storybook/core/preview-api.js"(exports, module) {
    module.exports = __STORYBOOK_MODULE_PREVIEW_API__;
  }
});

// node_modules/.cache/sb-vite-plugin-externals/storybook/internal/core-events.js
var require_core_events = __commonJS({
  "node_modules/.cache/sb-vite-plugin-externals/storybook/internal/core-events.js"(exports, module) {
    module.exports = __STORYBOOK_MODULE_CORE_EVENTS__;
  }
});

// node_modules/.cache/sb-vite-plugin-externals/storybook/internal/channels.js
var require_channels = __commonJS({
  "node_modules/.cache/sb-vite-plugin-externals/storybook/internal/channels.js"(exports, module) {
    module.exports = __STORYBOOK_MODULE_CHANNELS__;
  }
});

// node_modules/@storybook/addon-docs/dist/chunk-HLWAVYOI.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/@storybook/blocks/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_global = __toESM(require_global(), 1);
var import_pickBy = __toESM(require_pickBy(), 1);
var import_client_logger = __toESM(require_client_logger(), 1);
var import_memoizerific = __toESM(require_memoizerific(), 1);
var import_uniq = __toESM(require_uniq(), 1);
var import_cloneDeep = __toESM(require_cloneDeep(), 1);
var import_preview_api2 = __toESM(require_preview_api(), 1);

// node_modules/@storybook/core/dist/docs-tools/index.js
var import_preview_errors = __toESM(require_preview_errors());
var import_preview_errors2 = __toESM(require_preview_errors());
var import_preview_api = __toESM(require_preview_api2());
var zs = Object.create;
var yt = Object.defineProperty;
var Ws = Object.getOwnPropertyDescriptor;
var Xs2 = Object.getOwnPropertyNames;
var Qs = Object.getPrototypeOf;
var Zs = Object.prototype.hasOwnProperty;
var r = (e, n) => yt(e, "name", { value: n, configurable: true });
var l = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
var ep = (e, n, a, s) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let p of Xs2(n))
      !Zs.call(e, p) && p !== a && yt(e, p, { get: () => n[p], enumerable: !(s = Ws(n, p)) || s.enumerable });
  return e;
};
var pr = (e, n, a) => (a = e != null ? zs(Qs(e)) : {}, ep(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  n || !e || !e.__esModule ? yt(a, "default", { value: e, enumerable: true }) : a,
  e
));
var dt = l((xT, ur) => {
  var cp = typeof global == "object" && global && global.Object === Object && global;
  ur.exports = cp;
});
var L = l((bT, lr) => {
  var up = dt(), lp = typeof self == "object" && self && self.Object === Object && self, fp = up || lp || Function("return this")();
  lr.exports = fp;
});
var he = l((vT, fr) => {
  var yp = L(), dp = yp.Symbol;
  fr.exports = dp;
});
var Tr2 = l((wT, mr) => {
  var yr = he(), dr = Object.prototype, mp = dr.hasOwnProperty, Tp = dr.toString, xe = yr ? yr.toStringTag : void 0;
  function gp(e) {
    var n = mp.call(e, xe), a = e[xe];
    try {
      e[xe] = void 0;
      var s = true;
    } catch {
    }
    var p = Tp.call(e);
    return s && (n ? e[xe] = a : delete e[xe]), p;
  }
  r(gp, "getRawTag");
  mr.exports = gp;
});
var hr = l((JT2, gr) => {
  var hp = Object.prototype, xp = hp.toString;
  function bp(e) {
    return xp.call(e);
  }
  r(bp, "objectToString");
  gr.exports = bp;
});
var ne = l((ET, vr) => {
  var xr = he(), vp = Tr2(), wp = hr(), Pp = "[object Null]", Jp = "[object Undefined]", br = xr ? xr.toStringTag : void 0;
  function Sp(e) {
    return e == null ? e === void 0 ? Jp : Pp : br && br in Object(e) ? vp(e) : wp(e);
  }
  r(Sp, "baseGetTag");
  vr.exports = Sp;
});
var Ce = l((AT, wr) => {
  function Ep(e) {
    var n = typeof e;
    return e != null && (n == "object" || n == "function");
  }
  r(Ep, "isObject");
  wr.exports = Ep;
});
var mt = l((_T, Pr) => {
  var Op = ne(), Ap = Ce(), Np = "[object AsyncFunction]", _p = "[object Function]", Dp = "[object GeneratorFunction]", qp = "[object Proxy]";
  function Ip(e) {
    if (!Ap(e))
      return false;
    var n = Op(e);
    return n == _p || n == Dp || n == Np || n == qp;
  }
  r(Ip, "isFunction");
  Pr.exports = Ip;
});
var Sr = l((qT2, Jr) => {
  var Rp = L(), jp = Rp["__core-js_shared__"];
  Jr.exports = jp;
});
var Ar = l((IT, Or) => {
  var Tt = Sr(), Er = function() {
    var e = /[^.]+$/.exec(Tt && Tt.keys && Tt.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function Fp(e) {
    return !!Er && Er in e;
  }
  r(Fp, "isMasked");
  Or.exports = Fp;
});
var gt = l((jT, Nr) => {
  var Lp = Function.prototype, kp = Lp.toString;
  function Cp(e) {
    if (e != null) {
      try {
        return kp.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  r(Cp, "toSource");
  Nr.exports = Cp;
});
var Dr = l((LT, _r) => {
  var Up = mt(), Mp = Ar(), Vp = Ce(), Kp = gt(), Bp = /[\\^$.*+?()[\]{}|]/g, $p = /^\[object .+?Constructor\]$/, Gp = Function.prototype, Yp = Object.prototype, Hp = Gp.toString, zp = Yp.hasOwnProperty, Wp = RegExp(
    "^" + Hp.call(zp).replace(Bp, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function Xp(e) {
    if (!Vp(e) || Mp(e))
      return false;
    var n = Up(e) ? Wp : $p;
    return n.test(Kp(e));
  }
  r(Xp, "baseIsNative");
  _r.exports = Xp;
});
var Ir = l((CT, qr) => {
  function Qp(e, n) {
    return e == null ? void 0 : e[n];
  }
  r(Qp, "getValue");
  qr.exports = Qp;
});
var H = l((MT, Rr) => {
  var Zp = Dr(), ec = Ir();
  function tc(e, n) {
    var a = ec(e, n);
    return Zp(a) ? a : void 0;
  }
  r(tc, "getNative");
  Rr.exports = tc;
});
var Fr = l((KT, jr) => {
  var rc = H(), nc = function() {
    try {
      var e = rc(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  }();
  jr.exports = nc;
});
var Cr = l((BT, kr) => {
  var Lr = Fr();
  function oc(e, n, a) {
    n == "__proto__" && Lr ? Lr(e, n, {
      configurable: true,
      enumerable: true,
      value: a,
      writable: true
    }) : e[n] = a;
  }
  r(oc, "baseAssignValue");
  kr.exports = oc;
});
var Mr = l((GT, Ur) => {
  function ac(e) {
    return function(n, a, s) {
      for (var p = -1, c = Object(n), y = s(n), d = y.length; d--; ) {
        var m = y[e ? d : ++p];
        if (a(c[m], m, c) === false)
          break;
      }
      return n;
    };
  }
  r(ac, "createBaseFor");
  Ur.exports = ac;
});
var Kr = l((HT, Vr) => {
  var ic = Mr(), sc = ic();
  Vr.exports = sc;
});
var $r = l((zT, Br) => {
  function pc2(e, n) {
    for (var a = -1, s = Array(e); ++a < e; )
      s[a] = n(a);
    return s;
  }
  r(pc2, "baseTimes");
  Br.exports = pc2;
});
var oe = l((XT, Gr) => {
  function cc(e) {
    return e != null && typeof e == "object";
  }
  r(cc, "isObjectLike");
  Gr.exports = cc;
});
var Hr = l((ZT, Yr) => {
  var uc = ne(), lc = oe(), fc = "[object Arguments]";
  function yc(e) {
    return lc(e) && uc(e) == fc;
  }
  r(yc, "baseIsArguments");
  Yr.exports = yc;
});
var ht = l((tg, Xr) => {
  var zr2 = Hr(), dc = oe(), Wr = Object.prototype, mc = Wr.hasOwnProperty, Tc = Wr.propertyIsEnumerable, gc2 = zr2(/* @__PURE__ */ function() {
    return arguments;
  }()) ? zr2 : function(e) {
    return dc(e) && mc.call(e, "callee") && !Tc.call(e, "callee");
  };
  Xr.exports = gc2;
});
var M = l((rg, Qr) => {
  var hc = Array.isArray;
  Qr.exports = hc;
});
var en = l((ng, Zr) => {
  function xc() {
    return false;
  }
  r(xc, "stubFalse");
  Zr.exports = xc;
});
var xt = l((be, ae) => {
  var bc = L(), vc = en(), nn = typeof be == "object" && be && !be.nodeType && be, tn = nn && typeof ae == "object" && ae && !ae.nodeType && ae, wc = tn && tn.exports === nn, rn = wc ? bc.Buffer : void 0, Pc = rn ? rn.isBuffer : void 0, Jc = Pc || vc;
  ae.exports = Jc;
});
var bt = l((ag, on) => {
  var Sc = 9007199254740991, Ec = /^(?:0|[1-9]\d*)$/;
  function Oc(e, n) {
    var a = typeof e;
    return n = n ?? Sc, !!n && (a == "number" || a != "symbol" && Ec.test(e)) && e > -1 && e % 1 == 0 && e < n;
  }
  r(Oc, "isIndex");
  on.exports = Oc;
});
var Ue = l((sg, an) => {
  var Ac = 9007199254740991;
  function Nc(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Ac;
  }
  r(Nc, "isLength");
  an.exports = Nc;
});
var pn = l((cg, sn) => {
  var _c = ne(), Dc = Ue(), qc = oe(), Ic = "[object Arguments]", Rc = "[object Array]", jc = "[object Boolean]", Fc = "[object Date]", Lc = "[object Error]", kc = "[object Function]", Cc = "[object Map]", Uc = "[object Number]", Mc = "[object Object]", Vc = "[object RegExp]", Kc = "[object Set]", Bc = "[object String]", $c = "[object WeakMap]", Gc = "[object ArrayBuffer]", Yc = "[object DataView]", Hc = "[object Float32Array]", zc = "[object Float64Array]", Wc = "[object Int8Array]", Xc = "[object Int16Array]", Qc = "[object Int32Array]", Zc = "[object Uint8Array]", eu = "[object Uint8ClampedArray]", tu = "[object Uint16Array]", ru = "[object Uint32Array]", E = {};
  E[Hc] = E[zc] = E[Wc] = E[Xc] = E[Qc] = E[Zc] = E[eu] = E[tu] = E[ru] = true;
  E[Ic] = E[Rc] = E[Gc] = E[jc] = E[Yc] = E[Fc] = E[Lc] = E[kc] = E[Cc] = E[Uc] = E[Mc] = E[Vc] = E[Kc] = E[Bc] = E[$c] = false;
  function nu(e) {
    return qc(e) && Dc(e.length) && !!E[_c(e)];
  }
  r(nu, "baseIsTypedArray");
  sn.exports = nu;
});
var un = l((lg, cn) => {
  function ou(e) {
    return function(n) {
      return e(n);
    };
  }
  r(ou, "baseUnary");
  cn.exports = ou;
});
var fn = l((ve, ie) => {
  var au = dt(), ln = typeof ve == "object" && ve && !ve.nodeType && ve, we = ln && typeof ie == "object" && ie && !ie.nodeType && ie, iu = we && we.exports === ln, vt = iu && au.process, su = function() {
    try {
      var e = we && we.require && we.require("util").types;
      return e || vt && vt.binding && vt.binding("util");
    } catch {
    }
  }();
  ie.exports = su;
});
var wt = l((yg, mn) => {
  var pu2 = pn(), cu = un(), yn = fn(), dn = yn && yn.isTypedArray, uu = dn ? cu(dn) : pu2;
  mn.exports = uu;
});
var gn = l((dg, Tn) => {
  var lu2 = $r(), fu = ht(), yu = M(), du2 = xt(), mu = bt(), Tu = wt(), gu = Object.prototype, hu = gu.hasOwnProperty;
  function xu(e, n) {
    var a = yu(e), s = !a && fu(e), p = !a && !s && du2(e), c = !a && !s && !p && Tu(e), y = a || s || p || c, d = y ? lu2(e.length, String) : [], m = d.length;
    for (var g in e)
      (n || hu.call(e, g)) && !(y && // Safari 9 has enumerable `arguments.length` in strict mode.
      (g == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      p && (g == "offset" || g == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      c && (g == "buffer" || g == "byteLength" || g == "byteOffset") || // Skip index properties.
      mu(g, m))) && d.push(g);
    return d;
  }
  r(xu, "arrayLikeKeys");
  Tn.exports = xu;
});
var xn = l((Tg, hn) => {
  var bu = Object.prototype;
  function vu(e) {
    var n = e && e.constructor, a = typeof n == "function" && n.prototype || bu;
    return e === a;
  }
  r(vu, "isPrototype");
  hn.exports = vu;
});
var vn = l((hg, bn) => {
  function wu(e, n) {
    return function(a) {
      return e(n(a));
    };
  }
  r(wu, "overArg");
  bn.exports = wu;
});
var Pn = l((bg, wn) => {
  var Pu = vn(), Ju = Pu(Object.keys, Object);
  wn.exports = Ju;
});
var Sn = l((vg, Jn) => {
  var Su = xn(), Eu = Pn(), Ou = Object.prototype, Au = Ou.hasOwnProperty;
  function Nu(e) {
    if (!Su(e))
      return Eu(e);
    var n = [];
    for (var a in Object(e))
      Au.call(e, a) && a != "constructor" && n.push(a);
    return n;
  }
  r(Nu, "baseKeys");
  Jn.exports = Nu;
});
var On = l((Pg, En) => {
  var _u = mt(), Du = Ue();
  function qu(e) {
    return e != null && Du(e.length) && !_u(e);
  }
  r(qu, "isArrayLike");
  En.exports = qu;
});
var Me = l((Sg, An) => {
  var Iu = gn(), Ru = Sn(), ju = On();
  function Fu(e) {
    return ju(e) ? Iu(e) : Ru(e);
  }
  r(Fu, "keys");
  An.exports = Fu;
});
var _n = l((Og, Nn) => {
  var Lu = Kr(), ku = Me();
  function Cu(e, n) {
    return e && Lu(e, n, ku);
  }
  r(Cu, "baseForOwn");
  Nn.exports = Cu;
});
var qn = l((Ng, Dn) => {
  function Uu() {
    this.__data__ = [], this.size = 0;
  }
  r(Uu, "listCacheClear");
  Dn.exports = Uu;
});
var Pt = l((Dg, In) => {
  function Mu(e, n) {
    return e === n || e !== e && n !== n;
  }
  r(Mu, "eq");
  In.exports = Mu;
});
var Pe = l((Ig, Rn) => {
  var Vu = Pt();
  function Ku(e, n) {
    for (var a = e.length; a--; )
      if (Vu(e[a][0], n))
        return a;
    return -1;
  }
  r(Ku, "assocIndexOf");
  Rn.exports = Ku;
});
var Fn = l((jg, jn) => {
  var Bu2 = Pe(), $u = Array.prototype, Gu = $u.splice;
  function Yu(e) {
    var n = this.__data__, a = Bu2(n, e);
    if (a < 0)
      return false;
    var s = n.length - 1;
    return a == s ? n.pop() : Gu.call(n, a, 1), --this.size, true;
  }
  r(Yu, "listCacheDelete");
  jn.exports = Yu;
});
var kn = l((Lg, Ln) => {
  var Hu = Pe();
  function zu(e) {
    var n = this.__data__, a = Hu(n, e);
    return a < 0 ? void 0 : n[a][1];
  }
  r(zu, "listCacheGet");
  Ln.exports = zu;
});
var Un = l((Cg, Cn) => {
  var Wu = Pe();
  function Xu(e) {
    return Wu(this.__data__, e) > -1;
  }
  r(Xu, "listCacheHas");
  Cn.exports = Xu;
});
var Vn = l((Mg, Mn) => {
  var Qu = Pe();
  function Zu(e, n) {
    var a = this.__data__, s = Qu(a, e);
    return s < 0 ? (++this.size, a.push([e, n])) : a[s][1] = n, this;
  }
  r(Zu, "listCacheSet");
  Mn.exports = Zu;
});
var Je = l((Kg, Kn) => {
  var el = qn(), tl = Fn(), rl = kn(), nl = Un(), ol = Vn();
  function se(e) {
    var n = -1, a = e == null ? 0 : e.length;
    for (this.clear(); ++n < a; ) {
      var s = e[n];
      this.set(s[0], s[1]);
    }
  }
  r(se, "ListCache");
  se.prototype.clear = el;
  se.prototype.delete = tl;
  se.prototype.get = rl;
  se.prototype.has = nl;
  se.prototype.set = ol;
  Kn.exports = se;
});
var $n = l(($g, Bn) => {
  var al = Je();
  function il() {
    this.__data__ = new al(), this.size = 0;
  }
  r(il, "stackClear");
  Bn.exports = il;
});
var Yn = l((Yg, Gn) => {
  function sl(e) {
    var n = this.__data__, a = n.delete(e);
    return this.size = n.size, a;
  }
  r(sl, "stackDelete");
  Gn.exports = sl;
});
var zn = l((zg, Hn) => {
  function pl(e) {
    return this.__data__.get(e);
  }
  r(pl, "stackGet");
  Hn.exports = pl;
});
var Xn = l((Xg, Wn) => {
  function cl(e) {
    return this.__data__.has(e);
  }
  r(cl, "stackHas");
  Wn.exports = cl;
});
var Ve = l((Zg, Qn) => {
  var ul = H(), ll = L(), fl = ul(ll, "Map");
  Qn.exports = fl;
});
var Se = l((eh, Zn) => {
  var yl = H(), dl = yl(Object, "create");
  Zn.exports = dl;
});
var ro = l((th, to) => {
  var eo = Se();
  function ml() {
    this.__data__ = eo ? eo(null) : {}, this.size = 0;
  }
  r(ml, "hashClear");
  to.exports = ml;
});
var oo = l((nh, no) => {
  function Tl(e) {
    var n = this.has(e) && delete this.__data__[e];
    return this.size -= n ? 1 : 0, n;
  }
  r(Tl, "hashDelete");
  no.exports = Tl;
});
var io = l((ah, ao) => {
  var gl = Se(), hl = "__lodash_hash_undefined__", xl = Object.prototype, bl = xl.hasOwnProperty;
  function vl(e) {
    var n = this.__data__;
    if (gl) {
      var a = n[e];
      return a === hl ? void 0 : a;
    }
    return bl.call(n, e) ? n[e] : void 0;
  }
  r(vl, "hashGet");
  ao.exports = vl;
});
var po = l((sh, so) => {
  var wl = Se(), Pl = Object.prototype, Jl = Pl.hasOwnProperty;
  function Sl(e) {
    var n = this.__data__;
    return wl ? n[e] !== void 0 : Jl.call(n, e);
  }
  r(Sl, "hashHas");
  so.exports = Sl;
});
var uo = l((ch, co) => {
  var El = Se(), Ol2 = "__lodash_hash_undefined__";
  function Al(e, n) {
    var a = this.__data__;
    return this.size += this.has(e) ? 0 : 1, a[e] = El && n === void 0 ? Ol2 : n, this;
  }
  r(Al, "hashSet");
  co.exports = Al;
});
var fo = l((lh, lo) => {
  var Nl = ro(), _l = oo(), Dl2 = io(), ql = po(), Il = uo();
  function pe(e) {
    var n = -1, a = e == null ? 0 : e.length;
    for (this.clear(); ++n < a; ) {
      var s = e[n];
      this.set(s[0], s[1]);
    }
  }
  r(pe, "Hash");
  pe.prototype.clear = Nl;
  pe.prototype.delete = _l;
  pe.prototype.get = Dl2;
  pe.prototype.has = ql;
  pe.prototype.set = Il;
  lo.exports = pe;
});
var To = l((yh, mo) => {
  var yo = fo(), Rl = Je(), jl = Ve();
  function Fl() {
    this.size = 0, this.__data__ = {
      hash: new yo(),
      map: new (jl || Rl)(),
      string: new yo()
    };
  }
  r(Fl, "mapCacheClear");
  mo.exports = Fl;
});
var ho = l((mh, go) => {
  function Ll(e) {
    var n = typeof e;
    return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? e !== "__proto__" : e === null;
  }
  r(Ll, "isKeyable");
  go.exports = Ll;
});
var Ee = l((gh, xo) => {
  var kl = ho();
  function Cl(e, n) {
    var a = e.__data__;
    return kl(n) ? a[typeof n == "string" ? "string" : "hash"] : a.map;
  }
  r(Cl, "getMapData");
  xo.exports = Cl;
});
var vo = l((xh, bo) => {
  var Ul = Ee();
  function Ml(e) {
    var n = Ul(this, e).delete(e);
    return this.size -= n ? 1 : 0, n;
  }
  r(Ml, "mapCacheDelete");
  bo.exports = Ml;
});
var Po = l((vh, wo) => {
  var Vl = Ee();
  function Kl(e) {
    return Vl(this, e).get(e);
  }
  r(Kl, "mapCacheGet");
  wo.exports = Kl;
});
var So = l((Ph, Jo) => {
  var Bl = Ee();
  function $l(e) {
    return Bl(this, e).has(e);
  }
  r($l, "mapCacheHas");
  Jo.exports = $l;
});
var Oo = l((Sh, Eo) => {
  var Gl = Ee();
  function Yl(e, n) {
    var a = Gl(this, e), s = a.size;
    return a.set(e, n), this.size += a.size == s ? 0 : 1, this;
  }
  r(Yl, "mapCacheSet");
  Eo.exports = Yl;
});
var Ke = l((Oh, Ao2) => {
  var Hl = To(), zl = vo(), Wl = Po(), Xl = So(), Ql = Oo();
  function ce(e) {
    var n = -1, a = e == null ? 0 : e.length;
    for (this.clear(); ++n < a; ) {
      var s = e[n];
      this.set(s[0], s[1]);
    }
  }
  r(ce, "MapCache");
  ce.prototype.clear = Hl;
  ce.prototype.delete = zl;
  ce.prototype.get = Wl;
  ce.prototype.has = Xl;
  ce.prototype.set = Ql;
  Ao2.exports = ce;
});
var _o = l((Nh, No) => {
  var Zl = Je(), ef = Ve(), tf = Ke(), rf = 200;
  function nf(e, n) {
    var a = this.__data__;
    if (a instanceof Zl) {
      var s = a.__data__;
      if (!ef || s.length < rf - 1)
        return s.push([e, n]), this.size = ++a.size, this;
      a = this.__data__ = new tf(s);
    }
    return a.set(e, n), this.size = a.size, this;
  }
  r(nf, "stackSet");
  No.exports = nf;
});
var Jt = l((Dh, Do) => {
  var of = Je(), af = $n(), sf = Yn(), pf = zn(), cf = Xn(), uf = _o();
  function ue(e) {
    var n = this.__data__ = new of(e);
    this.size = n.size;
  }
  r(ue, "Stack");
  ue.prototype.clear = af;
  ue.prototype.delete = sf;
  ue.prototype.get = pf;
  ue.prototype.has = cf;
  ue.prototype.set = uf;
  Do.exports = ue;
});
var Io = l((Ih, qo) => {
  var lf = "__lodash_hash_undefined__";
  function ff(e) {
    return this.__data__.set(e, lf), this;
  }
  r(ff, "setCacheAdd");
  qo.exports = ff;
});
var jo = l((jh, Ro) => {
  function yf(e) {
    return this.__data__.has(e);
  }
  r(yf, "setCacheHas");
  Ro.exports = yf;
});
var Lo = l((Lh, Fo) => {
  var df = Ke(), mf = Io(), Tf = jo();
  function Be(e) {
    var n = -1, a = e == null ? 0 : e.length;
    for (this.__data__ = new df(); ++n < a; )
      this.add(e[n]);
  }
  r(Be, "SetCache");
  Be.prototype.add = Be.prototype.push = mf;
  Be.prototype.has = Tf;
  Fo.exports = Be;
});
var Co = l((Ch, ko) => {
  function gf(e, n) {
    for (var a = -1, s = e == null ? 0 : e.length; ++a < s; )
      if (n(e[a], a, e))
        return true;
    return false;
  }
  r(gf, "arraySome");
  ko.exports = gf;
});
var Mo = l((Mh, Uo) => {
  function hf(e, n) {
    return e.has(n);
  }
  r(hf, "cacheHas");
  Uo.exports = hf;
});
var St = l((Kh, Vo) => {
  var xf = Lo(), bf = Co(), vf = Mo(), wf = 1, Pf = 2;
  function Jf(e, n, a, s, p, c) {
    var y = a & wf, d = e.length, m = n.length;
    if (d != m && !(y && m > d))
      return false;
    var g = c.get(e), b = c.get(n);
    if (g && b)
      return g == n && b == e;
    var A2 = -1, J = true, v = a & Pf ? new xf() : void 0;
    for (c.set(e, n), c.set(n, e); ++A2 < d; ) {
      var N = e[A2], q = n[A2];
      if (s)
        var R = y ? s(q, N, A2, n, e, c) : s(N, q, A2, e, n, c);
      if (R !== void 0) {
        if (R)
          continue;
        J = false;
        break;
      }
      if (v) {
        if (!bf(n, function(k, C) {
          if (!vf(v, C) && (N === k || p(N, k, a, s, c)))
            return v.push(C);
        })) {
          J = false;
          break;
        }
      } else if (!(N === q || p(N, q, a, s, c))) {
        J = false;
        break;
      }
    }
    return c.delete(e), c.delete(n), J;
  }
  r(Jf, "equalArrays");
  Vo.exports = Jf;
});
var Bo = l(($h, Ko) => {
  var Sf = L(), Ef = Sf.Uint8Array;
  Ko.exports = Ef;
});
var Go = l((Gh, $o) => {
  function Of(e) {
    var n = -1, a = Array(e.size);
    return e.forEach(function(s, p) {
      a[++n] = [p, s];
    }), a;
  }
  r(Of, "mapToArray");
  $o.exports = Of;
});
var Ho = l((Hh, Yo) => {
  function Af(e) {
    var n = -1, a = Array(e.size);
    return e.forEach(function(s) {
      a[++n] = s;
    }), a;
  }
  r(Af, "setToArray");
  Yo.exports = Af;
});
var Zo = l((Wh, Qo) => {
  var zo = he(), Wo = Bo(), Nf = Pt(), _f = St(), Df = Go(), qf = Ho(), If = 1, Rf = 2, jf = "[object Boolean]", Ff = "[object Date]", Lf = "[object Error]", kf = "[object Map]", Cf = "[object Number]", Uf = "[object RegExp]", Mf = "[object Set]", Vf = "[object String]", Kf = "[object Symbol]", Bf = "[object ArrayBuffer]", $f = "[object DataView]", Xo = zo ? zo.prototype : void 0, Et = Xo ? Xo.valueOf : void 0;
  function Gf(e, n, a, s, p, c, y) {
    switch (a) {
      case $f:
        if (e.byteLength != n.byteLength || e.byteOffset != n.byteOffset)
          return false;
        e = e.buffer, n = n.buffer;
      case Bf:
        return !(e.byteLength != n.byteLength || !c(new Wo(e), new Wo(n)));
      case jf:
      case Ff:
      case Cf:
        return Nf(+e, +n);
      case Lf:
        return e.name == n.name && e.message == n.message;
      case Uf:
      case Vf:
        return e == n + "";
      case kf:
        var d = Df;
      case Mf:
        var m = s & If;
        if (d || (d = qf), e.size != n.size && !m)
          return false;
        var g = y.get(e);
        if (g)
          return g == n;
        s |= Rf, y.set(e, n);
        var b = _f(d(e), d(n), s, p, c, y);
        return y.delete(e), b;
      case Kf:
        if (Et)
          return Et.call(e) == Et.call(n);
    }
    return false;
  }
  r(Gf, "equalByTag");
  Qo.exports = Gf;
});
var ta = l((Qh, ea) => {
  function Yf(e, n) {
    for (var a = -1, s = n.length, p = e.length; ++a < s; )
      e[p + a] = n[a];
    return e;
  }
  r(Yf, "arrayPush");
  ea.exports = Yf;
});
var na = l((ex, ra) => {
  var Hf = ta(), zf = M();
  function Wf(e, n, a) {
    var s = n(e);
    return zf(e) ? s : Hf(s, a(e));
  }
  r(Wf, "baseGetAllKeys");
  ra.exports = Wf;
});
var aa = l((rx, oa) => {
  function Xf(e, n) {
    for (var a = -1, s = e == null ? 0 : e.length, p = 0, c = []; ++a < s; ) {
      var y = e[a];
      n(y, a, e) && (c[p++] = y);
    }
    return c;
  }
  r(Xf, "arrayFilter");
  oa.exports = Xf;
});
var sa = l((ox, ia) => {
  function Qf() {
    return [];
  }
  r(Qf, "stubArray");
  ia.exports = Qf;
});
var ua = l((ix, ca) => {
  var Zf = aa(), ey = sa(), ty = Object.prototype, ry = ty.propertyIsEnumerable, pa = Object.getOwnPropertySymbols, ny = pa ? function(e) {
    return e == null ? [] : (e = Object(e), Zf(pa(e), function(n) {
      return ry.call(e, n);
    }));
  } : ey;
  ca.exports = ny;
});
var fa = l((sx, la) => {
  var oy = na(), ay = ua(), iy = Me();
  function sy(e) {
    return oy(e, iy, ay);
  }
  r(sy, "getAllKeys");
  la.exports = sy;
});
var ma = l((cx, da) => {
  var ya = fa(), py = 1, cy = Object.prototype, uy = cy.hasOwnProperty;
  function ly(e, n, a, s, p, c) {
    var y = a & py, d = ya(e), m = d.length, g = ya(n), b = g.length;
    if (m != b && !y)
      return false;
    for (var A2 = m; A2--; ) {
      var J = d[A2];
      if (!(y ? J in n : uy.call(n, J)))
        return false;
    }
    var v = c.get(e), N = c.get(n);
    if (v && N)
      return v == n && N == e;
    var q = true;
    c.set(e, n), c.set(n, e);
    for (var R = y; ++A2 < m; ) {
      J = d[A2];
      var k = e[J], C = n[J];
      if (s)
        var Q = y ? s(C, k, J, n, e, c) : s(k, C, J, e, n, c);
      if (!(Q === void 0 ? k === C || p(k, C, a, s, c) : Q)) {
        q = false;
        break;
      }
      R || (R = J == "constructor");
    }
    if (q && !R) {
      var w = e.constructor, K = n.constructor;
      w != K && "constructor" in e && "constructor" in n && !(typeof w == "function" && w instanceof w && typeof K == "function" && K instanceof K) && (q = false);
    }
    return c.delete(e), c.delete(n), q;
  }
  r(ly, "equalObjects");
  da.exports = ly;
});
var ga = l((lx, Ta) => {
  var fy = H(), yy = L(), dy = fy(yy, "DataView");
  Ta.exports = dy;
});
var xa = l((fx, ha) => {
  var my = H(), Ty = L(), gy = my(Ty, "Promise");
  ha.exports = gy;
});
var va = l((yx, ba) => {
  var hy = H(), xy = L(), by = hy(xy, "Set");
  ba.exports = by;
});
var Pa = l((dx, wa) => {
  var vy = H(), wy = L(), Py = vy(wy, "WeakMap");
  wa.exports = Py;
});
var Da = l((mx, _a) => {
  var Ot = ga(), At2 = Ve(), Nt = xa(), _t = va(), Dt = Pa(), Na = ne(), le = gt(), Ja = "[object Map]", Jy = "[object Object]", Sa = "[object Promise]", Ea = "[object Set]", Oa = "[object WeakMap]", Aa = "[object DataView]", Sy = le(Ot), Ey = le(At2), Oy = le(Nt), Ay = le(_t), Ny = le(
    Dt
  ), X = Na;
  (Ot && X(new Ot(new ArrayBuffer(1))) != Aa || At2 && X(new At2()) != Ja || Nt && X(Nt.resolve()) != Sa || _t && X(new _t()) != Ea || Dt && X(
    new Dt()
  ) != Oa) && (X = r(function(e) {
    var n = Na(e), a = n == Jy ? e.constructor : void 0, s = a ? le(a) : "";
    if (s)
      switch (s) {
        case Sy:
          return Aa;
        case Ey:
          return Ja;
        case Oy:
          return Sa;
        case Ay:
          return Ea;
        case Ny:
          return Oa;
      }
    return n;
  }, "getTag"));
  _a.exports = X;
});
var Ca = l((gx, ka) => {
  var qt = Jt(), _y = St(), Dy = Zo(), qy = ma(), qa = Da(), Ia = M(), Ra = xt(), Iy = wt(), Ry = 1, ja = "[object Arguments]", Fa = "[object Array]", $e = "[object Object]", jy = Object.prototype, La = jy.hasOwnProperty;
  function Fy(e, n, a, s, p, c) {
    var y = Ia(e), d = Ia(n), m = y ? Fa : qa(e), g = d ? Fa : qa(n);
    m = m == ja ? $e : m, g = g == ja ? $e : g;
    var b = m == $e, A2 = g == $e, J = m == g;
    if (J && Ra(e)) {
      if (!Ra(n))
        return false;
      y = true, b = false;
    }
    if (J && !b)
      return c || (c = new qt()), y || Iy(e) ? _y(e, n, a, s, p, c) : Dy(e, n, m, a, s, p, c);
    if (!(a & Ry)) {
      var v = b && La.call(e, "__wrapped__"), N = A2 && La.call(n, "__wrapped__");
      if (v || N) {
        var q = v ? e.value() : e, R = N ? n.value() : n;
        return c || (c = new qt()), p(q, R, a, s, c);
      }
    }
    return J ? (c || (c = new qt()), qy(e, n, a, s, p, c)) : false;
  }
  r(Fy, "baseIsEqualDeep");
  ka.exports = Fy;
});
var It = l((xx, Va) => {
  var Ly = Ca(), Ua = oe();
  function Ma(e, n, a, s, p) {
    return e === n ? true : e == null || n == null || !Ua(e) && !Ua(n) ? e !== e && n !== n : Ly(e, n, a, s, Ma, p);
  }
  r(Ma, "baseIsEqual");
  Va.exports = Ma;
});
var Ba = l((vx, Ka) => {
  var ky = Jt(), Cy = It(), Uy = 1, My = 2;
  function Vy(e, n, a, s) {
    var p = a.length, c = p, y = !s;
    if (e == null)
      return !c;
    for (e = Object(e); p--; ) {
      var d = a[p];
      if (y && d[2] ? d[1] !== e[d[0]] : !(d[0] in e))
        return false;
    }
    for (; ++p < c; ) {
      d = a[p];
      var m = d[0], g = e[m], b = d[1];
      if (y && d[2]) {
        if (g === void 0 && !(m in e))
          return false;
      } else {
        var A2 = new ky();
        if (s)
          var J = s(g, b, m, e, n, A2);
        if (!(J === void 0 ? Cy(b, g, Uy | My, s, A2) : J))
          return false;
      }
    }
    return true;
  }
  r(Vy, "baseIsMatch");
  Ka.exports = Vy;
});
var Rt = l((Px, $a) => {
  var Ky = Ce();
  function By(e) {
    return e === e && !Ky(e);
  }
  r(By, "isStrictComparable");
  $a.exports = By;
});
var Ya = l((Sx, Ga) => {
  var $y = Rt(), Gy = Me();
  function Yy(e) {
    for (var n = Gy(e), a = n.length; a--; ) {
      var s = n[a], p = e[s];
      n[a] = [s, p, $y(p)];
    }
    return n;
  }
  r(Yy, "getMatchData");
  Ga.exports = Yy;
});
var jt2 = l((Ox, Ha) => {
  function Hy(e, n) {
    return function(a) {
      return a == null ? false : a[e] === n && (n !== void 0 || e in Object(a));
    };
  }
  r(Hy, "matchesStrictComparable");
  Ha.exports = Hy;
});
var Wa = l((Nx, za) => {
  var zy = Ba(), Wy = Ya(), Xy = jt2();
  function Qy(e) {
    var n = Wy(e);
    return n.length == 1 && n[0][2] ? Xy(n[0][0], n[0][1]) : function(a) {
      return a === e || zy(a, e, n);
    };
  }
  r(Qy, "baseMatches");
  za.exports = Qy;
});
var Ge = l((Dx, Xa) => {
  var Zy = ne(), ed = oe(), td = "[object Symbol]";
  function rd(e) {
    return typeof e == "symbol" || ed(e) && Zy(e) == td;
  }
  r(rd, "isSymbol");
  Xa.exports = rd;
});
var Ye = l((Ix, Qa) => {
  var nd = M(), od = Ge(), ad = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, id = /^\w*$/;
  function sd(e, n) {
    if (nd(e))
      return false;
    var a = typeof e;
    return a == "number" || a == "symbol" || a == "boolean" || e == null || od(e) ? true : id.test(e) || !ad.test(e) || n != null && e in Object(
      n
    );
  }
  r(sd, "isKey");
  Qa.exports = sd;
});
var ti = l((jx, ei) => {
  var Za = Ke(), pd = "Expected a function";
  function Ft(e, n) {
    if (typeof e != "function" || n != null && typeof n != "function")
      throw new TypeError(pd);
    var a = r(function() {
      var s = arguments, p = n ? n.apply(this, s) : s[0], c = a.cache;
      if (c.has(p))
        return c.get(p);
      var y = e.apply(this, s);
      return a.cache = c.set(p, y) || c, y;
    }, "memoized");
    return a.cache = new (Ft.Cache || Za)(), a;
  }
  r(Ft, "memoize");
  Ft.Cache = Za;
  ei.exports = Ft;
});
var ni = l((Lx, ri) => {
  var cd = ti(), ud = 500;
  function ld(e) {
    var n = cd(e, function(s) {
      return a.size === ud && a.clear(), s;
    }), a = n.cache;
    return n;
  }
  r(ld, "memoizeCapped");
  ri.exports = ld;
});
var ai = l((Cx, oi) => {
  var fd = ni(), yd = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, dd = /\\(\\)?/g, md = fd(
    function(e) {
      var n = [];
      return e.charCodeAt(0) === 46 && n.push(""), e.replace(yd, function(a, s, p, c) {
        n.push(p ? c.replace(dd, "$1") : s || a);
      }), n;
    }
  );
  oi.exports = md;
});
var si = l((Ux, ii) => {
  function Td(e, n) {
    for (var a = -1, s = e == null ? 0 : e.length, p = Array(s); ++a < s; )
      p[a] = n(e[a], a, e);
    return p;
  }
  r(Td, "arrayMap");
  ii.exports = Td;
});
var yi = l((Vx, fi) => {
  var pi = he(), gd = si(), hd = M(), xd = Ge(), bd = 1 / 0, ci = pi ? pi.prototype : void 0, ui = ci ? ci.toString : void 0;
  function li(e) {
    if (typeof e == "string")
      return e;
    if (hd(e))
      return gd(e, li) + "";
    if (xd(e))
      return ui ? ui.call(e) : "";
    var n = e + "";
    return n == "0" && 1 / e == -bd ? "-0" : n;
  }
  r(li, "baseToString");
  fi.exports = li;
});
var mi = l((Bx, di) => {
  var vd = yi();
  function wd(e) {
    return e == null ? "" : vd(e);
  }
  r(wd, "toString");
  di.exports = wd;
});
var Lt = l((Gx, Ti) => {
  var Pd = M(), Jd = Ye(), Sd = ai(), Ed = mi();
  function Od(e, n) {
    return Pd(e) ? e : Jd(e, n) ? [e] : Sd(Ed(e));
  }
  r(Od, "castPath");
  Ti.exports = Od;
});
var Oe = l((Hx, gi) => {
  var Ad = Ge(), Nd = 1 / 0;
  function _d(e) {
    if (typeof e == "string" || Ad(e))
      return e;
    var n = e + "";
    return n == "0" && 1 / e == -Nd ? "-0" : n;
  }
  r(_d, "toKey");
  gi.exports = _d;
});
var kt = l((Wx, hi) => {
  var Dd = Lt(), qd = Oe();
  function Id(e, n) {
    n = Dd(n, e);
    for (var a = 0, s = n.length; e != null && a < s; )
      e = e[qd(n[a++])];
    return a && a == s ? e : void 0;
  }
  r(Id, "baseGet");
  hi.exports = Id;
});
var bi = l((Qx, xi) => {
  var Rd = kt();
  function jd(e, n, a) {
    var s = e == null ? void 0 : Rd(e, n);
    return s === void 0 ? a : s;
  }
  r(jd, "get");
  xi.exports = jd;
});
var wi = l((eb, vi) => {
  function Fd(e, n) {
    return e != null && n in Object(e);
  }
  r(Fd, "baseHasIn");
  vi.exports = Fd;
});
var Ji = l((rb, Pi) => {
  var Ld = Lt(), kd = ht(), Cd = M(), Ud = bt(), Md = Ue(), Vd = Oe();
  function Kd(e, n, a) {
    n = Ld(n, e);
    for (var s = -1, p = n.length, c = false; ++s < p; ) {
      var y = Vd(n[s]);
      if (!(c = e != null && a(e, y)))
        break;
      e = e[y];
    }
    return c || ++s != p ? c : (p = e == null ? 0 : e.length, !!p && Md(p) && Ud(y, p) && (Cd(e) || kd(e)));
  }
  r(Kd, "hasPath");
  Pi.exports = Kd;
});
var Ei = l((ob, Si) => {
  var Bd = wi(), $d = Ji();
  function Gd(e, n) {
    return e != null && $d(e, n, Bd);
  }
  r(Gd, "hasIn");
  Si.exports = Gd;
});
var Ai = l((ib, Oi) => {
  var Yd = It(), Hd = bi(), zd = Ei(), Wd = Ye(), Xd = Rt(), Qd = jt2(), Zd = Oe(), em = 1, tm = 2;
  function rm(e, n) {
    return Wd(e) && Xd(n) ? Qd(Zd(e), n) : function(a) {
      var s = Hd(a, e);
      return s === void 0 && s === n ? zd(a, e) : Yd(n, s, em | tm);
    };
  }
  r(rm, "baseMatchesProperty");
  Oi.exports = rm;
});
var _i = l((pb, Ni) => {
  function nm(e) {
    return e;
  }
  r(nm, "identity");
  Ni.exports = nm;
});
var qi = l((ub, Di) => {
  function om(e) {
    return function(n) {
      return n == null ? void 0 : n[e];
    };
  }
  r(om, "baseProperty");
  Di.exports = om;
});
var Ri = l((fb, Ii) => {
  var am = kt();
  function im(e) {
    return function(n) {
      return am(n, e);
    };
  }
  r(im, "basePropertyDeep");
  Ii.exports = im;
});
var Fi = l((db, ji) => {
  var sm = qi(), pm = Ri(), cm = Ye(), um = Oe();
  function lm(e) {
    return cm(e) ? sm(um(e)) : pm(e);
  }
  r(lm, "property");
  ji.exports = lm;
});
var ki = l((Tb, Li) => {
  var fm = Wa(), ym = Ai(), dm = _i(), mm = M(), Tm = Fi();
  function gm(e) {
    return typeof e == "function" ? e : e == null ? dm : typeof e == "object" ? mm(e) ? ym(e[0], e[1]) : fm(e) : Tm(e);
  }
  r(gm, "baseIteratee");
  Li.exports = gm;
});
var Ui = l((hb, Ci) => {
  var hm = Cr(), xm = _n(), bm = ki();
  function vm(e, n) {
    var a = {};
    return n = bm(n, 3), xm(e, function(s, p, c) {
      hm(a, p, n(s, p, c));
    }), a;
  }
  r(vm, "mapValues");
  Ci.exports = vm;
});
var Qi = l((Ze, Xi) => {
  (function(e, n) {
    typeof Ze == "object" && typeof Xi < "u" ? n(Ze) : typeof define == "function" && define.amd ? define(["exports"], n) : (e = typeof globalThis < "u" ? globalThis : e || self, n(e.jtpp = {}));
  })(Ze, function(e) {
    "use strict";
    function n(t) {
      return t.text !== void 0 && t.text !== "" ? `'${t.type}' with value '${t.text}'` : `'${t.type}'`;
    }
    r(n, "tokenToString");
    let Re = class Re2 extends Error {
      constructor(o) {
        super(`No parslet found for token: ${n(o)}`), this.token = o, Object.setPrototypeOf(this, Re2.prototype);
      }
      getToken() {
        return this.token;
      }
    };
    r(Re, "NoParsletFoundError");
    let a = Re, je = class je2 extends Error {
      constructor(o) {
        super(`The parsing ended early. The next token was: ${n(o)}`), this.token = o, Object.setPrototypeOf(this, je2.prototype);
      }
      getToken() {
        return this.token;
      }
    };
    r(je, "EarlyEndOfParseError");
    let s = je, Fe = class Fe2 extends Error {
      constructor(o, i) {
        let u = `Unexpected type: '${o.type}'.`;
        i !== void 0 && (u += ` Message: ${i}`), super(u), Object.setPrototypeOf(this, Fe2.prototype);
      }
    };
    r(Fe, "UnexpectedTypeError");
    let p = Fe;
    function c(t) {
      return (o) => o.startsWith(t) ? { type: t, text: t } : null;
    }
    r(c, "makePunctuationRule");
    function y(t) {
      let o = 0, i, u = t[0], f = false;
      if (u !== "'" && u !== '"')
        return null;
      for (; o < t.length; ) {
        if (o++, i = t[o], !f && i === u) {
          o++;
          break;
        }
        f = !f && i === "\\";
      }
      if (i !== u)
        throw new Error("Unterminated String");
      return t.slice(0, o);
    }
    r(y, "getQuoted");
    let d = new RegExp("[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}", "u"), m = new RegExp(
      "[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}",
      "u"
    );
    function g(t) {
      let o = t[0];
      if (!d.test(o))
        return null;
      let i = 1;
      do {
        if (o = t[i], !m.test(o))
          break;
        i++;
      } while (i < t.length);
      return t.slice(0, i);
    }
    r(g, "getIdentifier");
    let b = /^(NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity))/;
    function A2(t) {
      var o, i;
      return (i = (o = b.exec(t)) === null || o === void 0 ? void 0 : o[0]) !== null && i !== void 0 ? i : null;
    }
    r(A2, "getNumber");
    let J = r((t) => {
      let o = g(t);
      return o == null ? null : {
        type: "Identifier",
        text: o
      };
    }, "identifierRule");
    function v(t) {
      return (o) => {
        if (!o.startsWith(t))
          return null;
        let i = o[t.length];
        return i !== void 0 && m.test(i) ? null : {
          type: t,
          text: t
        };
      };
    }
    r(v, "makeKeyWordRule");
    let N = r((t) => {
      let o = y(t);
      return o == null ? null : {
        type: "StringValue",
        text: o
      };
    }, "stringValueRule"), q = r((t) => t.length > 0 ? null : {
      type: "EOF",
      text: ""
    }, "eofRule"), R = r((t) => {
      let o = A2(t);
      return o === null ? null : {
        type: "Number",
        text: o
      };
    }, "numberRule"), k = [
      q,
      c("=>"),
      c("("),
      c(")"),
      c("{"),
      c("}"),
      c("["),
      c("]"),
      c("|"),
      c("&"),
      c("<"),
      c(">"),
      c(","),
      c(";"),
      c("*"),
      c("?"),
      c("!"),
      c("="),
      c(":"),
      c("..."),
      c("."),
      c("#"),
      c("~"),
      c("/"),
      c("@"),
      v("undefined"),
      v("null"),
      v("function"),
      v("this"),
      v("new"),
      v("module"),
      v("event"),
      v("external"),
      v("typeof"),
      v("keyof"),
      v("readonly"),
      v("import"),
      v("is"),
      v("in"),
      R,
      J,
      N
    ], C = /^\s*\n\s*/, ee2 = class ee3 {
      static create(o) {
        let i = this.read(o);
        o = i.text;
        let u = this.read(o);
        return o = u.text, new ee3(o, void 0, i.token, u.token);
      }
      constructor(o, i, u, f) {
        this.text = "", this.text = o, this.previous = i, this.current = u, this.next = f;
      }
      static read(o, i = false) {
        i = i || C.test(o), o = o.trim();
        for (let u of k) {
          let f = u(o);
          if (f !== null) {
            let T = Object.assign(Object.assign({}, f), { startOfLine: i });
            return o = o.slice(T.text.length), { text: o, token: T };
          }
        }
        throw new Error("Unexpected Token " + o);
      }
      advance() {
        let o = ee3.read(this.text);
        return new ee3(o.text, this.current, this.next, o.token);
      }
    };
    r(ee2, "Lexer");
    let Q = ee2;
    function w(t) {
      if (t === void 0)
        throw new Error("Unexpected undefined");
      if (t.type === "JsdocTypeKeyValue" || t.type === "JsdocTypeParameterList" || t.type === "JsdocTypeProperty" || t.type === "JsdocTypeReadonlyProperty" || t.type === "JsdocTypeObjectField" || t.type === "JsdocTypeJsdocObjectField" || t.type === "JsdocTypeIndexSignature" || t.type === "JsdocTypeMappedType")
        throw new p(t);
      return t;
    }
    r(w, "assertRootResult");
    function K(t) {
      return t.type === "JsdocTypeKeyValue" ? Ae(t) : w(t);
    }
    r(K, "assertPlainKeyValueOrRootResult");
    function Ts(t) {
      return t.type === "JsdocTypeName" ? t : Ae(t);
    }
    r(Ts, "assertPlainKeyValueOrNameResult");
    function Ae(t) {
      if (t.type !== "JsdocTypeKeyValue")
        throw new p(t);
      return t;
    }
    r(Ae, "assertPlainKeyValueResult");
    function gs(t) {
      var o;
      if (t.type === "JsdocTypeVariadic") {
        if (((o = t.element) === null || o === void 0 ? void 0 : o.type) === "JsdocTypeName")
          return t;
        throw new p(t);
      }
      if (t.type !== "JsdocTypeNumber" && t.type !== "JsdocTypeName")
        throw new p(t);
      return t;
    }
    r(gs, "assertNumberOrVariadicNameResult");
    function tt(t) {
      return t.type === "JsdocTypeIndexSignature" || t.type === "JsdocTypeMappedType";
    }
    r(tt, "isSquaredProperty");
    var h;
    (function(t) {
      t[t.ALL = 0] = "ALL", t[t.PARAMETER_LIST = 1] = "PARAMETER_LIST", t[t.OBJECT = 2] = "OBJECT", t[t.KEY_VALUE = 3] = "KEY_VALUE", t[t.UNION = 4] = "UNION", t[t.INTERSECTION = 5] = "INTERSECTION", t[t.PREFIX = 6] = "PREFIX", t[t.INFIX = 7] = "INFIX", t[t.TUPLE = 8] = "TUPLE", t[t.SYMBOL = 9] = "SYMBOL", t[t.OPTIONAL = 10] = "OPTIONAL", t[t.NULLABLE = 11] = "NULLABLE", t[t.KEY_OF_TYPE_OF = 12] = "KEY_OF_TYPE_OF", t[t.FUNCTION = 13] = "FUNCTION", t[t.ARROW = 14] = "ARROW", t[t.ARRAY_BRACKETS = 15] = "ARRAY_BRACKETS", t[t.GENERIC = 16] = "GENERIC", t[t.NAME_PATH = 17] = "NAME_PATH", t[t.PARENTHESIS = 18] = "PARENTHESIS", t[t.SPECIAL_TYPES = 19] = "SPECIAL_TYPES";
    })(h || (h = {}));
    let ft = class ft {
      constructor(o, i, u) {
        this.grammar = o, typeof i == "string" ? this._lexer = Q.create(i) : this._lexer = i, this.baseParser = u;
      }
      get lexer() {
        return this._lexer;
      }
      /**
       * Parses a given string and throws an error if the parse ended before the end of the string.
       */
      parse() {
        let o = this.parseType(h.ALL);
        if (this.lexer.current.type !== "EOF")
          throw new s(this.lexer.current);
        return o;
      }
      /**
       * Parses with the current lexer and asserts that the result is a {@link RootResult}.
       */
      parseType(o) {
        return w(this.parseIntermediateType(o));
      }
      /**
       * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues
       * to parse the state in the infix step.
       */
      parseIntermediateType(o) {
        let i = this.tryParslets(null, o);
        if (i === null)
          throw new a(this.lexer.current);
        return this.parseInfixIntermediateType(i, o);
      }
      /**
       * In the infix parsing step the parser continues to parse the current state with all parslets until none returns
       * a result.
       */
      parseInfixIntermediateType(o, i) {
        let u = this.tryParslets(o, i);
        for (; u !== null; )
          o = u, u = this.tryParslets(o, i);
        return o;
      }
      /**
       * Tries to parse the current state with all parslets in the grammar and returns the first non null result.
       */
      tryParslets(o, i) {
        for (let u of this.grammar) {
          let f = u(this, i, o);
          if (f !== null)
            return f;
        }
        return null;
      }
      /**
       * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was
       * advanced.
       */
      consume(o) {
        return Array.isArray(o) || (o = [o]), o.includes(this.lexer.current.type) ? (this._lexer = this.lexer.advance(), true) : false;
      }
      acceptLexerState(o) {
        this._lexer = o.lexer;
      }
    };
    r(ft, "Parser");
    let B = ft;
    function Wt(t) {
      return t === "EOF" || t === "|" || t === "," || t === ")" || t === ">";
    }
    r(Wt, "isQuestionMarkUnknownType");
    let rt = r((t, o, i) => {
      let u = t.lexer.current.type, f = t.lexer.next.type;
      return i == null && u === "?" && !Wt(f) || i != null && u === "?" ? (t.consume("?"), i == null ? {
        type: "JsdocTypeNullable",
        element: t.parseType(h.NULLABLE),
        meta: {
          position: "prefix"
        }
      } : {
        type: "JsdocTypeNullable",
        element: w(i),
        meta: {
          position: "suffix"
        }
      }) : null;
    }, "nullableParslet");
    function P2(t) {
      let o = r((i, u, f) => {
        let T = i.lexer.current.type, x = i.lexer.next.type;
        if (f === null) {
          if ("parsePrefix" in t && t.accept(T, x))
            return t.parsePrefix(i);
        } else if ("parseInfix" in t && t.precedence > u && t.accept(T, x))
          return t.parseInfix(i, f);
        return null;
      }, "parslet");
      return Object.defineProperty(o, "name", {
        value: t.name
      }), o;
    }
    r(P2, "composeParslet");
    let Ne2 = P2({
      name: "optionalParslet",
      accept: r((t) => t === "=", "accept"),
      precedence: h.OPTIONAL,
      parsePrefix: r((t) => (t.consume("="), {
        type: "JsdocTypeOptional",
        element: t.parseType(h.OPTIONAL),
        meta: {
          position: "prefix"
        }
      }), "parsePrefix"),
      parseInfix: r((t, o) => (t.consume("="), {
        type: "JsdocTypeOptional",
        element: w(o),
        meta: {
          position: "suffix"
        }
      }), "parseInfix")
    }), _e = P2({
      name: "numberParslet",
      accept: r((t) => t === "Number", "accept"),
      parsePrefix: r((t) => {
        let o = parseFloat(t.lexer.current.text);
        return t.consume("Number"), {
          type: "JsdocTypeNumber",
          value: o
        };
      }, "parsePrefix")
    }), hs = P2({
      name: "parenthesisParslet",
      accept: r((t) => t === "(", "accept"),
      parsePrefix: r((t) => {
        if (t.consume("("), t.consume(")"))
          return {
            type: "JsdocTypeParameterList",
            elements: []
          };
        let o = t.parseIntermediateType(h.ALL);
        if (!t.consume(")"))
          throw new Error("Unterminated parenthesis");
        return o.type === "JsdocTypeParameterList" ? o : o.type === "JsdocTypeKeyValue" ? {
          type: "JsdocTypeParameterList",
          elements: [o]
        } : {
          type: "JsdocTypeParenthesis",
          element: w(o)
        };
      }, "parsePrefix")
    }), xs = P2({
      name: "specialTypesParslet",
      accept: r((t, o) => t === "?" && Wt(o) || t === "null" || t === "undefined" || t === "*", "accept"),
      parsePrefix: r((t) => {
        if (t.consume("null"))
          return {
            type: "JsdocTypeNull"
          };
        if (t.consume("undefined"))
          return {
            type: "JsdocTypeUndefined"
          };
        if (t.consume("*"))
          return {
            type: "JsdocTypeAny"
          };
        if (t.consume("?"))
          return {
            type: "JsdocTypeUnknown"
          };
        throw new Error("Unacceptable token: " + t.lexer.current.text);
      }, "parsePrefix")
    }), bs = P2({
      name: "notNullableParslet",
      accept: r((t) => t === "!", "accept"),
      precedence: h.NULLABLE,
      parsePrefix: r((t) => (t.consume("!"), {
        type: "JsdocTypeNotNullable",
        element: t.parseType(h.NULLABLE),
        meta: {
          position: "prefix"
        }
      }), "parsePrefix"),
      parseInfix: r((t, o) => (t.consume("!"), {
        type: "JsdocTypeNotNullable",
        element: w(o),
        meta: {
          position: "suffix"
        }
      }), "parseInfix")
    });
    function vs({ allowTrailingComma: t }) {
      return P2({
        name: "parameterListParslet",
        accept: r((o) => o === ",", "accept"),
        precedence: h.PARAMETER_LIST,
        parseInfix: r((o, i) => {
          let u = [
            K(i)
          ];
          o.consume(",");
          do
            try {
              let f = o.parseIntermediateType(h.PARAMETER_LIST);
              u.push(K(f));
            } catch (f) {
              if (t && f instanceof a)
                break;
              throw f;
            }
          while (o.consume(","));
          if (u.length > 0 && u.slice(0, -1).some((f) => f.type === "JsdocTypeVariadic"))
            throw new Error("Only the last parameter may be a rest parameter");
          return {
            type: "JsdocTypeParameterList",
            elements: u
          };
        }, "parseInfix")
      });
    }
    r(vs, "createParameterListParslet");
    let ws = P2({
      name: "genericParslet",
      accept: r((t, o) => t === "<" || t === "." && o === "<", "accept"),
      precedence: h.GENERIC,
      parseInfix: r((t, o) => {
        let i = t.consume(".");
        t.consume("<");
        let u = [];
        do
          u.push(t.parseType(h.PARAMETER_LIST));
        while (t.consume(","));
        if (!t.consume(">"))
          throw new Error("Unterminated generic parameter list");
        return {
          type: "JsdocTypeGeneric",
          left: w(o),
          elements: u,
          meta: {
            brackets: "angle",
            dot: i
          }
        };
      }, "parseInfix")
    }), Ps = P2({
      name: "unionParslet",
      accept: r((t) => t === "|", "accept"),
      precedence: h.UNION,
      parseInfix: r((t, o) => {
        t.consume("|");
        let i = [];
        do
          i.push(t.parseType(h.UNION));
        while (t.consume("|"));
        return {
          type: "JsdocTypeUnion",
          elements: [w(o), ...i]
        };
      }, "parseInfix")
    }), nt = [
      rt,
      Ne2,
      _e,
      hs,
      xs,
      bs,
      vs({
        allowTrailingComma: true
      }),
      ws,
      Ps,
      Ne2
    ];
    function De({ allowSquareBracketsOnAnyType: t, allowJsdocNamePaths: o, pathGrammar: i }) {
      return r(function(f, T, x) {
        if (x == null || T >= h.NAME_PATH)
          return null;
        let S = f.lexer.current.type, D = f.lexer.next.type;
        if (!(S === "." && D !== "<" || S === "[" && (t || x.type === "JsdocTypeName") || o && (S === "~" || S === "#")))
          return null;
        let j2, Le = false;
        f.consume(".") ? j2 = "property" : f.consume("[") ? (j2 = "property-brackets", Le = true) : f.consume("~") ? j2 = "inner" : (f.consume("#"), j2 = "instance");
        let ir = i !== null ? new B(i, f.lexer, f) : f, U = ir.parseIntermediateType(h.NAME_PATH);
        f.acceptLexerState(ir);
        let ge;
        switch (U.type) {
          case "JsdocTypeName":
            ge = {
              type: "JsdocTypeProperty",
              value: U.value,
              meta: {
                quote: void 0
              }
            };
            break;
          case "JsdocTypeNumber":
            ge = {
              type: "JsdocTypeProperty",
              value: U.value.toString(10),
              meta: {
                quote: void 0
              }
            };
            break;
          case "JsdocTypeStringValue":
            ge = {
              type: "JsdocTypeProperty",
              value: U.value,
              meta: {
                quote: U.meta.quote
              }
            };
            break;
          case "JsdocTypeSpecialNamePath":
            if (U.specialType === "event")
              ge = U;
            else
              throw new p(U, "Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'");
            break;
          default:
            throw new p(U, "Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'");
        }
        if (Le && !f.consume("]")) {
          let sr = f.lexer.current;
          throw new Error(`Unterminated square brackets. Next token is '${sr.type}' with text '${sr.text}'`);
        }
        return {
          type: "JsdocTypeNamePath",
          left: w(x),
          right: ge,
          pathType: j2
        };
      }, "namePathParslet");
    }
    r(De, "createNamePathParslet");
    function $({ allowedAdditionalTokens: t }) {
      return P2({
        name: "nameParslet",
        accept: r((o) => o === "Identifier" || o === "this" || o === "new" || t.includes(o), "accept"),
        parsePrefix: r((o) => {
          let { type: i, text: u } = o.lexer.current;
          return o.consume(i), {
            type: "JsdocTypeName",
            value: u
          };
        }, "parsePrefix")
      });
    }
    r($, "createNameParslet");
    let me = P2({
      name: "stringValueParslet",
      accept: r((t) => t === "StringValue", "accept"),
      parsePrefix: r((t) => {
        let o = t.lexer.current.text;
        return t.consume("StringValue"), {
          type: "JsdocTypeStringValue",
          value: o.slice(1, -1),
          meta: {
            quote: o[0] === "'" ? "single" : "double"
          }
        };
      }, "parsePrefix")
    });
    function qe({ pathGrammar: t, allowedTypes: o }) {
      return P2({
        name: "specialNamePathParslet",
        accept: r((i) => o.includes(i), "accept"),
        parsePrefix: r((i) => {
          let u = i.lexer.current.type;
          if (i.consume(u), !i.consume(":"))
            return {
              type: "JsdocTypeName",
              value: u
            };
          let f, T = i.lexer.current;
          if (i.consume("StringValue"))
            f = {
              type: "JsdocTypeSpecialNamePath",
              value: T.text.slice(1, -1),
              specialType: u,
              meta: {
                quote: T.text[0] === "'" ? "single" : "double"
              }
            };
          else {
            let D = "", _ = ["Identifier", "@", "/"];
            for (; _.some((j2) => i.consume(j2)); )
              D += T.text, T = i.lexer.current;
            f = {
              type: "JsdocTypeSpecialNamePath",
              value: D,
              specialType: u,
              meta: {
                quote: void 0
              }
            };
          }
          let x = new B(t, i.lexer, i), S = x.parseInfixIntermediateType(f, h.ALL);
          return i.acceptLexerState(x), w(S);
        }, "parsePrefix")
      });
    }
    r(qe, "createSpecialNamePathParslet");
    let Xt = [
      $({
        allowedAdditionalTokens: ["external", "module"]
      }),
      me,
      _e,
      De({
        allowSquareBracketsOnAnyType: false,
        allowJsdocNamePaths: true,
        pathGrammar: null
      })
    ], Z = [
      ...Xt,
      qe({
        allowedTypes: ["event"],
        pathGrammar: Xt
      })
    ];
    function ot(t) {
      let o;
      if (t.type === "JsdocTypeParameterList")
        o = t.elements;
      else if (t.type === "JsdocTypeParenthesis")
        o = [t.element];
      else
        throw new p(t);
      return o.map((i) => K(i));
    }
    r(ot, "getParameters");
    function Js(t) {
      let o = ot(t);
      if (o.some((i) => i.type === "JsdocTypeKeyValue"))
        throw new Error("No parameter should be named");
      return o;
    }
    r(Js, "getUnnamedParameters");
    function at({ allowNamedParameters: t, allowNoReturnType: o, allowWithoutParenthesis: i, allowNewAsFunctionKeyword: u }) {
      return P2({
        name: "functionParslet",
        accept: r((f, T) => f === "function" || u && f === "new" && T === "(", "accept"),
        parsePrefix: r((f) => {
          let T = f.consume("new");
          f.consume("function");
          let x = f.lexer.current.type === "(";
          if (!x) {
            if (!i)
              throw new Error("function is missing parameter list");
            return {
              type: "JsdocTypeName",
              value: "function"
            };
          }
          let S = {
            type: "JsdocTypeFunction",
            parameters: [],
            arrow: false,
            constructor: T,
            parenthesis: x
          }, D = f.parseIntermediateType(h.FUNCTION);
          if (t === void 0)
            S.parameters = Js(D);
          else {
            if (T && D.type === "JsdocTypeFunction" && D.arrow)
              return S = D, S.constructor = true, S;
            S.parameters = ot(D);
            for (let _ of S.parameters)
              if (_.type === "JsdocTypeKeyValue" && !t.includes(_.key))
                throw new Error(`only allowed named parameters are ${t.join(", ")} but got ${_.type}`);
          }
          if (f.consume(":"))
            S.returnType = f.parseType(h.PREFIX);
          else if (!o)
            throw new Error("function is missing return type");
          return S;
        }, "parsePrefix")
      });
    }
    r(at, "createFunctionParslet");
    function it({ allowPostfix: t, allowEnclosingBrackets: o }) {
      return P2({
        name: "variadicParslet",
        accept: r((i) => i === "...", "accept"),
        precedence: h.PREFIX,
        parsePrefix: r((i) => {
          i.consume("...");
          let u = o && i.consume("[");
          try {
            let f = i.parseType(h.PREFIX);
            if (u && !i.consume("]"))
              throw new Error("Unterminated variadic type. Missing ']'");
            return {
              type: "JsdocTypeVariadic",
              element: w(f),
              meta: {
                position: "prefix",
                squareBrackets: u
              }
            };
          } catch (f) {
            if (f instanceof a) {
              if (u)
                throw new Error("Empty square brackets for variadic are not allowed.");
              return {
                type: "JsdocTypeVariadic",
                meta: {
                  position: void 0,
                  squareBrackets: false
                }
              };
            } else
              throw f;
          }
        }, "parsePrefix"),
        parseInfix: t ? (i, u) => (i.consume("..."), {
          type: "JsdocTypeVariadic",
          element: w(u),
          meta: {
            position: "suffix",
            squareBrackets: false
          }
        }) : void 0
      });
    }
    r(it, "createVariadicParslet");
    let Qt = P2({
      name: "symbolParslet",
      accept: r((t) => t === "(", "accept"),
      precedence: h.SYMBOL,
      parseInfix: r((t, o) => {
        if (o.type !== "JsdocTypeName")
          throw new Error("Symbol expects a name on the left side. (Reacting on '(')");
        t.consume("(");
        let i = {
          type: "JsdocTypeSymbol",
          value: o.value
        };
        if (!t.consume(")")) {
          let u = t.parseIntermediateType(h.SYMBOL);
          if (i.element = gs(u), !t.consume(")"))
            throw new Error("Symbol does not end after value");
        }
        return i;
      }, "parseInfix")
    }), Zt = P2({
      name: "arrayBracketsParslet",
      precedence: h.ARRAY_BRACKETS,
      accept: r((t, o) => t === "[" && o === "]", "accept"),
      parseInfix: r((t, o) => (t.consume("["), t.consume("]"), {
        type: "JsdocTypeGeneric",
        left: {
          type: "JsdocTypeName",
          value: "Array"
        },
        elements: [
          w(o)
        ],
        meta: {
          brackets: "square",
          dot: false
        }
      }), "parseInfix")
    });
    function st({ objectFieldGrammar: t, allowKeyTypes: o }) {
      return P2({
        name: "objectParslet",
        accept: r((i) => i === "{", "accept"),
        parsePrefix: r((i) => {
          i.consume("{");
          let u = {
            type: "JsdocTypeObject",
            meta: {
              separator: "comma"
            },
            elements: []
          };
          if (!i.consume("}")) {
            let f, T = new B(t, i.lexer, i);
            for (; ; ) {
              T.acceptLexerState(i);
              let x = T.parseIntermediateType(h.OBJECT);
              i.acceptLexerState(T), x === void 0 && o && (x = i.parseIntermediateType(h.OBJECT));
              let S = false;
              if (x.type === "JsdocTypeNullable" && (S = true, x = x.element), x.type === "JsdocTypeNumber" || x.type === "JsdocTypeName" || x.type === "JsdocTypeStringValue") {
                let _;
                x.type === "JsdocTypeStringValue" && (_ = x.meta.quote), u.elements.push({
                  type: "JsdocTypeObjectField",
                  key: x.value.toString(),
                  right: void 0,
                  optional: S,
                  readonly: false,
                  meta: {
                    quote: _
                  }
                });
              } else if (x.type === "JsdocTypeObjectField" || x.type === "JsdocTypeJsdocObjectField")
                u.elements.push(x);
              else
                throw new p(x);
              if (i.lexer.current.startOfLine)
                f = "linebreak";
              else if (i.consume(","))
                f = "comma";
              else if (i.consume(";"))
                f = "semicolon";
              else
                break;
              if (i.lexer.current.type === "}")
                break;
            }
            if (u.meta.separator = f ?? "comma", !i.consume("}"))
              throw new Error("Unterminated record type. Missing '}'");
          }
          return u;
        }, "parsePrefix")
      });
    }
    r(st, "createObjectParslet");
    function pt({ allowSquaredProperties: t, allowKeyTypes: o, allowReadonly: i, allowOptional: u }) {
      return P2({
        name: "objectFieldParslet",
        precedence: h.KEY_VALUE,
        accept: r((f) => f === ":", "accept"),
        parseInfix: r((f, T) => {
          var x;
          let S = false, D = false;
          u && T.type === "JsdocTypeNullable" && (S = true, T = T.element), i && T.type === "JsdocTypeReadonlyProperty" && (D = true, T = T.element);
          let _ = (x = f.baseParser) !== null && x !== void 0 ? x : f;
          if (_.acceptLexerState(f), T.type === "JsdocTypeNumber" || T.type === "JsdocTypeName" || T.type === "JsdocTypeStringValue" || tt(T)) {
            if (tt(T) && !t)
              throw new p(T);
            _.consume(":");
            let j2;
            T.type === "JsdocTypeStringValue" && (j2 = T.meta.quote);
            let Le = _.parseType(h.KEY_VALUE);
            return f.acceptLexerState(_), {
              type: "JsdocTypeObjectField",
              key: tt(T) ? T : T.value.toString(),
              right: Le,
              optional: S,
              readonly: D,
              meta: {
                quote: j2
              }
            };
          } else {
            if (!o)
              throw new p(T);
            _.consume(":");
            let j2 = _.parseType(h.KEY_VALUE);
            return f.acceptLexerState(_), {
              type: "JsdocTypeJsdocObjectField",
              left: w(T),
              right: j2
            };
          }
        }, "parseInfix")
      });
    }
    r(pt, "createObjectFieldParslet");
    function ct({ allowOptional: t, allowVariadic: o }) {
      return P2({
        name: "keyValueParslet",
        precedence: h.KEY_VALUE,
        accept: r((i) => i === ":", "accept"),
        parseInfix: r((i, u) => {
          let f = false, T = false;
          if (t && u.type === "JsdocTypeNullable" && (f = true, u = u.element), o && u.type === "JsdocTypeVariadic" && u.element !== void 0 && (T = true, u = u.element), u.type !== "JsdocTypeName")
            throw new p(u);
          i.consume(":");
          let x = i.parseType(h.KEY_VALUE);
          return {
            type: "JsdocTypeKeyValue",
            key: u.value,
            right: x,
            optional: f,
            variadic: T
          };
        }, "parseInfix")
      });
    }
    r(ct, "createKeyValueParslet");
    let er = [
      ...nt,
      at({
        allowWithoutParenthesis: true,
        allowNamedParameters: ["this", "new"],
        allowNoReturnType: true,
        allowNewAsFunctionKeyword: false
      }),
      me,
      qe({
        allowedTypes: ["module", "external", "event"],
        pathGrammar: Z
      }),
      it({
        allowEnclosingBrackets: true,
        allowPostfix: true
      }),
      $({
        allowedAdditionalTokens: ["keyof"]
      }),
      Qt,
      Zt,
      De({
        allowSquareBracketsOnAnyType: false,
        allowJsdocNamePaths: true,
        pathGrammar: Z
      })
    ], Ss = [
      ...er,
      st({
        // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here
        // we leave out the object type deliberately
        objectFieldGrammar: [
          $({
            allowedAdditionalTokens: ["module", "in"]
          }),
          pt({
            allowSquaredProperties: false,
            allowKeyTypes: true,
            allowOptional: false,
            allowReadonly: false
          }),
          ...er
        ],
        allowKeyTypes: true
      }),
      ct({
        allowOptional: true,
        allowVariadic: true
      })
    ], tr = P2({
      name: "typeOfParslet",
      accept: r((t) => t === "typeof", "accept"),
      parsePrefix: r((t) => (t.consume("typeof"), {
        type: "JsdocTypeTypeof",
        element: w(t.parseType(h.KEY_OF_TYPE_OF))
      }), "parsePrefix")
    }), Es = [
      $({
        allowedAdditionalTokens: ["module", "keyof", "event", "external", "in"]
      }),
      rt,
      Ne2,
      me,
      _e,
      pt({
        allowSquaredProperties: false,
        allowKeyTypes: false,
        allowOptional: false,
        allowReadonly: false
      })
    ], Os = [
      ...nt,
      st({
        allowKeyTypes: false,
        objectFieldGrammar: Es
      }),
      $({
        allowedAdditionalTokens: ["event", "external", "in"]
      }),
      tr,
      at({
        allowWithoutParenthesis: false,
        allowNamedParameters: ["this", "new"],
        allowNoReturnType: true,
        allowNewAsFunctionKeyword: false
      }),
      it({
        allowEnclosingBrackets: false,
        allowPostfix: false
      }),
      // additional name parslet is needed for some special cases
      $({
        allowedAdditionalTokens: ["keyof"]
      }),
      qe({
        allowedTypes: ["module"],
        pathGrammar: Z
      }),
      De({
        allowSquareBracketsOnAnyType: false,
        allowJsdocNamePaths: true,
        pathGrammar: Z
      }),
      ct({
        allowOptional: false,
        allowVariadic: false
      }),
      Qt
    ];
    function As({ allowQuestionMark: t }) {
      return P2({
        name: "tupleParslet",
        accept: r((o) => o === "[", "accept"),
        parsePrefix: r((o) => {
          o.consume("[");
          let i = {
            type: "JsdocTypeTuple",
            elements: []
          };
          if (o.consume("]"))
            return i;
          let u = o.parseIntermediateType(h.ALL);
          if (u.type === "JsdocTypeParameterList" ? u.elements[0].type === "JsdocTypeKeyValue" ? i.elements = u.elements.map(Ae) : i.elements = u.elements.map(w) : u.type === "JsdocTypeKeyValue" ? i.elements = [Ae(u)] : i.elements = [w(u)], !o.consume("]"))
            throw new Error("Unterminated '['");
          if (!t && i.elements.some((f) => f.type === "JsdocTypeUnknown"))
            throw new Error("Question mark in tuple not allowed");
          return i;
        }, "parsePrefix")
      });
    }
    r(As, "createTupleParslet");
    let Ns = P2({
      name: "keyOfParslet",
      accept: r((t) => t === "keyof", "accept"),
      parsePrefix: r((t) => (t.consume("keyof"), {
        type: "JsdocTypeKeyof",
        element: w(t.parseType(h.KEY_OF_TYPE_OF))
      }), "parsePrefix")
    }), _s = P2({
      name: "importParslet",
      accept: r((t) => t === "import", "accept"),
      parsePrefix: r((t) => {
        if (t.consume("import"), !t.consume("("))
          throw new Error("Missing parenthesis after import keyword");
        let o = t.parseType(h.PREFIX);
        if (o.type !== "JsdocTypeStringValue")
          throw new Error("Only string values are allowed as paths for imports");
        if (!t.consume(")"))
          throw new Error("Missing closing parenthesis after import keyword");
        return {
          type: "JsdocTypeImport",
          element: o
        };
      }, "parsePrefix")
    }), Ds = P2({
      name: "readonlyPropertyParslet",
      accept: r((t) => t === "readonly", "accept"),
      parsePrefix: r((t) => (t.consume("readonly"), {
        type: "JsdocTypeReadonlyProperty",
        element: t.parseType(h.KEY_VALUE)
      }), "parsePrefix")
    }), qs = P2({
      name: "arrowFunctionParslet",
      precedence: h.ARROW,
      accept: r((t) => t === "=>", "accept"),
      parseInfix: r((t, o) => (t.consume("=>"), {
        type: "JsdocTypeFunction",
        parameters: ot(o).map(Ts),
        arrow: true,
        constructor: false,
        parenthesis: true,
        returnType: t.parseType(h.OBJECT)
      }), "parseInfix")
    }), Is = P2({
      name: "intersectionParslet",
      accept: r((t) => t === "&", "accept"),
      precedence: h.INTERSECTION,
      parseInfix: r((t, o) => {
        t.consume("&");
        let i = [];
        do
          i.push(t.parseType(h.INTERSECTION));
        while (t.consume("&"));
        return {
          type: "JsdocTypeIntersection",
          elements: [w(o), ...i]
        };
      }, "parseInfix")
    }), Rs = P2({
      name: "predicateParslet",
      precedence: h.INFIX,
      accept: r((t) => t === "is", "accept"),
      parseInfix: r((t, o) => {
        if (o.type !== "JsdocTypeName")
          throw new p(o, "A typescript predicate always has to have a name on the left side.");
        return t.consume("is"), {
          type: "JsdocTypePredicate",
          left: o,
          right: w(t.parseIntermediateType(h.INFIX))
        };
      }, "parseInfix")
    }), js = P2({
      name: "objectSquareBracketPropertyParslet",
      accept: r((t) => t === "[", "accept"),
      parsePrefix: r((t) => {
        if (t.baseParser === void 0)
          throw new Error("Only allowed inside object grammar");
        t.consume("[");
        let o = t.lexer.current.text;
        t.consume("Identifier");
        let i;
        if (t.consume(":")) {
          let u = t.baseParser;
          u.acceptLexerState(t), i = {
            type: "JsdocTypeIndexSignature",
            key: o,
            right: u.parseType(h.ARRAY_BRACKETS)
          }, t.acceptLexerState(u);
        } else if (t.consume("in")) {
          let u = t.baseParser;
          u.acceptLexerState(t), i = {
            type: "JsdocTypeMappedType",
            key: o,
            right: u.parseType(h.ARRAY_BRACKETS)
          }, t.acceptLexerState(u);
        } else
          throw new Error("Missing ':' or 'in' inside square bracketed property.");
        if (!t.consume("]"))
          throw new Error("Unterminated square brackets");
        return i;
      }, "parsePrefix")
    }), Fs = [
      Ds,
      $({
        allowedAdditionalTokens: ["module", "event", "keyof", "event", "external", "in"]
      }),
      rt,
      Ne2,
      me,
      _e,
      pt({
        allowSquaredProperties: true,
        allowKeyTypes: false,
        allowOptional: true,
        allowReadonly: true
      }),
      js
    ], Ls = [
      ...nt,
      st({
        allowKeyTypes: false,
        objectFieldGrammar: Fs
      }),
      tr,
      Ns,
      _s,
      me,
      at({
        allowWithoutParenthesis: true,
        allowNoReturnType: false,
        allowNamedParameters: ["this", "new", "args"],
        allowNewAsFunctionKeyword: true
      }),
      As({
        allowQuestionMark: false
      }),
      it({
        allowEnclosingBrackets: false,
        allowPostfix: false
      }),
      $({
        allowedAdditionalTokens: ["event", "external", "in"]
      }),
      qe({
        allowedTypes: ["module"],
        pathGrammar: Z
      }),
      Zt,
      qs,
      De({
        allowSquareBracketsOnAnyType: true,
        allowJsdocNamePaths: false,
        pathGrammar: Z
      }),
      Is,
      Rs,
      ct({
        allowVariadic: true,
        allowOptional: true
      })
    ];
    function rr(t, o) {
      switch (o) {
        case "closure":
          return new B(Os, t).parse();
        case "jsdoc":
          return new B(Ss, t).parse();
        case "typescript":
          return new B(Ls, t).parse();
      }
    }
    r(rr, "parse");
    function ks(t, o = ["typescript", "closure", "jsdoc"]) {
      let i;
      for (let u of o)
        try {
          return rr(t, u);
        } catch (f) {
          i = f;
        }
      throw i;
    }
    r(ks, "tryParse");
    function Te(t, o) {
      let i = t[o.type];
      if (i === void 0)
        throw new Error(`In this set of transform rules exists no rule for type ${o.type}.`);
      return i(o, (u) => Te(t, u));
    }
    r(Te, "transform");
    function I(t) {
      throw new Error("This transform is not available. Are you trying the correct parsing mode?");
    }
    r(I, "notAvailableTransform");
    function nr(t) {
      let o = {
        params: []
      };
      for (let i of t.parameters)
        i.type === "JsdocTypeKeyValue" ? i.key === "this" ? o.this = i.right : i.key === "new" ? o.new = i.right : o.params.push(i) : o.params.push(i);
      return o;
    }
    r(nr, "extractSpecialParams");
    function Ie(t, o, i) {
      return t === "prefix" ? i + o : o + i;
    }
    r(Ie, "applyPosition");
    function G(t, o) {
      switch (o) {
        case "double":
          return `"${t}"`;
        case "single":
          return `'${t}'`;
        case void 0:
          return t;
      }
    }
    r(G, "quote");
    function or() {
      return {
        JsdocTypeParenthesis: r((t, o) => `(${t.element !== void 0 ? o(t.element) : ""})`, "JsdocTypeParenthesis"),
        JsdocTypeKeyof: r((t, o) => `keyof ${o(t.element)}`, "JsdocTypeKeyof"),
        JsdocTypeFunction: r((t, o) => {
          if (t.arrow) {
            if (t.returnType === void 0)
              throw new Error("Arrow function needs a return type.");
            let i = `(${t.parameters.map(o).join(", ")}) => ${o(t.returnType)}`;
            return t.constructor && (i = "new " + i), i;
          } else {
            let i = t.constructor ? "new" : "function";
            return t.parenthesis && (i += `(${t.parameters.map(o).join(", ")})`, t.returnType !== void 0 && (i += `: ${o(t.returnType)}`)), i;
          }
        }, "JsdocTypeFunction"),
        JsdocTypeName: r((t) => t.value, "JsdocTypeName"),
        JsdocTypeTuple: r((t, o) => `[${t.elements.map(o).join(", ")}]`, "JsdocTypeTuple"),
        JsdocTypeVariadic: r((t, o) => t.meta.position === void 0 ? "..." : Ie(t.meta.position, o(t.element), "..."), "JsdocTypeVariadic"),
        JsdocTypeNamePath: r((t, o) => {
          let i = o(t.left), u = o(t.right);
          switch (t.pathType) {
            case "inner":
              return `${i}~${u}`;
            case "instance":
              return `${i}#${u}`;
            case "property":
              return `${i}.${u}`;
            case "property-brackets":
              return `${i}[${u}]`;
          }
        }, "JsdocTypeNamePath"),
        JsdocTypeStringValue: r((t) => G(t.value, t.meta.quote), "JsdocTypeStringValue"),
        JsdocTypeAny: r(() => "*", "JsdocTypeAny"),
        JsdocTypeGeneric: r((t, o) => {
          if (t.meta.brackets === "square") {
            let i = t.elements[0], u = o(i);
            return i.type === "JsdocTypeUnion" || i.type === "JsdocTypeIntersection" ? `(${u})[]` : `${u}[]`;
          } else
            return `${o(t.left)}${t.meta.dot ? "." : ""}<${t.elements.map(o).join(", ")}>`;
        }, "JsdocTypeGeneric"),
        JsdocTypeImport: r((t, o) => `import(${o(t.element)})`, "JsdocTypeImport"),
        JsdocTypeObjectField: r((t, o) => {
          let i = "";
          return t.readonly && (i += "readonly "), typeof t.key == "string" ? i += G(t.key, t.meta.quote) : i += o(t.key), t.optional && (i += "?"), t.right === void 0 ? i : i + `: ${o(t.right)}`;
        }, "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: r((t, o) => `${o(t.left)}: ${o(t.right)}`, "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: r((t, o) => {
          let i = t.key;
          return t.optional && (i += "?"), t.variadic && (i = "..." + i), t.right === void 0 ? i : i + `: ${o(t.right)}`;
        }, "JsdocTypeKeyValue"),
        JsdocTypeSpecialNamePath: r((t) => `${t.specialType}:${G(t.value, t.meta.quote)}`, "JsdocTypeSpecialNamePath"),
        JsdocTypeNotNullable: r((t, o) => Ie(t.meta.position, o(t.element), "!"), "JsdocTypeNotNullable"),
        JsdocTypeNull: r(() => "null", "JsdocTypeNull"),
        JsdocTypeNullable: r((t, o) => Ie(t.meta.position, o(t.element), "?"), "JsdocTypeNullable"),
        JsdocTypeNumber: r((t) => t.value.toString(), "JsdocTypeNumber"),
        JsdocTypeObject: r((t, o) => `{${t.elements.map(o).join((t.meta.separator === "comma" ? "," : ";") + " ")}}`, "JsdocTypeObject"),
        JsdocTypeOptional: r((t, o) => Ie(t.meta.position, o(t.element), "="), "JsdocTypeOptional"),
        JsdocTypeSymbol: r((t, o) => `${t.value}(${t.element !== void 0 ? o(t.element) : ""})`, "JsdocTypeSymbol"),
        JsdocTypeTypeof: r((t, o) => `typeof ${o(t.element)}`, "JsdocTypeTypeof"),
        JsdocTypeUndefined: r(() => "undefined", "JsdocTypeUndefined"),
        JsdocTypeUnion: r((t, o) => t.elements.map(o).join(" | "), "JsdocTypeUnion"),
        JsdocTypeUnknown: r(() => "?", "JsdocTypeUnknown"),
        JsdocTypeIntersection: r((t, o) => t.elements.map(o).join(" & "), "JsdocTypeIntersection"),
        JsdocTypeProperty: r((t) => G(t.value, t.meta.quote), "JsdocTypeProperty"),
        JsdocTypePredicate: r((t, o) => `${o(t.left)} is ${o(t.right)}`, "JsdocTypePredicate"),
        JsdocTypeIndexSignature: r((t, o) => `[${t.key}: ${o(t.right)}]`, "JsdocTypeIndexSignature"),
        JsdocTypeMappedType: r((t, o) => `[${t.key} in ${o(t.right)}]`, "JsdocTypeMappedType")
      };
    }
    r(or, "stringifyRules");
    let Cs = or();
    function Us(t) {
      return Te(Cs, t);
    }
    r(Us, "stringify");
    let Ms = [
      "null",
      "true",
      "false",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "export",
      "extends",
      "finally",
      "for",
      "function",
      "if",
      "import",
      "in",
      "instanceof",
      "new",
      "return",
      "super",
      "switch",
      "this",
      "throw",
      "try",
      "typeof",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ];
    function Y(t) {
      let o = {
        type: "NameExpression",
        name: t
      };
      return Ms.includes(t) && (o.reservedWord = true), o;
    }
    r(Y, "makeName");
    let Vs = {
      JsdocTypeOptional: r((t, o) => {
        let i = o(t.element);
        return i.optional = true, i;
      }, "JsdocTypeOptional"),
      JsdocTypeNullable: r((t, o) => {
        let i = o(t.element);
        return i.nullable = true, i;
      }, "JsdocTypeNullable"),
      JsdocTypeNotNullable: r((t, o) => {
        let i = o(t.element);
        return i.nullable = false, i;
      }, "JsdocTypeNotNullable"),
      JsdocTypeVariadic: r((t, o) => {
        if (t.element === void 0)
          throw new Error("dots without value are not allowed in catharsis mode");
        let i = o(t.element);
        return i.repeatable = true, i;
      }, "JsdocTypeVariadic"),
      JsdocTypeAny: r(() => ({
        type: "AllLiteral"
      }), "JsdocTypeAny"),
      JsdocTypeNull: r(() => ({
        type: "NullLiteral"
      }), "JsdocTypeNull"),
      JsdocTypeStringValue: r((t) => Y(G(t.value, t.meta.quote)), "JsdocTypeStringValue"),
      JsdocTypeUndefined: r(() => ({
        type: "UndefinedLiteral"
      }), "JsdocTypeUndefined"),
      JsdocTypeUnknown: r(() => ({
        type: "UnknownLiteral"
      }), "JsdocTypeUnknown"),
      JsdocTypeFunction: r((t, o) => {
        let i = nr(t), u = {
          type: "FunctionType",
          params: i.params.map(o)
        };
        return i.this !== void 0 && (u.this = o(i.this)), i.new !== void 0 && (u.new = o(i.new)), t.returnType !== void 0 && (u.result = o(t.returnType)), u;
      }, "JsdocTypeFunction"),
      JsdocTypeGeneric: r((t, o) => ({
        type: "TypeApplication",
        applications: t.elements.map((i) => o(i)),
        expression: o(t.left)
      }), "JsdocTypeGeneric"),
      JsdocTypeSpecialNamePath: r((t) => Y(t.specialType + ":" + G(t.value, t.meta.quote)), "JsdocTypeSpecialNamePath"),
      JsdocTypeName: r((t) => t.value !== "function" ? Y(t.value) : {
        type: "FunctionType",
        params: []
      }, "JsdocTypeName"),
      JsdocTypeNumber: r((t) => Y(t.value.toString()), "JsdocTypeNumber"),
      JsdocTypeObject: r((t, o) => {
        let i = {
          type: "RecordType",
          fields: []
        };
        for (let u of t.elements)
          u.type !== "JsdocTypeObjectField" && u.type !== "JsdocTypeJsdocObjectField" ? i.fields.push({
            type: "FieldType",
            key: o(u),
            value: void 0
          }) : i.fields.push(o(u));
        return i;
      }, "JsdocTypeObject"),
      JsdocTypeObjectField: r((t, o) => {
        if (typeof t.key != "string")
          throw new Error("Index signatures and mapped types are not supported");
        return {
          type: "FieldType",
          key: Y(G(t.key, t.meta.quote)),
          value: t.right === void 0 ? void 0 : o(t.right)
        };
      }, "JsdocTypeObjectField"),
      JsdocTypeJsdocObjectField: r((t, o) => ({
        type: "FieldType",
        key: o(t.left),
        value: o(t.right)
      }), "JsdocTypeJsdocObjectField"),
      JsdocTypeUnion: r((t, o) => ({
        type: "TypeUnion",
        elements: t.elements.map((i) => o(i))
      }), "JsdocTypeUnion"),
      JsdocTypeKeyValue: r((t, o) => ({
        type: "FieldType",
        key: Y(t.key),
        value: t.right === void 0 ? void 0 : o(t.right)
      }), "JsdocTypeKeyValue"),
      JsdocTypeNamePath: r((t, o) => {
        let i = o(t.left), u;
        t.right.type === "JsdocTypeSpecialNamePath" ? u = o(t.right).name : u = G(t.right.value, t.right.meta.quote);
        let f = t.pathType === "inner" ? "~" : t.pathType === "instance" ? "#" : ".";
        return Y(`${i.name}${f}${u}`);
      }, "JsdocTypeNamePath"),
      JsdocTypeSymbol: r((t) => {
        let o = "", i = t.element, u = false;
        return (i == null ? void 0 : i.type) === "JsdocTypeVariadic" && (i.meta.position === "prefix" ? o = "..." : u = true, i = i.element), (i == null ? void 0 : i.type) === "JsdocTypeName" ? o += i.value : (i == null ? void 0 : i.type) === "JsdocTypeNumber" && (o += i.value.toString()), u && (o += "..."), Y(`${t.value}(${o})`);
      }, "JsdocTypeSymbol"),
      JsdocTypeParenthesis: r((t, o) => o(w(t.element)), "JsdocTypeParenthesis"),
      JsdocTypeMappedType: I,
      JsdocTypeIndexSignature: I,
      JsdocTypeImport: I,
      JsdocTypeKeyof: I,
      JsdocTypeTuple: I,
      JsdocTypeTypeof: I,
      JsdocTypeIntersection: I,
      JsdocTypeProperty: I,
      JsdocTypePredicate: I
    };
    function Ks(t) {
      return Te(Vs, t);
    }
    r(Ks, "catharsisTransform");
    function W(t) {
      switch (t) {
        case void 0:
          return "none";
        case "single":
          return "single";
        case "double":
          return "double";
      }
    }
    r(W, "getQuoteStyle");
    function Bs(t) {
      switch (t) {
        case "inner":
          return "INNER_MEMBER";
        case "instance":
          return "INSTANCE_MEMBER";
        case "property":
          return "MEMBER";
        case "property-brackets":
          return "MEMBER";
      }
    }
    r(Bs, "getMemberType");
    function ut(t, o) {
      return o.length === 2 ? {
        type: t,
        left: o[0],
        right: o[1]
      } : {
        type: t,
        left: o[0],
        right: ut(t, o.slice(1))
      };
    }
    r(ut, "nestResults");
    let $s = {
      JsdocTypeOptional: r((t, o) => ({
        type: "OPTIONAL",
        value: o(t.element),
        meta: {
          syntax: t.meta.position === "prefix" ? "PREFIX_EQUAL_SIGN" : "SUFFIX_EQUALS_SIGN"
        }
      }), "JsdocTypeOptional"),
      JsdocTypeNullable: r((t, o) => ({
        type: "NULLABLE",
        value: o(t.element),
        meta: {
          syntax: t.meta.position === "prefix" ? "PREFIX_QUESTION_MARK" : "SUFFIX_QUESTION_MARK"
        }
      }), "JsdocTypeNullable"),
      JsdocTypeNotNullable: r((t, o) => ({
        type: "NOT_NULLABLE",
        value: o(t.element),
        meta: {
          syntax: t.meta.position === "prefix" ? "PREFIX_BANG" : "SUFFIX_BANG"
        }
      }), "JsdocTypeNotNullable"),
      JsdocTypeVariadic: r((t, o) => {
        let i = {
          type: "VARIADIC",
          meta: {
            syntax: t.meta.position === "prefix" ? "PREFIX_DOTS" : t.meta.position === "suffix" ? "SUFFIX_DOTS" : "ONLY_DOTS"
          }
        };
        return t.element !== void 0 && (i.value = o(t.element)), i;
      }, "JsdocTypeVariadic"),
      JsdocTypeName: r((t) => ({
        type: "NAME",
        name: t.value
      }), "JsdocTypeName"),
      JsdocTypeTypeof: r((t, o) => ({
        type: "TYPE_QUERY",
        name: o(t.element)
      }), "JsdocTypeTypeof"),
      JsdocTypeTuple: r((t, o) => ({
        type: "TUPLE",
        entries: t.elements.map(o)
      }), "JsdocTypeTuple"),
      JsdocTypeKeyof: r((t, o) => ({
        type: "KEY_QUERY",
        value: o(t.element)
      }), "JsdocTypeKeyof"),
      JsdocTypeImport: r((t) => ({
        type: "IMPORT",
        path: {
          type: "STRING_VALUE",
          quoteStyle: W(t.element.meta.quote),
          string: t.element.value
        }
      }), "JsdocTypeImport"),
      JsdocTypeUndefined: r(() => ({
        type: "NAME",
        name: "undefined"
      }), "JsdocTypeUndefined"),
      JsdocTypeAny: r(() => ({
        type: "ANY"
      }), "JsdocTypeAny"),
      JsdocTypeFunction: r((t, o) => {
        let i = nr(t), u = {
          type: t.arrow ? "ARROW" : "FUNCTION",
          params: i.params.map((f) => {
            if (f.type === "JsdocTypeKeyValue") {
              if (f.right === void 0)
                throw new Error("Function parameter without ':' is not expected to be 'KEY_VALUE'");
              return {
                type: "NAMED_PARAMETER",
                name: f.key,
                typeName: o(f.right)
              };
            } else
              return o(f);
          }),
          new: null,
          returns: null
        };
        return i.this !== void 0 ? u.this = o(i.this) : t.arrow || (u.this = null), i.new !== void 0 && (u.new = o(i.new)), t.returnType !== void 0 && (u.returns = o(t.returnType)), u;
      }, "JsdocTypeFunction"),
      JsdocTypeGeneric: r((t, o) => {
        let i = {
          type: "GENERIC",
          subject: o(t.left),
          objects: t.elements.map(o),
          meta: {
            syntax: t.meta.brackets === "square" ? "SQUARE_BRACKET" : t.meta.dot ? "ANGLE_BRACKET_WITH_DOT" : "ANGLE_BRACKET"
          }
        };
        return t.meta.brackets === "square" && t.elements[0].type === "JsdocTypeFunction" && !t.elements[0].parenthesis && (i.objects[0] = {
          type: "NAME",
          name: "function"
        }), i;
      }, "JsdocTypeGeneric"),
      JsdocTypeObjectField: r((t, o) => {
        if (typeof t.key != "string")
          throw new Error("Index signatures and mapped types are not supported");
        if (t.right === void 0)
          return {
            type: "RECORD_ENTRY",
            key: t.key,
            quoteStyle: W(t.meta.quote),
            value: null,
            readonly: false
          };
        let i = o(t.right);
        return t.optional && (i = {
          type: "OPTIONAL",
          value: i,
          meta: {
            syntax: "SUFFIX_KEY_QUESTION_MARK"
          }
        }), {
          type: "RECORD_ENTRY",
          key: t.key.toString(),
          quoteStyle: W(t.meta.quote),
          value: i,
          readonly: false
        };
      }, "JsdocTypeObjectField"),
      JsdocTypeJsdocObjectField: r(() => {
        throw new Error("Keys may not be typed in jsdoctypeparser.");
      }, "JsdocTypeJsdocObjectField"),
      JsdocTypeKeyValue: r((t, o) => {
        if (t.right === void 0)
          return {
            type: "RECORD_ENTRY",
            key: t.key,
            quoteStyle: "none",
            value: null,
            readonly: false
          };
        let i = o(t.right);
        return t.optional && (i = {
          type: "OPTIONAL",
          value: i,
          meta: {
            syntax: "SUFFIX_KEY_QUESTION_MARK"
          }
        }), {
          type: "RECORD_ENTRY",
          key: t.key,
          quoteStyle: "none",
          value: i,
          readonly: false
        };
      }, "JsdocTypeKeyValue"),
      JsdocTypeObject: r((t, o) => {
        let i = [];
        for (let u of t.elements)
          (u.type === "JsdocTypeObjectField" || u.type === "JsdocTypeJsdocObjectField") && i.push(o(u));
        return {
          type: "RECORD",
          entries: i
        };
      }, "JsdocTypeObject"),
      JsdocTypeSpecialNamePath: r((t) => {
        if (t.specialType !== "module")
          throw new Error(`jsdoctypeparser does not support type ${t.specialType} at this point.`);
        return {
          type: "MODULE",
          value: {
            type: "FILE_PATH",
            quoteStyle: W(t.meta.quote),
            path: t.value
          }
        };
      }, "JsdocTypeSpecialNamePath"),
      JsdocTypeNamePath: r((t, o) => {
        let i = false, u, f;
        t.right.type === "JsdocTypeSpecialNamePath" && t.right.specialType === "event" ? (i = true, u = t.right.value, f = W(t.right.meta.quote)) : (u = t.right.value, f = W(t.right.meta.quote));
        let T = {
          type: Bs(t.pathType),
          owner: o(t.left),
          name: u,
          quoteStyle: f,
          hasEventPrefix: i
        };
        if (T.owner.type === "MODULE") {
          let x = T.owner;
          return T.owner = T.owner.value, x.value = T, x;
        } else
          return T;
      }, "JsdocTypeNamePath"),
      JsdocTypeUnion: r((t, o) => ut("UNION", t.elements.map(o)), "JsdocTypeUnion"),
      JsdocTypeParenthesis: r((t, o) => ({
        type: "PARENTHESIS",
        value: o(w(t.element))
      }), "JsdocTypeParenthesis"),
      JsdocTypeNull: r(() => ({
        type: "NAME",
        name: "null"
      }), "JsdocTypeNull"),
      JsdocTypeUnknown: r(() => ({
        type: "UNKNOWN"
      }), "JsdocTypeUnknown"),
      JsdocTypeStringValue: r((t) => ({
        type: "STRING_VALUE",
        quoteStyle: W(t.meta.quote),
        string: t.value
      }), "JsdocTypeStringValue"),
      JsdocTypeIntersection: r((t, o) => ut("INTERSECTION", t.elements.map(o)), "JsdocTypeIntersection"),
      JsdocTypeNumber: r((t) => ({
        type: "NUMBER_VALUE",
        number: t.value.toString()
      }), "JsdocTypeNumber"),
      JsdocTypeSymbol: I,
      JsdocTypeProperty: I,
      JsdocTypePredicate: I,
      JsdocTypeMappedType: I,
      JsdocTypeIndexSignature: I
    };
    function Gs(t) {
      return Te($s, t);
    }
    r(Gs, "jtpTransform");
    function Ys() {
      return {
        JsdocTypeIntersection: r((t, o) => ({
          type: "JsdocTypeIntersection",
          elements: t.elements.map(o)
        }), "JsdocTypeIntersection"),
        JsdocTypeGeneric: r((t, o) => ({
          type: "JsdocTypeGeneric",
          left: o(t.left),
          elements: t.elements.map(o),
          meta: {
            dot: t.meta.dot,
            brackets: t.meta.brackets
          }
        }), "JsdocTypeGeneric"),
        JsdocTypeNullable: r((t) => t, "JsdocTypeNullable"),
        JsdocTypeUnion: r((t, o) => ({
          type: "JsdocTypeUnion",
          elements: t.elements.map(o)
        }), "JsdocTypeUnion"),
        JsdocTypeUnknown: r((t) => t, "JsdocTypeUnknown"),
        JsdocTypeUndefined: r((t) => t, "JsdocTypeUndefined"),
        JsdocTypeTypeof: r((t, o) => ({
          type: "JsdocTypeTypeof",
          element: o(t.element)
        }), "JsdocTypeTypeof"),
        JsdocTypeSymbol: r((t, o) => {
          let i = {
            type: "JsdocTypeSymbol",
            value: t.value
          };
          return t.element !== void 0 && (i.element = o(t.element)), i;
        }, "JsdocTypeSymbol"),
        JsdocTypeOptional: r((t, o) => ({
          type: "JsdocTypeOptional",
          element: o(t.element),
          meta: {
            position: t.meta.position
          }
        }), "JsdocTypeOptional"),
        JsdocTypeObject: r((t, o) => ({
          type: "JsdocTypeObject",
          meta: {
            separator: "comma"
          },
          elements: t.elements.map(o)
        }), "JsdocTypeObject"),
        JsdocTypeNumber: r((t) => t, "JsdocTypeNumber"),
        JsdocTypeNull: r((t) => t, "JsdocTypeNull"),
        JsdocTypeNotNullable: r((t, o) => ({
          type: "JsdocTypeNotNullable",
          element: o(t.element),
          meta: {
            position: t.meta.position
          }
        }), "JsdocTypeNotNullable"),
        JsdocTypeSpecialNamePath: r((t) => t, "JsdocTypeSpecialNamePath"),
        JsdocTypeObjectField: r((t, o) => ({
          type: "JsdocTypeObjectField",
          key: t.key,
          right: t.right === void 0 ? void 0 : o(t.right),
          optional: t.optional,
          readonly: t.readonly,
          meta: t.meta
        }), "JsdocTypeObjectField"),
        JsdocTypeJsdocObjectField: r((t, o) => ({
          type: "JsdocTypeJsdocObjectField",
          left: o(t.left),
          right: o(t.right)
        }), "JsdocTypeJsdocObjectField"),
        JsdocTypeKeyValue: r((t, o) => ({
          type: "JsdocTypeKeyValue",
          key: t.key,
          right: t.right === void 0 ? void 0 : o(t.right),
          optional: t.optional,
          variadic: t.variadic
        }), "JsdocTypeKeyValue"),
        JsdocTypeImport: r((t, o) => ({
          type: "JsdocTypeImport",
          element: o(t.element)
        }), "JsdocTypeImport"),
        JsdocTypeAny: r((t) => t, "JsdocTypeAny"),
        JsdocTypeStringValue: r((t) => t, "JsdocTypeStringValue"),
        JsdocTypeNamePath: r((t) => t, "JsdocTypeNamePath"),
        JsdocTypeVariadic: r((t, o) => {
          let i = {
            type: "JsdocTypeVariadic",
            meta: {
              position: t.meta.position,
              squareBrackets: t.meta.squareBrackets
            }
          };
          return t.element !== void 0 && (i.element = o(t.element)), i;
        }, "JsdocTypeVariadic"),
        JsdocTypeTuple: r((t, o) => ({
          type: "JsdocTypeTuple",
          elements: t.elements.map(o)
        }), "JsdocTypeTuple"),
        JsdocTypeName: r((t) => t, "JsdocTypeName"),
        JsdocTypeFunction: r((t, o) => {
          let i = {
            type: "JsdocTypeFunction",
            arrow: t.arrow,
            parameters: t.parameters.map(o),
            constructor: t.constructor,
            parenthesis: t.parenthesis
          };
          return t.returnType !== void 0 && (i.returnType = o(t.returnType)), i;
        }, "JsdocTypeFunction"),
        JsdocTypeKeyof: r((t, o) => ({
          type: "JsdocTypeKeyof",
          element: o(t.element)
        }), "JsdocTypeKeyof"),
        JsdocTypeParenthesis: r((t, o) => ({
          type: "JsdocTypeParenthesis",
          element: o(t.element)
        }), "JsdocTypeParenthesis"),
        JsdocTypeProperty: r((t) => t, "JsdocTypeProperty"),
        JsdocTypePredicate: r((t, o) => ({
          type: "JsdocTypePredicate",
          left: o(t.left),
          right: o(t.right)
        }), "JsdocTypePredicate"),
        JsdocTypeIndexSignature: r((t, o) => ({
          type: "JsdocTypeIndexSignature",
          key: t.key,
          right: o(t.right)
        }), "JsdocTypeIndexSignature"),
        JsdocTypeMappedType: r((t, o) => ({
          type: "JsdocTypeMappedType",
          key: t.key,
          right: o(t.right)
        }), "JsdocTypeMappedType")
      };
    }
    r(Ys, "identityTransformRules");
    let ar = {
      JsdocTypeAny: [],
      JsdocTypeFunction: ["parameters", "returnType"],
      JsdocTypeGeneric: ["left", "elements"],
      JsdocTypeImport: [],
      JsdocTypeIndexSignature: ["right"],
      JsdocTypeIntersection: ["elements"],
      JsdocTypeKeyof: ["element"],
      JsdocTypeKeyValue: ["right"],
      JsdocTypeMappedType: ["right"],
      JsdocTypeName: [],
      JsdocTypeNamePath: ["left", "right"],
      JsdocTypeNotNullable: ["element"],
      JsdocTypeNull: [],
      JsdocTypeNullable: ["element"],
      JsdocTypeNumber: [],
      JsdocTypeObject: ["elements"],
      JsdocTypeObjectField: ["right"],
      JsdocTypeJsdocObjectField: ["left", "right"],
      JsdocTypeOptional: ["element"],
      JsdocTypeParenthesis: ["element"],
      JsdocTypeSpecialNamePath: [],
      JsdocTypeStringValue: [],
      JsdocTypeSymbol: ["element"],
      JsdocTypeTuple: ["elements"],
      JsdocTypeTypeof: ["element"],
      JsdocTypeUndefined: [],
      JsdocTypeUnion: ["elements"],
      JsdocTypeUnknown: [],
      JsdocTypeVariadic: ["element"],
      JsdocTypeProperty: [],
      JsdocTypePredicate: ["left", "right"]
    };
    function lt(t, o, i, u, f) {
      u == null ? void 0 : u(t, o, i);
      let T = ar[t.type];
      for (let x of T) {
        let S = t[x];
        if (S !== void 0)
          if (Array.isArray(S))
            for (let D of S)
              lt(D, t, x, u, f);
          else
            lt(S, t, x, u, f);
      }
      f == null ? void 0 : f(t, o, i);
    }
    r(lt, "_traverse");
    function Hs(t, o, i) {
      lt(t, void 0, void 0, o, i);
    }
    r(Hs, "traverse"), e.catharsisTransform = Ks, e.identityTransformRules = Ys, e.jtpTransform = Gs, e.parse = rr, e.stringify = Us, e.stringifyRules = or, e.transform = Te, e.traverse = Hs, e.tryParse = ks, e.visitorKeys = ar;
  });
});
var cr = /^['"]|['"]$/g;
var tp = r((e) => e.replace(cr, ""), "trimQuotes");
var rp = r((e) => cr.test(e), "includesQuotes");
var ke = r((e) => {
  let n = tp(e);
  return rp(e) || Number.isNaN(Number(n)) ? n : Number(n);
}, "parseLiteral");
var op = r((e) => {
  switch (e.type) {
    case "function":
      return { name: "function" };
    case "object":
      let n = {};
      return e.signature.properties.forEach((a) => {
        n[a.key] = te(a.value);
      }), {
        name: "object",
        value: n
      };
    default:
      throw new import_preview_errors.UnknownArgTypesError({ type: e, language: "Typescript" });
  }
}, "convertSig");
var te = r((e) => {
  var _a, _b, _c, _d;
  let { name: n, raw: a } = e, s = {};
  switch (typeof a < "u" && (s.raw = a), e.name) {
    case "string":
    case "number":
    case "symbol":
    case "boolean":
      return { ...s, name: n };
    case "Array":
      return { ...s, name: "array", value: e.elements.map(te) };
    case "signature":
      return { ...s, ...op(e) };
    case "union":
      let p;
      return ((_a = e.elements) == null ? void 0 : _a.every((c) => c.name === "literal")) ? p = {
        ...s,
        name: "enum",
        // @ts-expect-error fix types
        value: (_b = e.elements) == null ? void 0 : _b.map((c) => ke(c.value))
      } : p = { ...s, name: n, value: (_c = e.elements) == null ? void 0 : _c.map(te) }, p;
    case "intersection":
      return { ...s, name: n, value: (_d = e.elements) == null ? void 0 : _d.map(te) };
    default:
      return { ...s, name: "other", value: n };
  }
}, "convert");
var ip = r((e) => e.name === "literal", "isLiteral");
var sp = r((e) => e.value.replace(/['|"]/g, ""), "toEnumOption");
var pp = r((e) => {
  switch (e.type) {
    case "function":
      return { name: "function" };
    case "object":
      let n = {};
      return e.signature.properties.forEach((a) => {
        n[a.key] = re(a.value);
      }), {
        name: "object",
        value: n
      };
    default:
      throw new import_preview_errors2.UnknownArgTypesError({ type: e, language: "Flow" });
  }
}, "convertSig");
var re = r((e) => {
  var _a, _b, _c, _d;
  let { name: n, raw: a } = e, s = {};
  switch (typeof a < "u" && (s.raw = a), e.name) {
    case "literal":
      return { ...s, name: "other", value: e.value };
    case "string":
    case "number":
    case "symbol":
    case "boolean":
      return { ...s, name: n };
    case "Array":
      return { ...s, name: "array", value: e.elements.map(re) };
    case "signature":
      return { ...s, ...pp(e) };
    case "union":
      return ((_a = e.elements) == null ? void 0 : _a.every(ip)) ? { ...s, name: "enum", value: (_b = e.elements) == null ? void 0 : _b.map(sp) } : { ...s, name: n, value: (_c = e.elements) == null ? void 0 : _c.map(re) };
    case "intersection":
      return { ...s, name: n, value: (_d = e.elements) == null ? void 0 : _d.map(re) };
    default:
      return { ...s, name: "other", value: n };
  }
}, "convert");
var Mi = pr(Ui(), 1);
var wm = /^\(.*\) => /;
var fe = r((e) => {
  let { name: n, raw: a, computed: s, value: p } = e, c = {};
  switch (typeof a < "u" && (c.raw = a), n) {
    case "enum": {
      let d = s ? p : p.map((m) => ke(m.value));
      return { ...c, name: n, value: d };
    }
    case "string":
    case "number":
    case "symbol":
      return { ...c, name: n };
    case "func":
      return { ...c, name: "function" };
    case "bool":
    case "boolean":
      return { ...c, name: "boolean" };
    case "arrayOf":
    case "array":
      return { ...c, name: "array", value: p && fe(p) };
    case "object":
      return { ...c, name: n };
    case "objectOf":
      return { ...c, name: n, value: fe(p) };
    case "shape":
    case "exact":
      let y = (0, Mi.default)(p, (d) => fe(d));
      return { ...c, name: "object", value: y };
    case "union":
      return { ...c, name: "union", value: p.map((d) => fe(d)) };
    case "instanceOf":
    case "element":
    case "elementType":
    default: {
      if ((n == null ? void 0 : n.indexOf("|")) > 0)
        try {
          let g = n.split("|").map((b) => JSON.parse(b));
          return { ...c, name: "enum", value: g };
        } catch {
        }
      let d = p ? `${n}(${p})` : n, m = wm.test(n) ? "function" : "other";
      return { ...c, name: m, value: d };
    }
  }
}, "convert");
var He = r((e) => {
  let { type: n, tsType: a, flowType: s } = e;
  try {
    if (n != null) return fe(n);
    if (a != null) return te(a);
    if (s != null) return re(s);
  } catch (p) {
    console.error(p);
  }
  return null;
}, "convert");
var Pm = ((p) => (p.JAVASCRIPT = "JavaScript", p.FLOW = "Flow", p.TYPESCRIPT = "TypeScript", p.UNKNOWN = "Unknown", p))(Pm || {});
var Jm = ["null", "undefined"];
function ye(e) {
  return Jm.some((n) => n === e);
}
r(ye, "isDefaultValueBlacklisted");
var Vi = r((e) => {
  if (!e)
    return "";
  if (typeof e == "string")
    return e;
  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);
}, "str");
function Ki(e) {
  return !!e.__docgenInfo;
}
r(Ki, "hasDocgen");
function Bi(e) {
  return e != null && Object.keys(e).length > 0;
}
r(Bi, "isValidDocgenSection");
function $i(e, n) {
  return Ki(e) ? e.__docgenInfo[n] : null;
}
r($i, "getDocgenSection");
function Gi(e) {
  return Ki(e) ? Vi(e.__docgenInfo.description) : "";
}
r(Gi, "getDocgenDescription");
var F;
(function(e) {
  e.start = "/**", e.nostart = "/***", e.delim = "*", e.end = "*/";
})(F = F || (F = {}));
function Ct(e) {
  return /^\s+$/.test(e);
}
r(Ct, "isSpace");
function Yi(e) {
  let n = e.match(/\r+$/);
  return n == null ? ["", e] : [e.slice(-n[0].length), e.slice(0, -n[0].length)];
}
r(Yi, "splitCR");
function V(e) {
  let n = e.match(/^\s+/);
  return n == null ? ["", e] : [e.slice(0, n[0].length), e.slice(n[0].length)];
}
r(V, "splitSpace");
function Hi(e) {
  return e.split(/\n/);
}
r(Hi, "splitLines");
function zi(e = {}) {
  return Object.assign({ tag: "", name: "", type: "", optional: false, description: "", problems: [], source: [] }, e);
}
r(zi, "seedSpec");
function Ut(e = {}) {
  return Object.assign({
    start: "",
    delimiter: "",
    postDelimiter: "",
    tag: "",
    postTag: "",
    name: "",
    postName: "",
    type: "",
    postType: "",
    description: "",
    end: "",
    lineEnd: ""
  }, e);
}
r(Ut, "seedTokens");
var Sm = /^@\S+/;
function Mt2({ fence: e = "```" } = {}) {
  let n = Em(e), a = r((s, p) => n(s) ? !p : p, "toggleFence");
  return r(function(p) {
    let c = [[]], y = false;
    for (let d of p)
      Sm.test(d.tokens.description) && !y ? c.push([d]) : c[c.length - 1].push(d), y = a(d.tokens.description, y);
    return c;
  }, "parseBlock");
}
r(Mt2, "getParser");
function Em(e) {
  return typeof e == "string" ? (n) => n.split(e).length % 2 === 0 : e;
}
r(Em, "getFencer");
function Vt({ startLine: e = 0, markers: n = F } = {}) {
  let a = null, s = e;
  return r(function(c) {
    let y = c, d = Ut();
    if ([d.lineEnd, y] = Yi(y), [d.start, y] = V(y), a === null && y.startsWith(n.start) && !y.startsWith(n.nostart) && (a = [], d.delimiter = y.slice(0, n.start.length), y = y.slice(n.start.length), [d.postDelimiter, y] = V(y)), a === null)
      return s++, null;
    let m = y.trimRight().endsWith(n.end);
    if (d.delimiter === "" && y.startsWith(n.delim) && !y.startsWith(n.end) && (d.delimiter = n.delim, y = y.slice(n.delim.length), [
      d.postDelimiter,
      y
    ] = V(y)), m) {
      let g = y.trimRight();
      d.end = y.slice(g.length - n.end.length), y = g.slice(0, -n.end.length);
    }
    if (d.description = y, a.push({ number: s, source: c, tokens: d }), s++, m) {
      let g = a.slice();
      return a = null, g;
    }
    return null;
  }, "parseSource");
}
r(Vt, "getParser");
function Kt({ tokenizers: e }) {
  return r(function(a) {
    var s;
    let p = zi({ source: a });
    for (let c of e)
      if (p = c(p), !((s = p.problems[p.problems.length - 1]) === null || s === void 0) && s.critical)
        break;
    return p;
  }, "parseSpec");
}
r(Kt, "getParser");
function ze() {
  return (e) => {
    let { tokens: n } = e.source[0], a = n.description.match(/\s*(@(\S+))(\s*)/);
    return a === null ? (e.problems.push({
      code: "spec:tag:prefix",
      message: 'tag should start with "@" symbol',
      line: e.source[0].number,
      critical: true
    }), e) : (n.tag = a[1], n.postTag = a[3], n.description = n.description.slice(a[0].length), e.tag = a[2], e);
  };
}
r(ze, "tagTokenizer");
function We(e = "compact") {
  let n = Am(e);
  return (a) => {
    let s = 0, p = [];
    for (let [d, { tokens: m }] of a.source.entries()) {
      let g = "";
      if (d === 0 && m.description[0] !== "{")
        return a;
      for (let b of m.description)
        if (b === "{" && s++, b === "}" && s--, g += b, s === 0)
          break;
      if (p.push([m, g]), s === 0)
        break;
    }
    if (s !== 0)
      return a.problems.push({
        code: "spec:type:unpaired-curlies",
        message: "unpaired curlies",
        line: a.source[0].number,
        critical: true
      }), a;
    let c = [], y = p[0][0].postDelimiter.length;
    for (let [d, [m, g]] of p.entries())
      m.type = g, d > 0 && (m.type = m.postDelimiter.slice(y) + g, m.postDelimiter = m.postDelimiter.slice(0, y)), [m.postType, m.description] = V(m.description.slice(g.length)), c.push(m.type);
    return c[0] = c[0].slice(1), c[c.length - 1] = c[c.length - 1].slice(0, -1), a.type = n(c), a;
  };
}
r(We, "typeTokenizer");
var Om = r((e) => e.trim(), "trim");
function Am(e) {
  return e === "compact" ? (n) => n.map(Om).join("") : e === "preserve" ? (n) => n.join(`
`) : e;
}
r(Am, "getJoiner");
var Nm = r((e) => e && e.startsWith('"') && e.endsWith('"'), "isQuoted");
function Xe() {
  let e = r((n, { tokens: a }, s) => a.type === "" ? n : s, "typeEnd");
  return (n) => {
    let { tokens: a } = n.source[n.source.reduce(e, 0)], s = a.description.trimLeft(), p = s.split('"');
    if (p.length > 1 && p[0] === "" && p.length % 2 === 1)
      return n.name = p[1], a.name = `"${p[1]}"`, [a.postName, a.description] = V(s.slice(a.name.length)), n;
    let c = 0, y = "", d = false, m;
    for (let b of s) {
      if (c === 0 && Ct(b))
        break;
      b === "[" && c++, b === "]" && c--, y += b;
    }
    if (c !== 0)
      return n.problems.push({
        code: "spec:name:unpaired-brackets",
        message: "unpaired brackets",
        line: n.source[0].number,
        critical: true
      }), n;
    let g = y;
    if (y[0] === "[" && y[y.length - 1] === "]") {
      d = true, y = y.slice(1, -1);
      let b = y.split("=");
      if (y = b[0].trim(), b[1] !== void 0 && (m = b.slice(1).join("=").trim()), y === "")
        return n.problems.push({
          code: "spec:name:empty-name",
          message: "empty name",
          line: n.source[0].number,
          critical: true
        }), n;
      if (m === "")
        return n.problems.push({
          code: "spec:name:empty-default",
          message: "empty default value",
          line: n.source[0].number,
          critical: true
        }), n;
      if (!Nm(m) && /=(?!>)/.test(m))
        return n.problems.push({
          code: "spec:name:invalid-default",
          message: "invalid default value syntax",
          line: n.source[0].number,
          critical: true
        }), n;
    }
    return n.optional = d, n.name = y, a.name = g, m !== void 0 && (n.default = m), [a.postName, a.description] = V(s.slice(a.name.length)), n;
  };
}
r(Xe, "nameTokenizer");
function Qe(e = "compact", n = F) {
  let a = Bt(e);
  return (s) => (s.description = a(s.source, n), s);
}
r(Qe, "descriptionTokenizer");
function Bt(e) {
  return e === "compact" ? _m2 : e === "preserve" ? Im : e;
}
r(Bt, "getJoiner");
function _m2(e, n = F) {
  return e.map(({ tokens: { description: a } }) => a.trim()).filter((a) => a !== "").join(" ");
}
r(_m2, "compactJoiner");
var Dm = r((e, { tokens: n }, a) => n.type === "" ? e : a, "lineNo");
var qm = r(({ tokens: e }) => (e.delimiter === "" ? e.start : e.postDelimiter.slice(1)) + e.description, "getDescription");
function Im(e, n = F) {
  if (e.length === 0)
    return "";
  e[0].tokens.description === "" && e[0].tokens.delimiter === n.start && (e = e.slice(1));
  let a = e[e.length - 1];
  return a !== void 0 && a.tokens.description === "" && a.tokens.end.endsWith(n.end) && (e = e.slice(0, -1)), e = e.slice(e.reduce(Dm, 0)), e.map(qm).join(`
`);
}
r(Im, "preserveJoiner");
function $t({ startLine: e = 0, fence: n = "```", spacing: a = "compact", markers: s = F, tokenizers: p = [
  ze(),
  We(a),
  Xe(),
  Qe(a)
] } = {}) {
  if (e < 0 || e % 1 > 0)
    throw new Error("Invalid startLine");
  let c = Vt({ startLine: e, markers: s }), y = Mt2({ fence: n }), d = Kt({ tokenizers: p }), m = Bt(a);
  return function(g) {
    let b = [];
    for (let A2 of Hi(g)) {
      let J = c(A2);
      if (J === null)
        continue;
      let v = y(J), N = v.slice(1).map(d);
      b.push({
        description: m(v[0], s),
        tags: N,
        source: J,
        problems: N.reduce((q, R) => q.concat(R.problems), [])
      });
    }
    return b;
  };
}
r($t, "getParser");
function Rm(e) {
  return e.start + e.delimiter + e.postDelimiter + e.tag + e.postTag + e.type + e.postType + e.name + e.postName + e.description + e.end + e.lineEnd;
}
r(Rm, "join");
function Gt() {
  return (e) => e.source.map(({ tokens: n }) => Rm(n)).join(`
`);
}
r(Gt, "getStringifier");
var jm = {
  line: 0,
  start: 0,
  delimiter: 0,
  postDelimiter: 0,
  tag: 0,
  postTag: 0,
  name: 0,
  postName: 0,
  type: 0,
  postType: 0,
  description: 0,
  end: 0,
  lineEnd: 0
};
var Dv = Object.keys(jm);
function Wi(e, n = {}) {
  return $t(n)(e);
}
r(Wi, "parse");
var Qv = Gt();
var de = pr(Qi(), 1);
function Fm(e) {
  return e != null && e.includes("@");
}
r(Fm, "containsJsDoc");
function Lm(e) {
  let s = `/**
` + (e ?? "").split(`
`).map((c) => ` * ${c}`).join(`
`) + `
*/`, p = Wi(s, {
    spacing: "preserve"
  });
  if (!p || p.length === 0)
    throw new Error("Cannot parse JSDoc tags.");
  return p[0];
}
r(Lm, "parse");
var km = {
  tags: ["param", "arg", "argument", "returns", "ignore", "deprecated"]
};
var Zi = r((e, n = km) => {
  if (!Fm(e))
    return {
      includesJsDoc: false,
      ignore: false
    };
  let a = Lm(e), s = Cm(a, n.tags);
  return s.ignore ? {
    includesJsDoc: true,
    ignore: true
  } : {
    includesJsDoc: true,
    ignore: false,
    // Always use the parsed description to ensure JSDoc is removed from the description.
    description: a.description.trim(),
    extractedTags: s
  };
}, "parseJsDoc");
function Cm(e, n) {
  let a = {
    params: null,
    deprecated: null,
    returns: null,
    ignore: false
  };
  for (let s of e.tags)
    if (!(n !== void 0 && !n.includes(s.tag)))
      if (s.tag === "ignore") {
        a.ignore = true;
        break;
      } else
        switch (s.tag) {
          case "param":
          case "arg":
          case "argument": {
            let p = Mm(s);
            p != null && (a.params == null && (a.params = []), a.params.push(p));
            break;
          }
          case "deprecated": {
            let p = Vm(s);
            p != null && (a.deprecated = p);
            break;
          }
          case "returns": {
            let p = Km(s);
            p != null && (a.returns = p);
            break;
          }
          default:
            break;
        }
  return a;
}
r(Cm, "extractJsDocTags");
function Um(e) {
  return e.replace(/[\.-]$/, "");
}
r(Um, "normaliseParamName");
function Mm(e) {
  if (!e.name || e.name === "-")
    return null;
  let n = rs(e.type);
  return {
    name: e.name,
    type: n,
    description: ts(e.description),
    getPrettyName: r(() => Um(e.name), "getPrettyName"),
    getTypeName: r(() => n ? ns(n) : null, "getTypeName")
  };
}
r(Mm, "extractParam");
function Vm(e) {
  return e.name ? es(e.name, e.description) : null;
}
r(Vm, "extractDeprecated");
function es(e, n) {
  let a = e === "" ? n : `${e} ${n}`;
  return ts(a);
}
r(es, "joinNameAndDescription");
function ts(e) {
  let n = e.replace(/^- /g, "").trim();
  return n === "" ? null : n;
}
r(ts, "normaliseDescription");
function Km(e) {
  let n = rs(e.type);
  return n ? {
    type: n,
    description: es(e.name, e.description),
    getTypeName: r(() => ns(n), "getTypeName")
  } : null;
}
r(Km, "extractReturns");
var z = (0, de.stringifyRules)();
var Bm = z.JsdocTypeObject;
z.JsdocTypeAny = () => "any";
z.JsdocTypeObject = (e, n) => `(${Bm(e, n)})`;
z.JsdocTypeOptional = (e, n) => n(e.element);
z.JsdocTypeNullable = (e, n) => n(e.element);
z.JsdocTypeNotNullable = (e, n) => n(e.element);
z.JsdocTypeUnion = (e, n) => e.elements.map(n).join("|");
function rs(e) {
  try {
    return (0, de.parse)(e, "typescript");
  } catch {
    return null;
  }
}
r(rs, "extractType");
function ns(e) {
  return (0, de.transform)(z, e);
}
r(ns, "extractTypeName");
function Ht(e) {
  return e.length > 90;
}
r(Ht, "isTooLongForTypeSummary");
function os(e) {
  return e.length > 50;
}
r(os, "isTooLongForDefaultValueSummary");
function O(e, n) {
  return e === n ? { summary: e } : { summary: e, detail: n };
}
r(O, "createSummaryValue");
var cw = r((e) => e.replace(/\\r\\n/g, "\\n"), "normalizeNewlines");
function as({ name: e, value: n, elements: a, raw: s }) {
  return n ?? (a != null ? a.map(as).join(" | ") : s ?? e);
}
r(as, "generateUnionElement");
function $m({ name: e, raw: n, elements: a }) {
  return a != null ? O(a.map(as).join(" | ")) : n != null ? O(n.replace(/^\|\s*/, "")) : O(e);
}
r($m, "generateUnion");
function Gm({ type: e, raw: n }) {
  return n != null ? O(n) : O(e);
}
r(Gm, "generateFuncSignature");
function Ym({ type: e, raw: n }) {
  return n != null ? Ht(n) ? O(e, n) : O(n) : O(e);
}
r(Ym, "generateObjectSignature");
function Hm(e) {
  let { type: n } = e;
  return n === "object" ? Ym(e) : Gm(e);
}
r(Hm, "generateSignature");
function zm({ name: e, raw: n }) {
  return n != null ? Ht(n) ? O(e, n) : O(n) : O(e);
}
r(zm, "generateDefault");
function is(e) {
  if (e == null)
    return null;
  switch (e.name) {
    case "union":
      return $m(e);
    case "signature":
      return Hm(e);
    default:
      return zm(e);
  }
}
r(is, "createType");
function ss(e, n) {
  if (e != null) {
    let { value: a } = e;
    if (!ye(a))
      return os(a) ? O(n == null ? void 0 : n.name, a) : O(a);
  }
  return null;
}
r(ss, "createDefaultValue");
var ps = r((e, n) => {
  let { flowType: a, description: s, required: p, defaultValue: c } = n;
  return {
    name: e,
    type: is(a),
    required: p,
    description: s,
    defaultValue: ss(c ?? null, a ?? null)
  };
}, "createFlowPropDef");
function cs({ tsType: e, required: n }) {
  if (e == null)
    return null;
  let a = e.name;
  return n || (a = a.replace(" | undefined", "")), O(
    ["Array", "Record", "signature"].includes(e.name) ? e.raw : a
  );
}
r(cs, "createType");
function us({ defaultValue: e }) {
  if (e != null) {
    let { value: n } = e;
    if (!ye(n))
      return O(n);
  }
  return null;
}
r(us, "createDefaultValue");
var ls = r((e, n) => {
  let { description: a, required: s } = n;
  return {
    name: e,
    type: cs(n),
    required: s,
    description: a,
    defaultValue: us(n)
  };
}, "createTsPropDef");
function Wm(e) {
  return e != null ? O(e.name) : null;
}
r(Wm, "createType");
function Xm(e) {
  let { computed: n, func: a } = e;
  return typeof n > "u" && typeof a > "u";
}
r(Xm, "isReactDocgenTypescript");
function Qm(e) {
  return e ? e.name === "string" ? true : e.name === "enum" ? Array.isArray(e.value) && e.value.every(
    ({ value: n }) => typeof n == "string" && n[0] === '"' && n[n.length - 1] === '"'
  ) : false : false;
}
r(Qm, "isStringValued");
function Zm(e, n) {
  if (e != null) {
    let { value: a } = e;
    if (!ye(a))
      return Xm(e) && Qm(n) ? O(JSON.stringify(a)) : O(a);
  }
  return null;
}
r(Zm, "createDefaultValue");
function fs(e, n, a) {
  let { description: s, required: p, defaultValue: c } = a;
  return {
    name: e,
    type: Wm(n),
    required: p,
    description: s,
    defaultValue: Zm(c, n)
  };
}
r(fs, "createBasicPropDef");
function et(e, n) {
  var _a;
  if (n == null ? void 0 : n.includesJsDoc) {
    let { description: a, extractedTags: s } = n;
    a != null && (e.description = n.description);
    let p = {
      ...s,
      params: (_a = s == null ? void 0 : s.params) == null ? void 0 : _a.map(
        (c) => ({
          name: c.getPrettyName(),
          description: c.description
        })
      )
    };
    Object.values(p).filter(Boolean).length > 0 && (e.jsDocTags = p);
  }
  return e;
}
r(et, "applyJsDocResult");
var eT = r((e, n, a) => {
  let s = fs(e, n.type, n);
  return s.sbType = He(n), et(s, a);
}, "javaScriptFactory");
var tT = r((e, n, a) => {
  let s = ls(e, n);
  return s.sbType = He(n), et(s, a);
}, "tsFactory");
var rT = r((e, n, a) => {
  let s = ps(e, n);
  return s.sbType = He(n), et(s, a);
}, "flowFactory");
var nT = r((e, n, a) => {
  let s = fs(e, { name: "unknown" }, n);
  return et(s, a);
}, "unknownFactory");
var zt = r((e) => {
  switch (e) {
    case "JavaScript":
      return eT;
    case "TypeScript":
      return tT;
    case "Flow":
      return rT;
    default:
      return nT;
  }
}, "getPropDefFactory");
var ys = r(
  (e) => e.type != null ? "JavaScript" : e.flowType != null ? "Flow" : e.tsType != null ? "TypeScript" : "Unknown",
  "getTypeSystem"
);
var oT = r((e) => {
  let n = ys(e[0]), a = zt(n);
  return e.map((s) => {
    var _a;
    let p = s;
    return ((_a = s.type) == null ? void 0 : _a.elements) && (p = {
      ...s,
      type: {
        ...s.type,
        value: s.type.elements
      }
    }), ds(p.name, p, n, a);
  });
}, "extractComponentSectionArray");
var aT = r((e) => {
  let n = Object.keys(e), a = ys(e[n[0]]), s = zt(a);
  return n.map((p) => {
    let c = e[p];
    return c != null ? ds(p, c, a, s) : null;
  }).filter(Boolean);
}, "extractComponentSectionObject");
var Bw = r((e, n) => {
  let a = $i(e, n);
  return Bi(a) ? Array.isArray(a) ? oT(a) : aT(a) : [];
}, "extractComponentProps");
function ds(e, n, a, s) {
  let p = Zi(n.description);
  return p.includesJsDoc && p.ignore ? null : {
    propDef: s(e, n, p),
    jsDocTags: p.extractedTags,
    docgenInfo: n,
    typeSystem: a
  };
}
r(ds, "extractProp");
function $w(e) {
  return e != null ? Gi(e) : "";
}
r($w, "extractComponentDescription");
var zw = r((e) => {
  let {
    component: n,
    argTypes: a,
    parameters: { docs: s = {} }
  } = e, { extractArgTypes: p } = s, c = p && n ? p(n) : {};
  return c ? (0, import_preview_api.combineParameters)(c, a) : a;
}, "enhanceArgTypes");
var ms = "storybook/docs";
var Qw = `${ms}/panel`;
var eP = `${ms}/snippet-rendered`;
var sT = ((s) => (s.AUTO = "auto", s.CODE = "code", s.DYNAMIC = "dynamic", s))(sT || {});
var pT = /(addons\/|addon-|addon-essentials\/)(docs|controls)/;
var rP = r((e) => {
  var _a;
  return (_a = e.presetsList) == null ? void 0 : _a.some((n) => pT.test(n.name));
}, "hasDocsOrControls");

// node_modules/@storybook/blocks/dist/index.mjs
var import_core_events = __toESM(require_core_events(), 1);
var import_channels = __toESM(require_channels(), 1);
var require_default_options = __commonJS2({ "../../node_modules/tocbot/src/js/default-options.js"(exports, module) {
  module.exports = { tocSelector: ".js-toc", contentSelector: ".js-toc-content", headingSelector: "h1, h2, h3", ignoreSelector: ".js-toc-ignore", hasInnerContainers: false, linkClass: "toc-link", extraLinkClasses: "", activeLinkClass: "is-active-link", listClass: "toc-list", extraListClasses: "", isCollapsedClass: "is-collapsed", collapsibleClass: "is-collapsible", listItemClass: "toc-list-item", activeListItemClass: "is-active-li", collapseDepth: 0, scrollSmooth: true, scrollSmoothDuration: 420, scrollSmoothOffset: 0, scrollEndCallback: function(e) {
  }, headingsOffset: 1, throttleTimeout: 50, positionFixedSelector: null, positionFixedClass: "is-position-fixed", fixedSidebarOffset: "auto", includeHtml: false, includeTitleTags: false, onClick: function(e) {
  }, orderedList: true, scrollContainer: null, skipRendering: false, headingLabelCallback: false, ignoreHiddenElements: false, headingObjectCallback: null, basePath: "", disableTocScrollSync: false, tocScrollOffset: 0 };
} });
var require_build_html = __commonJS2({ "../../node_modules/tocbot/src/js/build-html.js"(exports, module) {
  module.exports = function(options) {
    var forEach = [].forEach, some = [].some, body = document.body, tocElement, currentlyHighlighting = true, SPACE_CHAR = " ";
    function createEl(d, container) {
      var link = container.appendChild(createLink(d));
      if (d.children.length) {
        var list = createList(d.isCollapsed);
        d.children.forEach(function(child) {
          createEl(child, list);
        }), link.appendChild(list);
      }
    }
    function render(parent, data) {
      var collapsed = false, container = createList(collapsed);
      if (data.forEach(function(d) {
        createEl(d, container);
      }), tocElement = parent || tocElement, tocElement !== null) return tocElement.firstChild && tocElement.removeChild(tocElement.firstChild), data.length === 0 ? tocElement : tocElement.appendChild(container);
    }
    function createLink(data) {
      var item = document.createElement("li"), a = document.createElement("a");
      return options.listItemClass && item.setAttribute("class", options.listItemClass), options.onClick && (a.onclick = options.onClick), options.includeTitleTags && a.setAttribute("title", data.textContent), options.includeHtml && data.childNodes.length ? forEach.call(data.childNodes, function(node) {
        a.appendChild(node.cloneNode(true));
      }) : a.textContent = data.textContent, a.setAttribute("href", options.basePath + "#" + data.id), a.setAttribute("class", options.linkClass + SPACE_CHAR + "node-name--" + data.nodeName + SPACE_CHAR + options.extraLinkClasses), item.appendChild(a), item;
    }
    function createList(isCollapsed) {
      var listElement = options.orderedList ? "ol" : "ul", list = document.createElement(listElement), classes = options.listClass + SPACE_CHAR + options.extraListClasses;
      return isCollapsed && (classes = classes + SPACE_CHAR + options.collapsibleClass, classes = classes + SPACE_CHAR + options.isCollapsedClass), list.setAttribute("class", classes), list;
    }
    function updateFixedSidebarClass() {
      if (options.scrollContainer && document.querySelector(options.scrollContainer)) {
        var top;
        top = document.querySelector(options.scrollContainer).scrollTop;
      } else top = document.documentElement.scrollTop || body.scrollTop;
      var posFixedEl = document.querySelector(options.positionFixedSelector);
      options.fixedSidebarOffset === "auto" && (options.fixedSidebarOffset = tocElement.offsetTop), top > options.fixedSidebarOffset ? posFixedEl.className.indexOf(options.positionFixedClass) === -1 && (posFixedEl.className += SPACE_CHAR + options.positionFixedClass) : posFixedEl.className = posFixedEl.className.replace(SPACE_CHAR + options.positionFixedClass, "");
    }
    function getHeadingTopPos(obj) {
      var position = 0;
      return obj !== null && (position = obj.offsetTop, options.hasInnerContainers && (position += getHeadingTopPos(obj.offsetParent))), position;
    }
    function updateClassname(obj, className) {
      return obj && obj.className !== className && (obj.className = className), obj;
    }
    function updateToc(headingsArray) {
      if (options.scrollContainer && document.querySelector(options.scrollContainer)) {
        var top;
        top = document.querySelector(options.scrollContainer).scrollTop;
      } else top = document.documentElement.scrollTop || body.scrollTop;
      options.positionFixedSelector && updateFixedSidebarClass();
      var headings = headingsArray, topHeader;
      if (currentlyHighlighting && tocElement !== null && headings.length > 0) {
        some.call(headings, function(heading, i) {
          if (getHeadingTopPos(heading) > top + options.headingsOffset + 10) {
            var index = i === 0 ? i : i - 1;
            return topHeader = headings[index], true;
          } else if (i === headings.length - 1) return topHeader = headings[headings.length - 1], true;
        });
        var oldActiveTocLink = tocElement.querySelector("." + options.activeLinkClass), activeTocLink = tocElement.querySelector("." + options.linkClass + ".node-name--" + topHeader.nodeName + '[href="' + options.basePath + "#" + topHeader.id.replace(/([ #;&,.+*~':"!^$[\]()=>|/\\@])/g, "\\$1") + '"]');
        if (oldActiveTocLink === activeTocLink) return;
        var tocLinks = tocElement.querySelectorAll("." + options.linkClass);
        forEach.call(tocLinks, function(tocLink) {
          updateClassname(tocLink, tocLink.className.replace(SPACE_CHAR + options.activeLinkClass, ""));
        });
        var tocLis = tocElement.querySelectorAll("." + options.listItemClass);
        forEach.call(tocLis, function(tocLi) {
          updateClassname(tocLi, tocLi.className.replace(SPACE_CHAR + options.activeListItemClass, ""));
        }), activeTocLink && activeTocLink.className.indexOf(options.activeLinkClass) === -1 && (activeTocLink.className += SPACE_CHAR + options.activeLinkClass);
        var li = activeTocLink && activeTocLink.parentNode;
        li && li.className.indexOf(options.activeListItemClass) === -1 && (li.className += SPACE_CHAR + options.activeListItemClass);
        var tocLists = tocElement.querySelectorAll("." + options.listClass + "." + options.collapsibleClass);
        forEach.call(tocLists, function(list) {
          list.className.indexOf(options.isCollapsedClass) === -1 && (list.className += SPACE_CHAR + options.isCollapsedClass);
        }), activeTocLink && activeTocLink.nextSibling && activeTocLink.nextSibling.className.indexOf(options.isCollapsedClass) !== -1 && updateClassname(activeTocLink.nextSibling, activeTocLink.nextSibling.className.replace(SPACE_CHAR + options.isCollapsedClass, "")), removeCollapsedFromParents(activeTocLink && activeTocLink.parentNode.parentNode);
      }
    }
    function removeCollapsedFromParents(element) {
      return element && element.className.indexOf(options.collapsibleClass) !== -1 && element.className.indexOf(options.isCollapsedClass) !== -1 ? (updateClassname(element, element.className.replace(SPACE_CHAR + options.isCollapsedClass, "")), removeCollapsedFromParents(element.parentNode.parentNode)) : element;
    }
    function disableTocAnimation(event) {
      var target = event.target || event.srcElement;
      typeof target.className != "string" || target.className.indexOf(options.linkClass) === -1 || (currentlyHighlighting = false);
    }
    function enableTocAnimation() {
      currentlyHighlighting = true;
    }
    return { enableTocAnimation, disableTocAnimation, render, updateToc };
  };
} });
var require_parse_content = __commonJS2({ "../../node_modules/tocbot/src/js/parse-content.js"(exports, module) {
  module.exports = function(options) {
    var reduce = [].reduce;
    function getLastItem(array2) {
      return array2[array2.length - 1];
    }
    function getHeadingLevel(heading) {
      return +heading.nodeName.toUpperCase().replace("H", "");
    }
    function isHTMLElement(maybeElement) {
      try {
        return maybeElement instanceof window.HTMLElement || maybeElement instanceof window.parent.HTMLElement;
      } catch {
        return maybeElement instanceof window.HTMLElement;
      }
    }
    function getHeadingObject(heading) {
      if (!isHTMLElement(heading)) return heading;
      if (options.ignoreHiddenElements && (!heading.offsetHeight || !heading.offsetParent)) return null;
      let headingLabel = heading.getAttribute("data-heading-label") || (options.headingLabelCallback ? String(options.headingLabelCallback(heading.innerText)) : (heading.innerText || heading.textContent).trim());
      var obj = { id: heading.id, children: [], nodeName: heading.nodeName, headingLevel: getHeadingLevel(heading), textContent: headingLabel };
      return options.includeHtml && (obj.childNodes = heading.childNodes), options.headingObjectCallback ? options.headingObjectCallback(obj, heading) : obj;
    }
    function addNode(node, nest) {
      for (var obj = getHeadingObject(node), level = obj.headingLevel, array2 = nest, lastItem = getLastItem(array2), lastItemLevel = lastItem ? lastItem.headingLevel : 0, counter = level - lastItemLevel; counter > 0 && (lastItem = getLastItem(array2), !(lastItem && level === lastItem.headingLevel)); ) lastItem && lastItem.children !== void 0 && (array2 = lastItem.children), counter--;
      return level >= options.collapseDepth && (obj.isCollapsed = true), array2.push(obj), array2;
    }
    function selectHeadings(contentElement, headingSelector) {
      var selectors = headingSelector;
      options.ignoreSelector && (selectors = headingSelector.split(",").map(function(selector) {
        return selector.trim() + ":not(" + options.ignoreSelector + ")";
      }));
      try {
        return contentElement.querySelectorAll(selectors);
      } catch {
        return console.warn("Headers not found with selector: " + selectors), null;
      }
    }
    function nestHeadingsArray(headingsArray) {
      return reduce.call(headingsArray, function(prev, curr) {
        var currentHeading = getHeadingObject(curr);
        return currentHeading && addNode(currentHeading, prev.nest), prev;
      }, { nest: [] });
    }
    return { nestHeadingsArray, selectHeadings };
  };
} });
var require_update_toc_scroll = __commonJS2({ "../../node_modules/tocbot/src/js/update-toc-scroll.js"(exports, module) {
  module.exports = function(options) {
    var toc = options.tocElement || document.querySelector(options.tocSelector);
    if (toc && toc.scrollHeight > toc.clientHeight) {
      var activeItem = toc.querySelector("." + options.activeListItemClass);
      activeItem && (toc.scrollTop = activeItem.offsetTop - options.tocScrollOffset);
    }
  };
} });
var require_scroll_smooth = __commonJS2({ "../../node_modules/tocbot/src/js/scroll-smooth/index.js"(exports) {
  exports.initSmoothScrolling = initSmoothScrolling;
  function initSmoothScrolling(options) {
    var duration = options.duration, offset = options.offset, pageUrl = location.hash ? stripHash(location.href) : location.href;
    delegatedLinkHijacking();
    function delegatedLinkHijacking() {
      document.body.addEventListener("click", onClick, false);
      function onClick(e) {
        !isInPageLink(e.target) || e.target.className.indexOf("no-smooth-scroll") > -1 || e.target.href.charAt(e.target.href.length - 2) === "#" && e.target.href.charAt(e.target.href.length - 1) === "!" || e.target.className.indexOf(options.linkClass) === -1 || jump(e.target.hash, { duration, offset, callback: function() {
          setFocus(e.target.hash);
        } });
      }
    }
    function isInPageLink(n) {
      return n.tagName.toLowerCase() === "a" && (n.hash.length > 0 || n.href.charAt(n.href.length - 1) === "#") && (stripHash(n.href) === pageUrl || stripHash(n.href) + "#" === pageUrl);
    }
    function stripHash(url) {
      return url.slice(0, url.lastIndexOf("#"));
    }
    function setFocus(hash) {
      var element = document.getElementById(hash.substring(1));
      element && (/^(?:a|select|input|button|textarea)$/i.test(element.tagName) || (element.tabIndex = -1), element.focus());
    }
  }
  function jump(target, options) {
    var start = window.pageYOffset, opt = { duration: options.duration, offset: options.offset || 0, callback: options.callback, easing: options.easing || easeInOutQuad }, tgt = document.querySelector('[id="' + decodeURI(target).split("#").join("") + '"]') || document.querySelector('[id="' + target.split("#").join("") + '"]'), distance = typeof target == "string" ? opt.offset + (target ? tgt && tgt.getBoundingClientRect().top || 0 : -(document.documentElement.scrollTop || document.body.scrollTop)) : target, duration = typeof opt.duration == "function" ? opt.duration(distance) : opt.duration, timeStart, timeElapsed;
    requestAnimationFrame(function(time) {
      timeStart = time, loop(time);
    });
    function loop(time) {
      timeElapsed = time - timeStart, window.scrollTo(0, opt.easing(timeElapsed, start, distance, duration)), timeElapsed < duration ? requestAnimationFrame(loop) : end();
    }
    function end() {
      window.scrollTo(0, start + distance), typeof opt.callback == "function" && opt.callback();
    }
    function easeInOutQuad(t, b, c, d) {
      return t /= d / 2, t < 1 ? c / 2 * t * t + b : (t--, -c / 2 * (t * (t - 2) - 1) + b);
    }
  }
} });
var require_js = __commonJS2({ "../../node_modules/tocbot/src/js/index.js"(exports, module) {
  (function(root, factory) {
    typeof define == "function" && define.amd ? define([], factory(root)) : typeof exports == "object" ? module.exports = factory(root) : root.tocbot = factory(root);
  })(typeof global < "u" ? global : window || global, function(root) {
    var defaultOptions = require_default_options(), options = {}, tocbot2 = {}, BuildHtml = require_build_html(), ParseContent = require_parse_content(), updateTocScroll = require_update_toc_scroll(), buildHtml, parseContent, supports = !!root && !!root.document && !!root.document.querySelector && !!root.addEventListener;
    if (typeof window > "u" && !supports) return;
    var headingsArray, hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      for (var target = {}, i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) hasOwnProperty.call(source, key) && (target[key] = source[key]);
      }
      return target;
    }
    function throttle(fn2, threshold, scope) {
      threshold || (threshold = 250);
      var last, deferTimer;
      return function() {
        var context = scope || this, now = +/* @__PURE__ */ new Date(), args = arguments;
        last && now < last + threshold ? (clearTimeout(deferTimer), deferTimer = setTimeout(function() {
          last = now, fn2.apply(context, args);
        }, threshold)) : (last = now, fn2.apply(context, args));
      };
    }
    function getContentElement(options2) {
      try {
        return options2.contentElement || document.querySelector(options2.contentSelector);
      } catch {
        return console.warn("Contents element not found: " + options2.contentSelector), null;
      }
    }
    function getTocElement(options2) {
      try {
        return options2.tocElement || document.querySelector(options2.tocSelector);
      } catch {
        return console.warn("TOC element not found: " + options2.tocSelector), null;
      }
    }
    return tocbot2.destroy = function() {
      var tocElement = getTocElement(options);
      tocElement !== null && (options.skipRendering || tocElement && (tocElement.innerHTML = ""), options.scrollContainer && document.querySelector(options.scrollContainer) ? (document.querySelector(options.scrollContainer).removeEventListener("scroll", this._scrollListener, false), document.querySelector(options.scrollContainer).removeEventListener("resize", this._scrollListener, false), buildHtml && document.querySelector(options.scrollContainer).removeEventListener("click", this._clickListener, false)) : (document.removeEventListener("scroll", this._scrollListener, false), document.removeEventListener("resize", this._scrollListener, false), buildHtml && document.removeEventListener("click", this._clickListener, false)));
    }, tocbot2.init = function(customOptions) {
      if (supports) {
        options = extend(defaultOptions, customOptions || {}), this.options = options, this.state = {}, options.scrollSmooth && (options.duration = options.scrollSmoothDuration, options.offset = options.scrollSmoothOffset, tocbot2.scrollSmooth = require_scroll_smooth().initSmoothScrolling(options)), buildHtml = BuildHtml(options), parseContent = ParseContent(options), this._buildHtml = buildHtml, this._parseContent = parseContent, this._headingsArray = headingsArray, tocbot2.destroy();
        var contentElement = getContentElement(options);
        if (contentElement !== null) {
          var tocElement = getTocElement(options);
          if (tocElement !== null && (headingsArray = parseContent.selectHeadings(contentElement, options.headingSelector), headingsArray !== null)) {
            var nestedHeadingsObj = parseContent.nestHeadingsArray(headingsArray), nestedHeadings = nestedHeadingsObj.nest;
            if (!options.skipRendering) buildHtml.render(tocElement, nestedHeadings);
            else return this;
            this._scrollListener = throttle(function(e) {
              buildHtml.updateToc(headingsArray), !options.disableTocScrollSync && updateTocScroll(options);
              var isTop = e && e.target && e.target.scrollingElement && e.target.scrollingElement.scrollTop === 0;
              (e && (e.eventPhase === 0 || e.currentTarget === null) || isTop) && (buildHtml.updateToc(headingsArray), options.scrollEndCallback && options.scrollEndCallback(e));
            }, options.throttleTimeout), this._scrollListener(), options.scrollContainer && document.querySelector(options.scrollContainer) ? (document.querySelector(options.scrollContainer).addEventListener("scroll", this._scrollListener, false), document.querySelector(options.scrollContainer).addEventListener("resize", this._scrollListener, false)) : (document.addEventListener("scroll", this._scrollListener, false), document.addEventListener("resize", this._scrollListener, false));
            var timeout = null;
            return this._clickListener = throttle(function(event) {
              options.scrollSmooth && buildHtml.disableTocAnimation(event), buildHtml.updateToc(headingsArray), timeout && clearTimeout(timeout), timeout = setTimeout(function() {
                buildHtml.enableTocAnimation();
              }, options.scrollSmoothDuration);
            }, options.throttleTimeout), options.scrollContainer && document.querySelector(options.scrollContainer) ? document.querySelector(options.scrollContainer).addEventListener("click", this._clickListener, false) : document.addEventListener("click", this._clickListener, false), this;
          }
        }
      }
    }, tocbot2.refresh = function(customOptions) {
      tocbot2.destroy(), tocbot2.init(customOptions || this.options);
    }, root.tocbot = tocbot2, tocbot2;
  });
} });
var Wrapper = Tr.div(j, ({ theme }) => ({ backgroundColor: theme.base === "light" ? "rgba(0,0,0,.01)" : "rgba(255,255,255,.01)", borderRadius: theme.appBorderRadius, border: `1px dashed ${theme.appBorderColor}`, display: "flex", alignItems: "center", justifyContent: "center", padding: 20, margin: "25px 0 40px", color: curriedTransparentize$1(0.3, theme.color.defaultText), fontSize: theme.typography.size.s2 }));
var EmptyBlock = (props) => import_react.default.createElement(Wrapper, { ...props, className: "docblock-emptyblock sb-unstyled" });
var StyledSyntaxHighlighter = Tr(_m)(({ theme }) => ({ fontSize: `${theme.typography.size.s2 - 1}px`, lineHeight: "19px", margin: "25px 0 40px", borderRadius: theme.appBorderRadius, boxShadow: theme.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0", "pre.prismjs": { padding: 20, background: "inherit" } }));
var SourceSkeletonWrapper = Tr.div(({ theme }) => ({ background: theme.background.content, borderRadius: theme.appBorderRadius, border: `1px solid ${theme.appBorderColor}`, boxShadow: theme.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0", margin: "25px 0 40px", padding: "20px 20px 20px 22px" }));
var SourceSkeletonPlaceholder = Tr.div(({ theme }) => ({ animation: `${theme.animation.glow} 1.5s ease-in-out infinite`, background: theme.appBorderColor, height: 17, marginTop: 1, width: "60%", [`&:first-child${gc}`]: { margin: 0 } }));
var SourceSkeleton = () => import_react.default.createElement(SourceSkeletonWrapper, null, import_react.default.createElement(SourceSkeletonPlaceholder, null), import_react.default.createElement(SourceSkeletonPlaceholder, { style: { width: "80%" } }), import_react.default.createElement(SourceSkeletonPlaceholder, { style: { width: "30%" } }), import_react.default.createElement(SourceSkeletonPlaceholder, { style: { width: "80%" } }));
var Source = ({ isLoading, error, language, code, dark, format: format2 = false, ...rest }) => {
  let { typography } = Mt();
  if (isLoading) return import_react.default.createElement(SourceSkeleton, null);
  if (error) return import_react.default.createElement(EmptyBlock, null, error);
  let syntaxHighlighter = import_react.default.createElement(StyledSyntaxHighlighter, { bordered: true, copyable: true, format: format2, language, className: "docblock-source sb-unstyled", ...rest }, code);
  if (typeof dark > "u") return syntaxHighlighter;
  let overrideTheme = dark ? Ne.dark : Ne.light;
  return import_react.default.createElement(jt, { theme: zr({ ...overrideTheme, fontCode: typography.fonts.mono, fontBase: typography.fonts.base }) }, syntaxHighlighter);
};
var toGlobalSelector = (element) => `& :where(${element}:not(.sb-anchor, .sb-unstyled, .sb-unstyled ${element}))`;
var breakpoint = 600;
var Title = Tr.h1(j, ({ theme }) => ({ color: theme.color.defaultText, fontSize: theme.typography.size.m3, fontWeight: theme.typography.weight.bold, lineHeight: "32px", [`@media (min-width: ${breakpoint}px)`]: { fontSize: theme.typography.size.l1, lineHeight: "36px", marginBottom: "16px" } }));
var Subtitle = Tr.h2(j, ({ theme }) => ({ fontWeight: theme.typography.weight.regular, fontSize: theme.typography.size.s3, lineHeight: "20px", borderBottom: "none", marginBottom: 15, [`@media (min-width: ${breakpoint}px)`]: { fontSize: theme.typography.size.m1, lineHeight: "28px", marginBottom: 24 }, color: curriedTransparentize$1(0.25, theme.color.defaultText) }));
var DocsContent = Tr.div(({ theme }) => {
  let reset = { fontFamily: theme.typography.fonts.base, fontSize: theme.typography.size.s3, margin: 0, WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale", WebkitTapHighlightColor: "rgba(0, 0, 0, 0)", WebkitOverflowScrolling: "touch" }, headers = { margin: "20px 0 8px", padding: 0, cursor: "text", position: "relative", color: theme.color.defaultText, "&:first-of-type": { marginTop: 0, paddingTop: 0 }, "&:hover a.anchor": { textDecoration: "none" }, "& code": { fontSize: "inherit" } }, code = { lineHeight: 1, margin: "0 2px", padding: "3px 5px", whiteSpace: "nowrap", borderRadius: 3, fontSize: theme.typography.size.s2 - 1, border: theme.base === "light" ? `1px solid ${theme.color.mediumlight}` : `1px solid ${theme.color.darker}`, color: theme.base === "light" ? curriedTransparentize$1(0.1, theme.color.defaultText) : curriedTransparentize$1(0.3, theme.color.defaultText), backgroundColor: theme.base === "light" ? theme.color.lighter : theme.color.border };
  return { maxWidth: 1e3, width: "100%", [toGlobalSelector("a")]: { ...reset, fontSize: "inherit", lineHeight: "24px", color: theme.color.secondary, textDecoration: "none", "&.absent": { color: "#cc0000" }, "&.anchor": { display: "block", paddingLeft: 30, marginLeft: -30, cursor: "pointer", position: "absolute", top: 0, left: 0, bottom: 0 } }, [toGlobalSelector("blockquote")]: { ...reset, margin: "16px 0", borderLeft: `4px solid ${theme.color.medium}`, padding: "0 15px", color: theme.color.dark, "& > :first-of-type": { marginTop: 0 }, "& > :last-child": { marginBottom: 0 } }, [toGlobalSelector("div")]: reset, [toGlobalSelector("dl")]: { ...reset, margin: "16px 0", padding: 0, "& dt": { fontSize: "14px", fontWeight: "bold", fontStyle: "italic", padding: 0, margin: "16px 0 4px" }, "& dt:first-of-type": { padding: 0 }, "& dt > :first-of-type": { marginTop: 0 }, "& dt > :last-child": { marginBottom: 0 }, "& dd": { margin: "0 0 16px", padding: "0 15px" }, "& dd > :first-of-type": { marginTop: 0 }, "& dd > :last-child": { marginBottom: 0 } }, [toGlobalSelector("h1")]: { ...reset, ...headers, fontSize: `${theme.typography.size.l1}px`, fontWeight: theme.typography.weight.bold }, [toGlobalSelector("h2")]: { ...reset, ...headers, fontSize: `${theme.typography.size.m2}px`, paddingBottom: 4, borderBottom: `1px solid ${theme.appBorderColor}` }, [toGlobalSelector("h3")]: { ...reset, ...headers, fontSize: `${theme.typography.size.m1}px`, fontWeight: theme.typography.weight.bold }, [toGlobalSelector("h4")]: { ...reset, ...headers, fontSize: `${theme.typography.size.s3}px` }, [toGlobalSelector("h5")]: { ...reset, ...headers, fontSize: `${theme.typography.size.s2}px` }, [toGlobalSelector("h6")]: { ...reset, ...headers, fontSize: `${theme.typography.size.s2}px`, color: theme.color.dark }, [toGlobalSelector("hr")]: { border: "0 none", borderTop: `1px solid ${theme.appBorderColor}`, height: 4, padding: 0 }, [toGlobalSelector("img")]: { maxWidth: "100%" }, [toGlobalSelector("li")]: { ...reset, fontSize: theme.typography.size.s2, color: theme.color.defaultText, lineHeight: "24px", "& + li": { marginTop: ".25em" }, "& ul, & ol": { marginTop: ".25em", marginBottom: 0 }, "& code": code }, [toGlobalSelector("ol")]: { ...reset, margin: "16px 0", paddingLeft: 30, "& :first-of-type": { marginTop: 0 }, "& :last-child": { marginBottom: 0 } }, [toGlobalSelector("p")]: { ...reset, margin: "16px 0", fontSize: theme.typography.size.s2, lineHeight: "24px", color: theme.color.defaultText, "& code": code }, [toGlobalSelector("pre")]: { ...reset, fontFamily: theme.typography.fonts.mono, WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale", lineHeight: "18px", padding: "11px 1rem", whiteSpace: "pre-wrap", color: "inherit", borderRadius: 3, margin: "1rem 0", "&:not(.prismjs)": { background: "transparent", border: "none", borderRadius: 0, padding: 0, margin: 0 }, "& pre, &.prismjs": { padding: 15, margin: 0, whiteSpace: "pre-wrap", color: "inherit", fontSize: "13px", lineHeight: "19px", code: { color: "inherit", fontSize: "inherit" } }, "& code": { whiteSpace: "pre" }, "& code, & tt": { border: "none" } }, [toGlobalSelector("span")]: { ...reset, "&.frame": { display: "block", overflow: "hidden", "& > span": { border: `1px solid ${theme.color.medium}`, display: "block", float: "left", overflow: "hidden", margin: "13px 0 0", padding: 7, width: "auto" }, "& span img": { display: "block", float: "left" }, "& span span": { clear: "both", color: theme.color.darkest, display: "block", padding: "5px 0 0" } }, "&.align-center": { display: "block", overflow: "hidden", clear: "both", "& > span": { display: "block", overflow: "hidden", margin: "13px auto 0", textAlign: "center" }, "& span img": { margin: "0 auto", textAlign: "center" } }, "&.align-right": { display: "block", overflow: "hidden", clear: "both", "& > span": { display: "block", overflow: "hidden", margin: "13px 0 0", textAlign: "right" }, "& span img": { margin: 0, textAlign: "right" } }, "&.float-left": { display: "block", marginRight: 13, overflow: "hidden", float: "left", "& span": { margin: "13px 0 0" } }, "&.float-right": { display: "block", marginLeft: 13, overflow: "hidden", float: "right", "& > span": { display: "block", overflow: "hidden", margin: "13px auto 0", textAlign: "right" } } }, [toGlobalSelector("table")]: { ...reset, margin: "16px 0", fontSize: theme.typography.size.s2, lineHeight: "24px", padding: 0, borderCollapse: "collapse", "& tr": { borderTop: `1px solid ${theme.appBorderColor}`, backgroundColor: theme.appContentBg, margin: 0, padding: 0 }, "& tr:nth-of-type(2n)": { backgroundColor: theme.base === "dark" ? theme.color.darker : theme.color.lighter }, "& tr th": { fontWeight: "bold", color: theme.color.defaultText, border: `1px solid ${theme.appBorderColor}`, margin: 0, padding: "6px 13px" }, "& tr td": { border: `1px solid ${theme.appBorderColor}`, color: theme.color.defaultText, margin: 0, padding: "6px 13px" }, "& tr th :first-of-type, & tr td :first-of-type": { marginTop: 0 }, "& tr th :last-child, & tr td :last-child": { marginBottom: 0 } }, [toGlobalSelector("ul")]: { ...reset, margin: "16px 0", paddingLeft: 30, "& :first-of-type": { marginTop: 0 }, "& :last-child": { marginBottom: 0 }, listStyle: "disc" } };
});
var DocsWrapper = Tr.div(({ theme }) => ({ background: theme.background.content, display: "flex", justifyContent: "center", padding: "4rem 20px", minHeight: "100vh", boxSizing: "border-box", gap: "3rem", [`@media (min-width: ${breakpoint}px)`]: {} }));
var DocsPageWrapper = ({ children, toc }) => import_react.default.createElement(DocsWrapper, { className: "sbdocs sbdocs-wrapper" }, import_react.default.createElement(DocsContent, { className: "sbdocs sbdocs-content" }, children), toc);
var getBlockBackgroundStyle = (theme) => ({ borderRadius: theme.appBorderRadius, background: theme.background.content, boxShadow: theme.base === "light" ? "rgba(0, 0, 0, 0.10) 0 1px 3px 0" : "rgba(0, 0, 0, 0.20) 0 2px 5px 0", border: `1px solid ${theme.appBorderColor}` });
var Bar = Tr(Ol)({ position: "absolute", left: 0, right: 0, top: 0, transition: "transform .2s linear" });
var Wrapper2 = Tr.div({ display: "flex", alignItems: "center", gap: 4 });
var IconPlaceholder = Tr.div(({ theme }) => ({ width: 14, height: 14, borderRadius: 2, margin: "0 7px", backgroundColor: theme.appBorderColor, animation: `${theme.animation.glow} 1.5s ease-in-out infinite` }));
var Toolbar = ({ isLoading, storyId, baseUrl, zoom, resetZoom, ...rest }) => import_react.default.createElement(Bar, { ...rest }, import_react.default.createElement(Wrapper2, { key: "left" }, isLoading ? [1, 2, 3].map((key) => import_react.default.createElement(IconPlaceholder, { key })) : import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(Dl, { key: "zoomin", onClick: (e) => {
  e.preventDefault(), zoom(0.8);
}, title: "Zoom in" }, import_react.default.createElement(ZoomIcon, null)), import_react.default.createElement(Dl, { key: "zoomout", onClick: (e) => {
  e.preventDefault(), zoom(1.25);
}, title: "Zoom out" }, import_react.default.createElement(ZoomOutIcon, null)), import_react.default.createElement(Dl, { key: "zoomreset", onClick: (e) => {
  e.preventDefault(), resetZoom();
}, title: "Reset zoom" }, import_react.default.createElement(ZoomResetIcon, null)))));
var ZoomContext = (0, import_react.createContext)({ scale: 1 });
var { window: globalWindow } = import_global.global;
var IFrame = class extends import_react.Component {
  constructor() {
    super(...arguments);
    this.iframe = null;
  }
  componentDidMount() {
    let { id } = this.props;
    this.iframe = globalWindow.document.getElementById(id);
  }
  shouldComponentUpdate(nextProps) {
    let { scale } = nextProps;
    return scale !== this.props.scale && this.setIframeBodyStyle({ width: `${scale * 100}%`, height: `${scale * 100}%`, transform: `scale(${1 / scale})`, transformOrigin: "top left" }), false;
  }
  setIframeBodyStyle(style) {
    return Object.assign(this.iframe.contentDocument.body.style, style);
  }
  render() {
    let { id, title, src, allowFullScreen, scale, ...rest } = this.props;
    return import_react.default.createElement("iframe", { id, title, src, ...allowFullScreen ? { allow: "fullscreen" } : {}, loading: "lazy", ...rest });
  }
};
var { PREVIEW_URL } = import_global.global;
var BASE_URL = PREVIEW_URL || "iframe.html";
var storyBlockIdFromId = ({ story, primary }) => `story--${story.id}${primary ? "--primary" : ""}`;
var InlineStory = (props) => {
  let storyRef = (0, import_react.useRef)(), [showLoader, setShowLoader] = (0, import_react.useState)(true), [error, setError] = (0, import_react.useState)(), { story, height, autoplay, forceInitialArgs, renderStoryToElement } = props;
  return (0, import_react.useEffect)(() => {
    if (!(story && storyRef.current)) return () => {
    };
    let element = storyRef.current, cleanup = renderStoryToElement(story, element, { showMain: () => {
    }, showError: ({ title, description }) => setError(new Error(`${title} - ${description}`)), showException: (err) => setError(err) }, { autoplay, forceInitialArgs });
    return setShowLoader(false), () => {
      Promise.resolve().then(() => cleanup());
    };
  }, [autoplay, renderStoryToElement, story]), error ? import_react.default.createElement("pre", null, import_react.default.createElement(JT, { error })) : import_react.default.createElement(import_react.default.Fragment, null, height ? import_react.default.createElement("style", null, `#${storyBlockIdFromId(props)} { min-height: ${height}; transform: translateZ(0); overflow: auto }`) : null, showLoader && import_react.default.createElement(StorySkeleton, null), import_react.default.createElement("div", { ref: storyRef, id: `${storyBlockIdFromId(props)}-inner`, "data-name": story.name }));
};
var IFrameStory = ({ story, height = "500px" }) => import_react.default.createElement("div", { style: { width: "100%", height } }, import_react.default.createElement(ZoomContext.Consumer, null, ({ scale }) => import_react.default.createElement(IFrame, { key: "iframe", id: `iframe--${story.id}`, title: story.name, src: UI(BASE_URL, story.id, { viewMode: "story" }), allowFullScreen: true, scale, style: { width: "100%", height: "100%", border: "0 none" } })));
var ErrorMessage = Tr.strong(({ theme }) => ({ color: theme.color.orange }));
var Story = (props) => {
  let { inline, story } = props;
  return inline && !props.autoplay && story.usesMount ? import_react.default.createElement(ErrorMessage, null, "This story mounts inside of play. Set", " ", import_react.default.createElement("a", { href: "https://storybook.js.org/docs/api/doc-blocks/doc-block-story#autoplay" }, "autoplay"), " ", "to true to view this story.") : import_react.default.createElement("div", { id: storyBlockIdFromId(props), className: "sb-story sb-unstyled", "data-story-block": "true" }, inline ? import_react.default.createElement(InlineStory, { ...props }) : import_react.default.createElement(IFrameStory, { ...props }));
};
var StorySkeleton = () => import_react.default.createElement(qI, null);
var ChildrenContainer = Tr.div(({ isColumn, columns, layout }) => ({ display: isColumn || !columns ? "block" : "flex", position: "relative", flexWrap: "wrap", overflow: "auto", flexDirection: isColumn ? "column" : "row", "& .innerZoomElementWrapper > *": isColumn ? { width: layout !== "fullscreen" ? "calc(100% - 20px)" : "100%", display: "block" } : { maxWidth: layout !== "fullscreen" ? "calc(100% - 20px)" : "100%", display: "inline-block" } }), ({ layout = "padded" }) => layout === "centered" || layout === "padded" ? { padding: "30px 20px", "& .innerZoomElementWrapper > *": { width: "auto", border: "10px solid transparent!important" } } : {}, ({ layout = "padded" }) => layout === "centered" ? { display: "flex", justifyContent: "center", justifyItems: "center", alignContent: "center", alignItems: "center" } : {}, ({ columns }) => columns && columns > 1 ? { ".innerZoomElementWrapper > *": { minWidth: `calc(100% / ${columns} - 20px)` } } : {});
var StyledSource = Tr(Source)(({ theme }) => ({ margin: 0, borderTopLeftRadius: 0, borderTopRightRadius: 0, borderBottomLeftRadius: theme.appBorderRadius, borderBottomRightRadius: theme.appBorderRadius, border: "none", background: theme.base === "light" ? "rgba(0, 0, 0, 0.85)" : curriedDarken$1(0.05, theme.background.content), color: theme.color.lightest, button: { background: theme.base === "light" ? "rgba(0, 0, 0, 0.85)" : curriedDarken$1(0.05, theme.background.content) } }));
var PreviewContainer = Tr.div(({ theme, withSource, isExpanded }) => ({ position: "relative", overflow: "hidden", margin: "25px 0 40px", ...getBlockBackgroundStyle(theme), borderBottomLeftRadius: withSource && isExpanded && 0, borderBottomRightRadius: withSource && isExpanded && 0, borderBottomWidth: isExpanded && 0, "h3 + &": { marginTop: "16px" } }), ({ withToolbar }) => withToolbar && { paddingTop: 40 });
var getSource = (withSource, expanded, setExpanded) => {
  switch (true) {
    case !!(withSource && withSource.error):
      return { source: null, actionItem: { title: "No code available", className: "docblock-code-toggle docblock-code-toggle--disabled", disabled: true, onClick: () => setExpanded(false) } };
    case expanded:
      return { source: import_react.default.createElement(StyledSource, { ...withSource, dark: true }), actionItem: { title: "Hide code", className: "docblock-code-toggle docblock-code-toggle--expanded", onClick: () => setExpanded(false) } };
    default:
      return { source: import_react.default.createElement(StyledSource, { ...withSource, dark: true }), actionItem: { title: "Show code", className: "docblock-code-toggle", onClick: () => setExpanded(true) } };
  }
};
function getStoryId(children) {
  if (import_react.Children.count(children) === 1) {
    let elt = children;
    if (elt.props) return elt.props.id;
  }
  return null;
}
var PositionedToolbar = Tr(Toolbar)({ position: "absolute", top: 0, left: 0, right: 0, height: 40 });
var Relative = Tr.div({ overflow: "hidden", position: "relative" });
var Preview = ({ isLoading, isColumn, columns, children, withSource, withToolbar = false, isExpanded = false, additionalActions, className, layout = "padded", ...props }) => {
  let [expanded, setExpanded] = (0, import_react.useState)(isExpanded), { source, actionItem } = getSource(withSource, expanded, setExpanded), [scale, setScale] = (0, import_react.useState)(1), previewClasses = [className].concat(["sbdocs", "sbdocs-preview", "sb-unstyled"]), defaultActionItems = withSource ? [actionItem] : [], [additionalActionItems, setAdditionalActionItems] = (0, import_react.useState)(additionalActions ? [...additionalActions] : []), actionItems = [...defaultActionItems, ...additionalActionItems], { window: globalWindow4 } = import_global.global, copyToClipboard = (0, import_react.useCallback)(async (text) => {
    let { createCopyToClipboardFunction } = await import("./components-XDLBO2JR.js");
    createCopyToClipboardFunction();
  }, []), onCopyCapture = (e) => {
    let selection = globalWindow4.getSelection();
    selection && selection.type === "Range" || (e.preventDefault(), additionalActionItems.filter((item) => item.title === "Copied").length === 0 && copyToClipboard(source.props.code).then(() => {
      setAdditionalActionItems([...additionalActionItems, { title: "Copied", onClick: () => {
      } }]), globalWindow4.setTimeout(() => setAdditionalActionItems(additionalActionItems.filter((item) => item.title !== "Copied")), 1500);
    }));
  };
  return import_react.default.createElement(PreviewContainer, { withSource, withToolbar, ...props, className: previewClasses.join(" ") }, withToolbar && import_react.default.createElement(PositionedToolbar, { isLoading, border: true, zoom: (z2) => setScale(scale * z2), resetZoom: () => setScale(1), storyId: getStoryId(children), baseUrl: "./iframe.html" }), import_react.default.createElement(ZoomContext.Provider, { value: { scale } }, import_react.default.createElement(Relative, { className: "docs-story", onCopyCapture: withSource && onCopyCapture }, import_react.default.createElement(ChildrenContainer, { isColumn: isColumn || !Array.isArray(children), columns, layout }, import_react.default.createElement(qT.Element, { scale }, Array.isArray(children) ? children.map((child, i) => import_react.default.createElement("div", { key: i }, child)) : import_react.default.createElement("div", null, children))), import_react.default.createElement(Xs, { actionItems }))), withSource && expanded && source);
};
Tr(Preview)(() => ({ ".docs-story": { paddingTop: 32, paddingBottom: 40 } }));
var Table = Tr.table(({ theme }) => ({ "&&": { borderCollapse: "collapse", borderSpacing: 0, border: "none", tr: { border: "none !important", background: "none" }, "td, th": { padding: 0, border: "none", width: "auto!important" }, marginTop: 0, marginBottom: 0, "th:first-of-type, td:first-of-type": { paddingLeft: 0 }, "th:last-of-type, td:last-of-type": { paddingRight: 0 }, td: { paddingTop: 0, paddingBottom: 4, "&:not(:first-of-type)": { paddingLeft: 10, paddingRight: 0 } }, tbody: { boxShadow: "none", border: "none" }, code: At({ theme }), div: { span: { fontWeight: "bold" } }, "& code": { margin: 0, display: "inline-block", fontSize: theme.typography.size.s1 } } }));
var ArgJsDoc = ({ tags }) => {
  let params = (tags.params || []).filter((x) => x.description), hasDisplayableParams = params.length !== 0, hasDisplayableDeprecated = tags.deprecated != null, hasDisplayableReturns = tags.returns != null && tags.returns.description != null;
  return !hasDisplayableParams && !hasDisplayableReturns && !hasDisplayableDeprecated ? null : import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(Table, null, import_react.default.createElement("tbody", null, hasDisplayableDeprecated && import_react.default.createElement("tr", { key: "deprecated" }, import_react.default.createElement("td", { colSpan: 2 }, import_react.default.createElement("strong", null, "Deprecated"), ": ", tags.deprecated.toString())), hasDisplayableParams && params.map((x) => import_react.default.createElement("tr", { key: x.name }, import_react.default.createElement("td", null, import_react.default.createElement("code", null, x.name)), import_react.default.createElement("td", null, x.description))), hasDisplayableReturns && import_react.default.createElement("tr", { key: "returns" }, import_react.default.createElement("td", null, import_react.default.createElement("code", null, "Returns")), import_react.default.createElement("td", null, tags.returns.description)))));
};
var ITEMS_BEFORE_EXPANSION = 8;
var Summary = Tr.div(({ isExpanded }) => ({ display: "flex", flexDirection: isExpanded ? "column" : "row", flexWrap: "wrap", alignItems: "flex-start", marginBottom: "-4px", minWidth: 100 }));
var Text = Tr.span(At, ({ theme, simple = false }) => ({ flex: "0 0 auto", fontFamily: theme.typography.fonts.mono, fontSize: theme.typography.size.s1, wordBreak: "break-word", whiteSpace: "normal", maxWidth: "100%", margin: 0, marginRight: "4px", marginBottom: "4px", paddingTop: "2px", paddingBottom: "2px", lineHeight: "13px", ...simple && { background: "transparent", border: "0 none", paddingLeft: 0 } }));
var ExpandButton = Tr.button(({ theme }) => ({ fontFamily: theme.typography.fonts.mono, color: theme.color.secondary, marginBottom: "4px", background: "none", border: "none" }));
var Expandable = Tr.div(At, ({ theme }) => ({ fontFamily: theme.typography.fonts.mono, color: theme.color.secondary, fontSize: theme.typography.size.s1, margin: 0, whiteSpace: "nowrap", display: "flex", alignItems: "center" }));
var Detail = Tr.div(({ theme, width }) => ({ width, minWidth: 200, maxWidth: 800, padding: 15, fontFamily: theme.typography.fonts.mono, fontSize: theme.typography.size.s1, boxSizing: "content-box", "& code": { padding: "0 !important" } }));
var ChevronUpIcon = Tr(ChevronSmallUpIcon)({ marginLeft: 4 });
var ChevronDownIcon2 = Tr(ChevronSmallDownIcon)({ marginLeft: 4 });
var EmptyArg = () => import_react.default.createElement("span", null, "-");
var ArgText = ({ text, simple }) => import_react.default.createElement(Text, { simple }, text);
var calculateDetailWidth = (0, import_memoizerific.default)(1e3)((detail) => {
  let lines = detail.split(/\r?\n/);
  return `${Math.max(...lines.map((x) => x.length))}ch`;
});
var getSummaryItems = (summary) => {
  if (!summary) return [summary];
  let summaryItems = summary.split("|").map((value2) => value2.trim());
  return (0, import_uniq.default)(summaryItems);
};
var renderSummaryItems = (summaryItems, isExpanded = true) => {
  let items = summaryItems;
  return isExpanded || (items = summaryItems.slice(0, ITEMS_BEFORE_EXPANSION)), items.map((item) => import_react.default.createElement(ArgText, { key: item, text: item === "" ? '""' : item }));
};
var ArgSummary = ({ value: value2, initialExpandedArgs }) => {
  let { summary, detail } = value2, [isOpen, setIsOpen] = (0, import_react.useState)(false), [isExpanded, setIsExpanded] = (0, import_react.useState)(initialExpandedArgs || false);
  if (summary == null) return null;
  let summaryAsString = typeof summary.toString == "function" ? summary.toString() : summary;
  if (detail == null) {
    if (/[(){}[\]<>]/.test(summaryAsString)) return import_react.default.createElement(ArgText, { text: summaryAsString });
    let summaryItems = getSummaryItems(summaryAsString), itemsCount = summaryItems.length;
    return itemsCount > ITEMS_BEFORE_EXPANSION ? import_react.default.createElement(Summary, { isExpanded }, renderSummaryItems(summaryItems, isExpanded), import_react.default.createElement(ExpandButton, { onClick: () => setIsExpanded(!isExpanded) }, isExpanded ? "Show less..." : `Show ${itemsCount - ITEMS_BEFORE_EXPANSION} more...`)) : import_react.default.createElement(Summary, null, renderSummaryItems(summaryItems));
  }
  return import_react.default.createElement(bB, { closeOnOutsideClick: true, placement: "bottom", visible: isOpen, onVisibleChange: (isVisible) => {
    setIsOpen(isVisible);
  }, tooltip: import_react.default.createElement(Detail, { width: calculateDetailWidth(detail) }, import_react.default.createElement(_m, { language: "jsx", format: false }, detail)) }, import_react.default.createElement(Expandable, { className: "sbdocs-expandable" }, import_react.default.createElement("span", null, summaryAsString), isOpen ? import_react.default.createElement(ChevronUpIcon, null) : import_react.default.createElement(ChevronDownIcon2, null)));
};
var ArgValue = ({ value: value2, initialExpandedArgs }) => value2 == null ? import_react.default.createElement(EmptyArg, null) : import_react.default.createElement(ArgSummary, { value: value2, initialExpandedArgs });
var Label = Tr.label(({ theme }) => ({ lineHeight: "18px", alignItems: "center", marginBottom: 8, display: "inline-block", position: "relative", whiteSpace: "nowrap", background: theme.boolean.background, borderRadius: "3em", padding: 1, '&[aria-disabled="true"]': { opacity: 0.5, input: { cursor: "not-allowed" } }, input: { appearance: "none", width: "100%", height: "100%", position: "absolute", left: 0, top: 0, margin: 0, padding: 0, border: "none", background: "transparent", cursor: "pointer", borderRadius: "3em", "&:focus": { outline: "none", boxShadow: `${theme.color.secondary} 0 0 0 1px inset !important` } }, span: { textAlign: "center", fontSize: theme.typography.size.s1, fontWeight: theme.typography.weight.bold, lineHeight: "1", cursor: "pointer", display: "inline-block", padding: "7px 15px", transition: "all 100ms ease-out", userSelect: "none", borderRadius: "3em", color: curriedTransparentize$1(0.5, theme.color.defaultText), background: "transparent", "&:hover": { boxShadow: `${curriedOpacify$1(0.3, theme.appBorderColor)} 0 0 0 1px inset` }, "&:active": { boxShadow: `${curriedOpacify$1(0.05, theme.appBorderColor)} 0 0 0 2px inset`, color: curriedOpacify$1(1, theme.appBorderColor) }, "&:first-of-type": { paddingRight: 8 }, "&:last-of-type": { paddingLeft: 8 } }, "input:checked ~ span:last-of-type, input:not(:checked) ~ span:first-of-type": { background: theme.boolean.selectedBackground, boxShadow: theme.base === "light" ? `${curriedOpacify$1(0.1, theme.appBorderColor)} 0 0 2px` : `${theme.appBorderColor} 0 0 0 1px`, color: theme.color.defaultText, padding: "7px 15px" } }));
var parse = (value2) => value2 === "true";
var BooleanControl = ({ name, value: value2, onChange, onBlur, onFocus, argType }) => {
  var _a;
  let onSetFalse = (0, import_react.useCallback)(() => onChange(false), [onChange]), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly);
  if (value2 === void 0) return import_react.default.createElement(Ao, { variant: "outline", size: "medium", id: getControlSetterButtonId(name), onClick: onSetFalse, disabled: readonly }, "Set boolean");
  let controlId = getControlId(name), parsedValue = typeof value2 == "string" ? parse(value2) : value2;
  return import_react.default.createElement(Label, { "aria-disabled": readonly, htmlFor: controlId, "aria-label": name }, import_react.default.createElement("input", { id: controlId, type: "checkbox", onChange: (e) => onChange(e.target.checked), checked: parsedValue, role: "switch", disabled: readonly, name, onBlur, onFocus }), import_react.default.createElement("span", { "aria-hidden": "true" }, "False"), import_react.default.createElement("span", { "aria-hidden": "true" }, "True"));
};
var parseDate = (value2) => {
  let [year, month, day] = value2.split("-"), result = /* @__PURE__ */ new Date();
  return result.setFullYear(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10)), result;
};
var parseTime = (value2) => {
  let [hours, minutes] = value2.split(":"), result = /* @__PURE__ */ new Date();
  return result.setHours(parseInt(hours, 10)), result.setMinutes(parseInt(minutes, 10)), result;
};
var formatDate = (value2) => {
  let date = new Date(value2), year = `000${date.getFullYear()}`.slice(-4), month = `0${date.getMonth() + 1}`.slice(-2), day = `0${date.getDate()}`.slice(-2);
  return `${year}-${month}-${day}`;
};
var formatTime = (value2) => {
  let date = new Date(value2), hours = `0${date.getHours()}`.slice(-2), minutes = `0${date.getMinutes()}`.slice(-2);
  return `${hours}:${minutes}`;
};
var FormInput = Tr(wL.Input)(({ readOnly }) => ({ opacity: readOnly ? 0.5 : 1 }));
var FlexSpaced = Tr.div(({ theme }) => ({ flex: 1, display: "flex", input: { marginLeft: 10, flex: 1, height: 32, "&::-webkit-calendar-picker-indicator": { opacity: 0.5, height: 12, filter: theme.base === "light" ? void 0 : "invert(1)" } }, "input:first-of-type": { marginLeft: 0, flexGrow: 4 }, "input:last-of-type": { flexGrow: 3 } }));
var DateControl = ({ name, value: value2, onChange, onFocus, onBlur, argType }) => {
  var _a;
  let [valid, setValid] = (0, import_react.useState)(true), dateRef = (0, import_react.useRef)(), timeRef = (0, import_react.useRef)(), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly);
  (0, import_react.useEffect)(() => {
    valid !== false && (dateRef && dateRef.current && (dateRef.current.value = value2 ? formatDate(value2) : ""), timeRef && timeRef.current && (timeRef.current.value = value2 ? formatTime(value2) : ""));
  }, [value2]);
  let onDateChange = (e) => {
    if (!e.target.value) return onChange();
    let parsed = parseDate(e.target.value), result = new Date(value2);
    result.setFullYear(parsed.getFullYear(), parsed.getMonth(), parsed.getDate());
    let time = result.getTime();
    time && onChange(time), setValid(!!time);
  }, onTimeChange = (e) => {
    if (!e.target.value) return onChange();
    let parsed = parseTime(e.target.value), result = new Date(value2);
    result.setHours(parsed.getHours()), result.setMinutes(parsed.getMinutes());
    let time = result.getTime();
    time && onChange(time), setValid(!!time);
  }, controlId = getControlId(name);
  return import_react.default.createElement(FlexSpaced, null, import_react.default.createElement(FormInput, { type: "date", max: "9999-12-31", ref: dateRef, id: `${controlId}-date`, name: `${controlId}-date`, readOnly: readonly, onChange: onDateChange, onFocus, onBlur }), import_react.default.createElement(FormInput, { type: "time", id: `${controlId}-time`, name: `${controlId}-time`, ref: timeRef, onChange: onTimeChange, readOnly: readonly, onFocus, onBlur }), valid ? null : import_react.default.createElement("div", null, "invalid"));
};
var Wrapper3 = Tr.label({ display: "flex" });
var parse2 = (value2) => {
  let result = parseFloat(value2);
  return Number.isNaN(result) ? void 0 : result;
};
var format = (value2) => value2 != null ? String(value2) : "";
var FormInput2 = Tr(wL.Input)(({ readOnly }) => ({ opacity: readOnly ? 0.5 : 1 }));
var NumberControl = ({ name, value: value2, onChange, min, max, step, onBlur, onFocus, argType }) => {
  var _a;
  let [inputValue, setInputValue] = (0, import_react.useState)(typeof value2 == "number" ? value2 : ""), [forceVisible, setForceVisible] = (0, import_react.useState)(false), [parseError, setParseError] = (0, import_react.useState)(null), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly), handleChange = (0, import_react.useCallback)((event) => {
    setInputValue(event.target.value);
    let result = parseFloat(event.target.value);
    Number.isNaN(result) ? setParseError(new Error(`'${event.target.value}' is not a number`)) : (onChange(result), setParseError(null));
  }, [onChange, setParseError]), onForceVisible = (0, import_react.useCallback)(() => {
    setInputValue("0"), onChange(0), setForceVisible(true);
  }, [setForceVisible]), htmlElRef = (0, import_react.useRef)(null);
  return (0, import_react.useEffect)(() => {
    forceVisible && htmlElRef.current && htmlElRef.current.select();
  }, [forceVisible]), (0, import_react.useEffect)(() => {
    inputValue !== (typeof value2 == "number" ? value2 : "") && setInputValue(value2);
  }, [value2]), value2 === void 0 ? import_react.default.createElement(Ao, { variant: "outline", size: "medium", id: getControlSetterButtonId(name), onClick: onForceVisible, disabled: readonly }, "Set number") : import_react.default.createElement(Wrapper3, null, import_react.default.createElement(FormInput2, { ref: htmlElRef, id: getControlId(name), type: "number", onChange: handleChange, size: "flex", placeholder: "Edit number...", value: inputValue, valid: parseError ? "error" : null, autoFocus: forceVisible, readOnly: readonly, name, min, max, step, onFocus, onBlur }));
};
var selectedKey = (value2, options) => {
  let entry = options && Object.entries(options).find(([_key, val]) => val === value2);
  return entry ? entry[0] : void 0;
};
var selectedKeys = (value2, options) => value2 && options ? Object.entries(options).filter((entry) => value2.includes(entry[1])).map((entry) => entry[0]) : [];
var selectedValues = (keys, options) => keys && options && keys.map((key) => options[key]);
var Wrapper4 = Tr.div(({ isInline }) => isInline ? { display: "flex", flexWrap: "wrap", alignItems: "flex-start", label: { display: "inline-flex", marginRight: 15 } } : { label: { display: "flex" } }, (props) => {
  if (props["aria-readonly"] === "true") return { input: { cursor: "not-allowed" } };
});
var Text2 = Tr.span({ "[aria-readonly=true] &": { opacity: 0.5 } });
var Label2 = Tr.label({ lineHeight: "20px", alignItems: "center", marginBottom: 8, "&:last-child": { marginBottom: 0 }, input: { margin: 0, marginRight: 6 } });
var CheckboxControl = ({ name, options, value: value2, onChange, isInline, argType }) => {
  var _a;
  if (!options) return import_client_logger.logger.warn(`Checkbox with no options: ${name}`), import_react.default.createElement(import_react.default.Fragment, null, "-");
  let initial = selectedKeys(value2, options), [selected, setSelected] = (0, import_react.useState)(initial), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly), handleChange = (e) => {
    let option = e.target.value, updated = [...selected];
    updated.includes(option) ? updated.splice(updated.indexOf(option), 1) : updated.push(option), onChange(selectedValues(updated, options)), setSelected(updated);
  };
  (0, import_react.useEffect)(() => {
    setSelected(selectedKeys(value2, options));
  }, [value2]);
  let controlId = getControlId(name);
  return import_react.default.createElement(Wrapper4, { "aria-readonly": readonly, isInline }, Object.keys(options).map((key, index) => {
    let id = `${controlId}-${index}`;
    return import_react.default.createElement(Label2, { key: id, htmlFor: id }, import_react.default.createElement("input", { type: "checkbox", disabled: readonly, id, name: id, value: key, onChange: handleChange, checked: selected == null ? void 0 : selected.includes(key) }), import_react.default.createElement(Text2, null, key));
  }));
};
var Wrapper5 = Tr.div(({ isInline }) => isInline ? { display: "flex", flexWrap: "wrap", alignItems: "flex-start", label: { display: "inline-flex", marginRight: 15 } } : { label: { display: "flex" } }, (props) => {
  if (props["aria-readonly"] === "true") return { input: { cursor: "not-allowed" } };
});
var Text3 = Tr.span({ "[aria-readonly=true] &": { opacity: 0.5 } });
var Label3 = Tr.label({ lineHeight: "20px", alignItems: "center", marginBottom: 8, "&:last-child": { marginBottom: 0 }, input: { margin: 0, marginRight: 6 } });
var RadioControl = ({ name, options, value: value2, onChange, isInline, argType }) => {
  var _a;
  if (!options) return import_client_logger.logger.warn(`Radio with no options: ${name}`), import_react.default.createElement(import_react.default.Fragment, null, "-");
  let selection = selectedKey(value2, options), controlId = getControlId(name), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly);
  return import_react.default.createElement(Wrapper5, { "aria-readonly": readonly, isInline }, Object.keys(options).map((key, index) => {
    let id = `${controlId}-${index}`;
    return import_react.default.createElement(Label3, { key: id, htmlFor: id }, import_react.default.createElement("input", { type: "radio", id, name: controlId, disabled: readonly, value: key, onChange: (e) => onChange(options[e.currentTarget.value]), checked: key === selection }), import_react.default.createElement(Text3, null, key));
  }));
};
var styleResets = { appearance: "none", border: "0 none", boxSizing: "inherit", display: " block", margin: " 0", background: "transparent", padding: 0, fontSize: "inherit", position: "relative" };
var OptionsSelect = Tr.select(styleResets, ({ theme }) => ({ boxSizing: "border-box", position: "relative", padding: "6px 10px", width: "100%", color: theme.input.color || "inherit", background: theme.input.background, borderRadius: theme.input.borderRadius, boxShadow: `${theme.input.border} 0 0 0 1px inset`, fontSize: theme.typography.size.s2 - 1, lineHeight: "20px", "&:focus": { boxShadow: `${theme.color.secondary} 0 0 0 1px inset`, outline: "none" }, "&[disabled]": { cursor: "not-allowed", opacity: 0.5 }, "::placeholder": { color: theme.textMutedColor }, "&[multiple]": { overflow: "auto", padding: 0, option: { display: "block", padding: "6px 10px", marginLeft: 1, marginRight: 1 } } }));
var SelectWrapper = Tr.span(({ theme }) => ({ display: "inline-block", lineHeight: "normal", overflow: "hidden", position: "relative", verticalAlign: "top", width: "100%", svg: { position: "absolute", zIndex: 1, pointerEvents: "none", height: "12px", marginTop: "-6px", right: "12px", top: "50%", fill: theme.textMutedColor, path: { fill: theme.textMutedColor } } }));
var NO_SELECTION = "Choose option...";
var SingleSelect = ({ name, value: value2, options, onChange, argType }) => {
  var _a;
  let handleChange = (e) => {
    onChange(options[e.currentTarget.value]);
  }, selection = selectedKey(value2, options) || NO_SELECTION, controlId = getControlId(name), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly);
  return import_react.default.createElement(SelectWrapper, null, import_react.default.createElement(ChevronSmallDownIcon, null), import_react.default.createElement(OptionsSelect, { disabled: readonly, id: controlId, value: selection, onChange: handleChange }, import_react.default.createElement("option", { key: "no-selection", disabled: true }, NO_SELECTION), Object.keys(options).map((key) => import_react.default.createElement("option", { key, value: key }, key))));
};
var MultiSelect = ({ name, value: value2, options, onChange, argType }) => {
  var _a;
  let handleChange = (e) => {
    let selection2 = Array.from(e.currentTarget.options).filter((option) => option.selected).map((option) => option.value);
    onChange(selectedValues(selection2, options));
  }, selection = selectedKeys(value2, options), controlId = getControlId(name), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly);
  return import_react.default.createElement(SelectWrapper, null, import_react.default.createElement(OptionsSelect, { disabled: readonly, id: controlId, multiple: true, value: selection, onChange: handleChange }, Object.keys(options).map((key) => import_react.default.createElement("option", { key, value: key }, key))));
};
var SelectControl = (props) => {
  let { name, options } = props;
  return options ? props.isMulti ? import_react.default.createElement(MultiSelect, { ...props }) : import_react.default.createElement(SingleSelect, { ...props }) : (import_client_logger.logger.warn(`Select with no options: ${name}`), import_react.default.createElement(import_react.default.Fragment, null, "-"));
};
var normalizeOptions = (options, labels) => Array.isArray(options) ? options.reduce((acc, item) => (acc[(labels == null ? void 0 : labels[item]) || String(item)] = item, acc), {}) : options;
var Controls = { check: CheckboxControl, "inline-check": CheckboxControl, radio: RadioControl, "inline-radio": RadioControl, select: SelectControl, "multi-select": SelectControl };
var OptionsControl = (props) => {
  let { type = "select", labels, argType } = props, normalized = { ...props, argType, options: argType ? normalizeOptions(argType.options, labels) : {}, isInline: type.includes("inline"), isMulti: type.includes("multi") }, Control = Controls[type];
  if (Control) return import_react.default.createElement(Control, { ...normalized });
  throw new Error(`Unknown options type: ${type}`);
};
var VALUE = "value";
var KEY = "key";
var ERROR = "Error";
var OBJECT = "Object";
var ARRAY = "Array";
var STRING = "String";
var NUMBER = "Number";
var BOOLEAN = "Boolean";
var DATE = "Date";
var NULL = "Null";
var UNDEFINED = "Undefined";
var FUNCTION = "Function";
var SYMBOL = "Symbol";
var ADD_DELTA_TYPE = "ADD_DELTA_TYPE";
var REMOVE_DELTA_TYPE = "REMOVE_DELTA_TYPE";
var UPDATE_DELTA_TYPE = "UPDATE_DELTA_TYPE";
function getObjectType(obj) {
  return obj !== null && typeof obj == "object" && !Array.isArray(obj) && typeof obj[Symbol.iterator] == "function" ? "Iterable" : Object.prototype.toString.call(obj).slice(8, -1);
}
function isComponentWillChange(oldValue, newValue) {
  let oldType = getObjectType(oldValue), newType = getObjectType(newValue);
  return (oldType === "Function" || newType === "Function") && newType !== oldType;
}
var JsonAddValue = class extends import_react.Component {
  constructor(props) {
    super(props), this.state = { inputRefKey: null, inputRefValue: null }, this.refInputValue = this.refInputValue.bind(this), this.refInputKey = this.refInputKey.bind(this), this.onKeydown = this.onKeydown.bind(this), this.onSubmit = this.onSubmit.bind(this);
  }
  componentDidMount() {
    let { inputRefKey, inputRefValue } = this.state, { onlyValue } = this.props;
    inputRefKey && typeof inputRefKey.focus == "function" && inputRefKey.focus(), onlyValue && inputRefValue && typeof inputRefValue.focus == "function" && inputRefValue.focus(), document.addEventListener("keydown", this.onKeydown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.onKeydown);
  }
  onKeydown(event) {
    event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.onSubmit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.props.handleCancel()));
  }
  onSubmit() {
    let { handleAdd, onlyValue, onSubmitValueParser, keyPath, deep } = this.props, { inputRefKey, inputRefValue } = this.state, result = {};
    if (!onlyValue) {
      if (!inputRefKey.value) return;
      result.key = inputRefKey.value;
    }
    result.newValue = onSubmitValueParser(false, keyPath, deep, result.key, inputRefValue.value), handleAdd(result);
  }
  refInputKey(node) {
    this.state.inputRefKey = node;
  }
  refInputValue(node) {
    this.state.inputRefValue = node;
  }
  render() {
    let { handleCancel, onlyValue, addButtonElement, cancelButtonElement, inputElementGenerator, keyPath, deep } = this.props, addButtonElementLayout = (0, import_react.cloneElement)(addButtonElement, { onClick: this.onSubmit }), cancelButtonElementLayout = (0, import_react.cloneElement)(cancelButtonElement, { onClick: handleCancel }), inputElementValue = inputElementGenerator(VALUE, keyPath, deep), inputElementValueLayout = (0, import_react.cloneElement)(inputElementValue, { placeholder: "Value", ref: this.refInputValue }), inputElementKeyLayout = null;
    if (!onlyValue) {
      let inputElementKey = inputElementGenerator(KEY, keyPath, deep);
      inputElementKeyLayout = (0, import_react.cloneElement)(inputElementKey, { placeholder: "Key", ref: this.refInputKey });
    }
    return import_react.default.createElement("span", { className: "rejt-add-value-node" }, inputElementKeyLayout, inputElementValueLayout, cancelButtonElementLayout, addButtonElementLayout);
  }
};
JsonAddValue.defaultProps = { onlyValue: false, addButtonElement: import_react.default.createElement("button", null, "+"), cancelButtonElement: import_react.default.createElement("button", null, "c") };
var JsonArray = class extends import_react.Component {
  constructor(props) {
    super(props);
    let keyPath = [...props.keyPath, props.name];
    this.state = { data: props.data, name: props.name, keyPath, deep: props.deep, nextDeep: props.deep + 1, collapsed: props.isCollapsed(keyPath, props.deep, props.data), addFormVisible: false }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveItem = this.handleRemoveItem.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
  }
  static getDerivedStateFromProps(props, state) {
    return props.data !== state.data ? { data: props.data } : null;
  }
  onChildUpdate(childKey, childData) {
    let { data, keyPath } = this.state;
    data[childKey] = childData, this.setState({ data });
    let { onUpdate } = this.props, size = keyPath.length;
    onUpdate(keyPath[size - 1], data);
  }
  handleAddMode() {
    this.setState({ addFormVisible: true });
  }
  handleCollapseMode() {
    this.setState((state) => ({ collapsed: !state.collapsed }));
  }
  handleRemoveItem(index) {
    return () => {
      let { beforeRemoveAction, logger: logger4 } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[index];
      beforeRemoveAction(index, keyPath, deep, oldValue).then(() => {
        let deltaUpdateResult = { keyPath, deep, key: index, oldValue, type: REMOVE_DELTA_TYPE };
        data.splice(index, 1), this.setState({ data });
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
      }).catch(logger4.error);
    };
  }
  handleAddValueAdd({ newValue }) {
    let { data, keyPath, nextDeep: deep } = this.state, { beforeAddAction, logger: logger4 } = this.props;
    beforeAddAction(data.length, keyPath, deep, newValue).then(() => {
      let newData = [...data, newValue];
      this.setState({ data: newData }), this.handleAddValueCancel();
      let { onUpdate, onDeltaUpdate } = this.props;
      onUpdate(keyPath[keyPath.length - 1], newData), onDeltaUpdate({ type: ADD_DELTA_TYPE, keyPath, deep, key: newData.length - 1, newValue });
    }).catch(logger4.error);
  }
  handleAddValueCancel() {
    this.setState({ addFormVisible: false });
  }
  handleEditValue({ key, value: value2 }) {
    return new Promise((resolve, reject) => {
      let { beforeUpdateAction } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[key];
      beforeUpdateAction(key, keyPath, deep, oldValue, value2).then(() => {
        data[key] = value2, this.setState({ data });
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({ type: UPDATE_DELTA_TYPE, keyPath, deep, key, newValue: value2, oldValue }), resolve(void 0);
      }).catch(reject);
    });
  }
  renderCollapsed() {
    let { name, data, keyPath, deep } = this.state, { handleRemove, readOnly, getStyle, dataType, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = (0, import_react.cloneElement)(minusMenuElement, { onClick: handleRemove, className: "rejt-minus-menu", style: minus });
    return import_react.default.createElement("span", { className: "rejt-collapsed" }, import_react.default.createElement("span", { className: "rejt-collapsed-text", style: collapsed, onClick: this.handleCollapseMode }, "[...] ", data.length, " ", data.length === 1 ? "item" : "items"), !isReadOnly && removeItemButton);
  }
  renderNotCollapsed() {
    let { name, data, keyPath, deep, addFormVisible, nextDeep } = this.state, { isCollapsed, handleRemove, onDeltaUpdate, readOnly, getStyle, dataType, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser } = this.props, { minus, plus, delimiter, ul, addForm } = getStyle(name, data, keyPath, deep, dataType), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = (0, import_react.cloneElement)(plusMenuElement, { onClick: this.handleAddMode, className: "rejt-plus-menu", style: plus }), removeItemButton = (0, import_react.cloneElement)(minusMenuElement, { onClick: handleRemove, className: "rejt-minus-menu", style: minus });
    return import_react.default.createElement("span", { className: "rejt-not-collapsed" }, import_react.default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "["), !addFormVisible && addItemButton, import_react.default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, data.map((item, index) => import_react.default.createElement(JsonNode, { key: index, name: index.toString(), data: item, keyPath, deep: nextDeep, isCollapsed, handleRemove: this.handleRemoveItem(index), handleUpdateValue: this.handleEditValue, onUpdate: this.onChildUpdate, onDeltaUpdate, readOnly, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser }))), !isReadOnly && addFormVisible && import_react.default.createElement("div", { className: "rejt-add-form", style: addForm }, import_react.default.createElement(JsonAddValue, { handleAdd: this.handleAddValueAdd, handleCancel: this.handleAddValueCancel, onlyValue: true, addButtonElement, cancelButtonElement, inputElementGenerator, keyPath, deep, onSubmitValueParser })), import_react.default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "]"), !isReadOnly && removeItemButton);
  }
  render() {
    let { name, collapsed, data, keyPath, deep } = this.state, { dataType, getStyle } = this.props, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed(), style = getStyle(name, data, keyPath, deep, dataType);
    return import_react.default.createElement("div", { className: "rejt-array-node" }, import_react.default.createElement("span", { onClick: this.handleCollapseMode }, import_react.default.createElement("span", { className: "rejt-name", style: style.name }, name, " :", " ")), value2);
  }
};
JsonArray.defaultProps = { keyPath: [], deep: 0, minusMenuElement: import_react.default.createElement("span", null, " - "), plusMenuElement: import_react.default.createElement("span", null, " + ") };
var JsonFunctionValue = class extends import_react.Component {
  constructor(props) {
    super(props);
    let keyPath = [...props.keyPath, props.name];
    this.state = { value: props.value, name: props.name, keyPath, deep: props.deep, editEnabled: false, inputRef: null }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
  }
  static getDerivedStateFromProps(props, state) {
    return props.value !== state.value ? { value: props.value } : null;
  }
  componentDidUpdate() {
    let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, readOnlyResult = readOnly(name, value2, keyPath, deep, dataType);
    editEnabled && !readOnlyResult && typeof inputRef.focus == "function" && inputRef.focus();
  }
  componentDidMount() {
    document.addEventListener("keydown", this.onKeydown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.onKeydown);
  }
  onKeydown(event) {
    event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
  }
  handleEdit() {
    let { handleUpdateValue, originalValue, logger: logger4, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
    if (!inputRef) return;
    let newValue = onSubmitValueParser(true, keyPath, deep, name, inputRef.value);
    handleUpdateValue({ value: newValue, key: name }).then(() => {
      isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
    }).catch(logger4.error);
  }
  handleEditMode() {
    this.setState({ editEnabled: true });
  }
  refInput(node) {
    this.state.inputRef = node;
  }
  handleCancelEdit() {
    this.setState({ editEnabled: false });
  }
  render() {
    let { name, value: value2, editEnabled, keyPath, deep } = this.state, { handleRemove, originalValue, readOnly, dataType, getStyle, editButtonElement, cancelButtonElement, textareaElementGenerator, minusMenuElement, keyPath: comeFromKeyPath } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), result = null, minusElement = null, resultOnlyResult = readOnly(name, originalValue, keyPath, deep, dataType);
    if (editEnabled && !resultOnlyResult) {
      let textareaElement = textareaElementGenerator(VALUE, comeFromKeyPath, deep, name, originalValue, dataType), editButtonElementLayout = (0, import_react.cloneElement)(editButtonElement, { onClick: this.handleEdit }), cancelButtonElementLayout = (0, import_react.cloneElement)(cancelButtonElement, { onClick: this.handleCancelEdit }), textareaElementLayout = (0, import_react.cloneElement)(textareaElement, { ref: this.refInput, defaultValue: originalValue });
      result = import_react.default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, textareaElementLayout, " ", cancelButtonElementLayout, editButtonElementLayout), minusElement = null;
    } else {
      result = import_react.default.createElement("span", { className: "rejt-value", style: style.value, onClick: resultOnlyResult ? null : this.handleEditMode }, value2);
      let minusMenuLayout = (0, import_react.cloneElement)(minusMenuElement, { onClick: handleRemove, className: "rejt-minus-menu", style: style.minus });
      minusElement = resultOnlyResult ? null : minusMenuLayout;
    }
    return import_react.default.createElement("li", { className: "rejt-function-value-node", style: style.li }, import_react.default.createElement("span", { className: "rejt-name", style: style.name }, name, " :", " "), result, minusElement);
  }
};
JsonFunctionValue.defaultProps = { keyPath: [], deep: 0, handleUpdateValue: () => {
}, editButtonElement: import_react.default.createElement("button", null, "e"), cancelButtonElement: import_react.default.createElement("button", null, "c"), minusMenuElement: import_react.default.createElement("span", null, " - ") };
var JsonNode = class extends import_react.Component {
  constructor(props) {
    super(props), this.state = { data: props.data, name: props.name, keyPath: props.keyPath, deep: props.deep };
  }
  static getDerivedStateFromProps(props, state) {
    return props.data !== state.data ? { data: props.data } : null;
  }
  render() {
    let { data, name, keyPath, deep } = this.state, { isCollapsed, handleRemove, handleUpdateValue, onUpdate, onDeltaUpdate, readOnly, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser } = this.props, readOnlyTrue = () => true, dataType = getObjectType(data);
    switch (dataType) {
      case ERROR:
        return import_react.default.createElement(JsonObject, { data, name, isCollapsed, keyPath, deep, handleRemove, onUpdate, onDeltaUpdate, readOnly: readOnlyTrue, dataType, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser });
      case OBJECT:
        return import_react.default.createElement(JsonObject, { data, name, isCollapsed, keyPath, deep, handleRemove, onUpdate, onDeltaUpdate, readOnly, dataType, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser });
      case ARRAY:
        return import_react.default.createElement(JsonArray, { data, name, isCollapsed, keyPath, deep, handleRemove, onUpdate, onDeltaUpdate, readOnly, dataType, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser });
      case STRING:
        return import_react.default.createElement(JsonValue, { name, value: `"${data}"`, originalValue: data, keyPath, deep, handleRemove, handleUpdateValue, readOnly, dataType, getStyle, cancelButtonElement, editButtonElement, inputElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      case NUMBER:
        return import_react.default.createElement(JsonValue, { name, value: data, originalValue: data, keyPath, deep, handleRemove, handleUpdateValue, readOnly, dataType, getStyle, cancelButtonElement, editButtonElement, inputElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      case BOOLEAN:
        return import_react.default.createElement(JsonValue, { name, value: data ? "true" : "false", originalValue: data, keyPath, deep, handleRemove, handleUpdateValue, readOnly, dataType, getStyle, cancelButtonElement, editButtonElement, inputElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      case DATE:
        return import_react.default.createElement(JsonValue, { name, value: data.toISOString(), originalValue: data, keyPath, deep, handleRemove, handleUpdateValue, readOnly: readOnlyTrue, dataType, getStyle, cancelButtonElement, editButtonElement, inputElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      case NULL:
        return import_react.default.createElement(JsonValue, { name, value: "null", originalValue: "null", keyPath, deep, handleRemove, handleUpdateValue, readOnly, dataType, getStyle, cancelButtonElement, editButtonElement, inputElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      case UNDEFINED:
        return import_react.default.createElement(JsonValue, { name, value: "undefined", originalValue: "undefined", keyPath, deep, handleRemove, handleUpdateValue, readOnly, dataType, getStyle, cancelButtonElement, editButtonElement, inputElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      case FUNCTION:
        return import_react.default.createElement(JsonFunctionValue, { name, value: data.toString(), originalValue: data, keyPath, deep, handleRemove, handleUpdateValue, readOnly, dataType, getStyle, cancelButtonElement, editButtonElement, textareaElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      case SYMBOL:
        return import_react.default.createElement(JsonValue, { name, value: data.toString(), originalValue: data, keyPath, deep, handleRemove, handleUpdateValue, readOnly: readOnlyTrue, dataType, getStyle, cancelButtonElement, editButtonElement, inputElementGenerator, minusMenuElement, logger: logger4, onSubmitValueParser });
      default:
        return null;
    }
  }
};
JsonNode.defaultProps = { keyPath: [], deep: 0 };
var JsonObject = class extends import_react.Component {
  constructor(props) {
    super(props);
    let keyPath = props.deep === -1 ? [] : [...props.keyPath, props.name];
    this.state = { name: props.name, data: props.data, keyPath, deep: props.deep, nextDeep: props.deep + 1, collapsed: props.isCollapsed(keyPath, props.deep, props.data), addFormVisible: false }, this.handleCollapseMode = this.handleCollapseMode.bind(this), this.handleRemoveValue = this.handleRemoveValue.bind(this), this.handleAddMode = this.handleAddMode.bind(this), this.handleAddValueAdd = this.handleAddValueAdd.bind(this), this.handleAddValueCancel = this.handleAddValueCancel.bind(this), this.handleEditValue = this.handleEditValue.bind(this), this.onChildUpdate = this.onChildUpdate.bind(this), this.renderCollapsed = this.renderCollapsed.bind(this), this.renderNotCollapsed = this.renderNotCollapsed.bind(this);
  }
  static getDerivedStateFromProps(props, state) {
    return props.data !== state.data ? { data: props.data } : null;
  }
  onChildUpdate(childKey, childData) {
    let { data, keyPath } = this.state;
    data[childKey] = childData, this.setState({ data });
    let { onUpdate } = this.props, size = keyPath.length;
    onUpdate(keyPath[size - 1], data);
  }
  handleAddMode() {
    this.setState({ addFormVisible: true });
  }
  handleAddValueCancel() {
    this.setState({ addFormVisible: false });
  }
  handleAddValueAdd({ key, newValue }) {
    let { data, keyPath, nextDeep: deep } = this.state, { beforeAddAction, logger: logger4 } = this.props;
    beforeAddAction(key, keyPath, deep, newValue).then(() => {
      data[key] = newValue, this.setState({ data }), this.handleAddValueCancel();
      let { onUpdate, onDeltaUpdate } = this.props;
      onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({ type: ADD_DELTA_TYPE, keyPath, deep, key, newValue });
    }).catch(logger4.error);
  }
  handleRemoveValue(key) {
    return () => {
      let { beforeRemoveAction, logger: logger4 } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[key];
      beforeRemoveAction(key, keyPath, deep, oldValue).then(() => {
        let deltaUpdateResult = { keyPath, deep, key, oldValue, type: REMOVE_DELTA_TYPE };
        delete data[key], this.setState({ data });
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate(deltaUpdateResult);
      }).catch(logger4.error);
    };
  }
  handleCollapseMode() {
    this.setState((state) => ({ collapsed: !state.collapsed }));
  }
  handleEditValue({ key, value: value2 }) {
    return new Promise((resolve, reject) => {
      let { beforeUpdateAction } = this.props, { data, keyPath, nextDeep: deep } = this.state, oldValue = data[key];
      beforeUpdateAction(key, keyPath, deep, oldValue, value2).then(() => {
        data[key] = value2, this.setState({ data });
        let { onUpdate, onDeltaUpdate } = this.props;
        onUpdate(keyPath[keyPath.length - 1], data), onDeltaUpdate({ type: UPDATE_DELTA_TYPE, keyPath, deep, key, newValue: value2, oldValue }), resolve();
      }).catch(reject);
    });
  }
  renderCollapsed() {
    let { name, keyPath, deep, data } = this.state, { handleRemove, readOnly, dataType, getStyle, minusMenuElement } = this.props, { minus, collapsed } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), removeItemButton = (0, import_react.cloneElement)(minusMenuElement, { onClick: handleRemove, className: "rejt-minus-menu", style: minus });
    return import_react.default.createElement("span", { className: "rejt-collapsed" }, import_react.default.createElement("span", { className: "rejt-collapsed-text", style: collapsed, onClick: this.handleCollapseMode }, "{...}", " ", keyList.length, " ", keyList.length === 1 ? "key" : "keys"), !isReadOnly && removeItemButton);
  }
  renderNotCollapsed() {
    let { name, data, keyPath, deep, nextDeep, addFormVisible } = this.state, { isCollapsed, handleRemove, onDeltaUpdate, readOnly, getStyle, dataType, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser } = this.props, { minus, plus, addForm, ul, delimiter } = getStyle(name, data, keyPath, deep, dataType), keyList = Object.getOwnPropertyNames(data), isReadOnly = readOnly(name, data, keyPath, deep, dataType), addItemButton = (0, import_react.cloneElement)(plusMenuElement, { onClick: this.handleAddMode, className: "rejt-plus-menu", style: plus }), removeItemButton = (0, import_react.cloneElement)(minusMenuElement, { onClick: handleRemove, className: "rejt-minus-menu", style: minus }), list = keyList.map((key) => import_react.default.createElement(JsonNode, { key, name: key, data: data[key], keyPath, deep: nextDeep, isCollapsed, handleRemove: this.handleRemoveValue(key), handleUpdateValue: this.handleEditValue, onUpdate: this.onChildUpdate, onDeltaUpdate, readOnly, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator, textareaElementGenerator, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser }));
    return import_react.default.createElement("span", { className: "rejt-not-collapsed" }, import_react.default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "{"), !isReadOnly && addItemButton, import_react.default.createElement("ul", { className: "rejt-not-collapsed-list", style: ul }, list), !isReadOnly && addFormVisible && import_react.default.createElement("div", { className: "rejt-add-form", style: addForm }, import_react.default.createElement(JsonAddValue, { handleAdd: this.handleAddValueAdd, handleCancel: this.handleAddValueCancel, addButtonElement, cancelButtonElement, inputElementGenerator, keyPath, deep, onSubmitValueParser })), import_react.default.createElement("span", { className: "rejt-not-collapsed-delimiter", style: delimiter }, "}"), !isReadOnly && removeItemButton);
  }
  render() {
    let { name, collapsed, data, keyPath, deep } = this.state, { getStyle, dataType } = this.props, value2 = collapsed ? this.renderCollapsed() : this.renderNotCollapsed(), style = getStyle(name, data, keyPath, deep, dataType);
    return import_react.default.createElement("div", { className: "rejt-object-node" }, import_react.default.createElement("span", { onClick: this.handleCollapseMode }, import_react.default.createElement("span", { className: "rejt-name", style: style.name }, name, " :", " ")), value2);
  }
};
JsonObject.defaultProps = { keyPath: [], deep: 0, minusMenuElement: import_react.default.createElement("span", null, " - "), plusMenuElement: import_react.default.createElement("span", null, " + ") };
var JsonValue = class extends import_react.Component {
  constructor(props) {
    super(props);
    let keyPath = [...props.keyPath, props.name];
    this.state = { value: props.value, name: props.name, keyPath, deep: props.deep, editEnabled: false, inputRef: null }, this.handleEditMode = this.handleEditMode.bind(this), this.refInput = this.refInput.bind(this), this.handleCancelEdit = this.handleCancelEdit.bind(this), this.handleEdit = this.handleEdit.bind(this), this.onKeydown = this.onKeydown.bind(this);
  }
  static getDerivedStateFromProps(props, state) {
    return props.value !== state.value ? { value: props.value } : null;
  }
  componentDidUpdate() {
    let { editEnabled, inputRef, name, value: value2, keyPath, deep } = this.state, { readOnly, dataType } = this.props, isReadOnly = readOnly(name, value2, keyPath, deep, dataType);
    editEnabled && !isReadOnly && typeof inputRef.focus == "function" && inputRef.focus();
  }
  componentDidMount() {
    document.addEventListener("keydown", this.onKeydown);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.onKeydown);
  }
  onKeydown(event) {
    event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.repeat || ((event.code === "Enter" || event.key === "Enter") && (event.preventDefault(), this.handleEdit()), (event.code === "Escape" || event.key === "Escape") && (event.preventDefault(), this.handleCancelEdit()));
  }
  handleEdit() {
    let { handleUpdateValue, originalValue, logger: logger4, onSubmitValueParser, keyPath } = this.props, { inputRef, name, deep } = this.state;
    if (!inputRef) return;
    let newValue = onSubmitValueParser(true, keyPath, deep, name, inputRef.value);
    handleUpdateValue({ value: newValue, key: name }).then(() => {
      isComponentWillChange(originalValue, newValue) || this.handleCancelEdit();
    }).catch(logger4.error);
  }
  handleEditMode() {
    this.setState({ editEnabled: true });
  }
  refInput(node) {
    this.state.inputRef = node;
  }
  handleCancelEdit() {
    this.setState({ editEnabled: false });
  }
  render() {
    let { name, value: value2, editEnabled, keyPath, deep } = this.state, { handleRemove, originalValue, readOnly, dataType, getStyle, editButtonElement, cancelButtonElement, inputElementGenerator, minusMenuElement, keyPath: comeFromKeyPath } = this.props, style = getStyle(name, originalValue, keyPath, deep, dataType), isReadOnly = readOnly(name, originalValue, keyPath, deep, dataType), isEditing = editEnabled && !isReadOnly, inputElement = inputElementGenerator(VALUE, comeFromKeyPath, deep, name, originalValue, dataType), editButtonElementLayout = (0, import_react.cloneElement)(editButtonElement, { onClick: this.handleEdit }), cancelButtonElementLayout = (0, import_react.cloneElement)(cancelButtonElement, { onClick: this.handleCancelEdit }), inputElementLayout = (0, import_react.cloneElement)(inputElement, { ref: this.refInput, defaultValue: JSON.stringify(originalValue) }), minusMenuLayout = (0, import_react.cloneElement)(minusMenuElement, { onClick: handleRemove, className: "rejt-minus-menu", style: style.minus });
    return import_react.default.createElement("li", { className: "rejt-value-node", style: style.li }, import_react.default.createElement("span", { className: "rejt-name", style: style.name }, name, " : "), isEditing ? import_react.default.createElement("span", { className: "rejt-edit-form", style: style.editForm }, inputElementLayout, " ", cancelButtonElementLayout, editButtonElementLayout) : import_react.default.createElement("span", { className: "rejt-value", style: style.value, onClick: isReadOnly ? null : this.handleEditMode }, String(value2)), !isReadOnly && !isEditing && minusMenuLayout);
  }
};
JsonValue.defaultProps = { keyPath: [], deep: 0, handleUpdateValue: () => Promise.resolve(), editButtonElement: import_react.default.createElement("button", null, "e"), cancelButtonElement: import_react.default.createElement("button", null, "c"), minusMenuElement: import_react.default.createElement("span", null, " - ") };
var object = { minus: { color: "red" }, plus: { color: "green" }, collapsed: { color: "grey" }, delimiter: {}, ul: { padding: "0px", margin: "0 0 0 25px", listStyle: "none" }, name: { color: "#2287CD" }, addForm: {} };
var array = { minus: { color: "red" }, plus: { color: "green" }, collapsed: { color: "grey" }, delimiter: {}, ul: { padding: "0px", margin: "0 0 0 25px", listStyle: "none" }, name: { color: "#2287CD" }, addForm: {} };
var value = { minus: { color: "red" }, editForm: {}, value: { color: "#7bba3d" }, li: { minHeight: "22px", lineHeight: "22px", outline: "0px" }, name: { color: "#2287CD" } };
function parse3(string) {
  let result = string;
  if (result.indexOf("function") === 0) return (0, eval)(`(${result})`);
  try {
    result = JSON.parse(string);
  } catch {
  }
  return result;
}
var JsonTree = class extends import_react.Component {
  constructor(props) {
    super(props), this.state = { data: props.data, rootName: props.rootName }, this.onUpdate = this.onUpdate.bind(this), this.removeRoot = this.removeRoot.bind(this);
  }
  static getDerivedStateFromProps(props, state) {
    return props.data !== state.data || props.rootName !== state.rootName ? { data: props.data, rootName: props.rootName } : null;
  }
  onUpdate(key, data) {
    this.setState({ data }), this.props.onFullyUpdate(data);
  }
  removeRoot() {
    this.onUpdate(null, null);
  }
  render() {
    let { data, rootName } = this.state, { isCollapsed, onDeltaUpdate, readOnly, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElement, textareaElement, minusMenuElement, plusMenuElement, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser, fallback = null } = this.props, dataType = getObjectType(data), readOnlyFunction = readOnly;
    getObjectType(readOnly) === "Boolean" && (readOnlyFunction = () => readOnly);
    let inputElementFunction = inputElement;
    inputElement && getObjectType(inputElement) !== "Function" && (inputElementFunction = () => inputElement);
    let textareaElementFunction = textareaElement;
    return textareaElement && getObjectType(textareaElement) !== "Function" && (textareaElementFunction = () => textareaElement), dataType === "Object" || dataType === "Array" ? import_react.default.createElement("div", { className: "rejt-tree" }, import_react.default.createElement(JsonNode, { data, name: rootName, deep: -1, isCollapsed, onUpdate: this.onUpdate, onDeltaUpdate, readOnly: readOnlyFunction, getStyle, addButtonElement, cancelButtonElement, editButtonElement, inputElementGenerator: inputElementFunction, textareaElementGenerator: textareaElementFunction, minusMenuElement, plusMenuElement, handleRemove: this.removeRoot, beforeRemoveAction, beforeAddAction, beforeUpdateAction, logger: logger4, onSubmitValueParser })) : fallback;
  }
};
JsonTree.defaultProps = { rootName: "root", isCollapsed: (keyPath, deep) => deep !== -1, getStyle: (keyName, data, keyPath, deep, dataType) => {
  switch (dataType) {
    case "Object":
    case "Error":
      return object;
    case "Array":
      return array;
    default:
      return value;
  }
}, readOnly: () => false, onFullyUpdate: () => {
}, onDeltaUpdate: () => {
}, beforeRemoveAction: () => Promise.resolve(), beforeAddAction: () => Promise.resolve(), beforeUpdateAction: () => Promise.resolve(), logger: { error: () => {
} }, onSubmitValueParser: (isEditMode, keyPath, deep, name, rawValue) => parse3(rawValue), inputElement: () => import_react.default.createElement("input", null), textareaElement: () => import_react.default.createElement("textarea", null), fallback: null };
var { window: globalWindow2 } = import_global.global;
var Wrapper6 = Tr.div(({ theme }) => ({ position: "relative", display: "flex", '&[aria-readonly="true"]': { opacity: 0.5 }, ".rejt-tree": { marginLeft: "1rem", fontSize: "13px" }, ".rejt-value-node, .rejt-object-node > .rejt-collapsed, .rejt-array-node > .rejt-collapsed, .rejt-object-node > .rejt-not-collapsed, .rejt-array-node > .rejt-not-collapsed": { "& > svg": { opacity: 0, transition: "opacity 0.2s" } }, ".rejt-value-node:hover, .rejt-object-node:hover > .rejt-collapsed, .rejt-array-node:hover > .rejt-collapsed, .rejt-object-node:hover > .rejt-not-collapsed, .rejt-array-node:hover > .rejt-not-collapsed": { "& > svg": { opacity: 1 } }, ".rejt-edit-form button": { display: "none" }, ".rejt-add-form": { marginLeft: 10 }, ".rejt-add-value-node": { display: "inline-flex", alignItems: "center" }, ".rejt-name": { lineHeight: "22px" }, ".rejt-not-collapsed-delimiter": { lineHeight: "22px" }, ".rejt-plus-menu": { marginLeft: 5 }, ".rejt-object-node > span > *, .rejt-array-node > span > *": { position: "relative", zIndex: 2 }, ".rejt-object-node, .rejt-array-node": { position: "relative" }, ".rejt-object-node > span:first-of-type::after, .rejt-array-node > span:first-of-type::after, .rejt-collapsed::before, .rejt-not-collapsed::before": { content: '""', position: "absolute", top: 0, display: "block", width: "100%", marginLeft: "-1rem", padding: "0 4px 0 1rem", height: 22 }, ".rejt-collapsed::before, .rejt-not-collapsed::before": { zIndex: 1, background: "transparent", borderRadius: 4, transition: "background 0.2s", pointerEvents: "none", opacity: 0.1 }, ".rejt-object-node:hover, .rejt-array-node:hover": { "& > .rejt-collapsed::before, & > .rejt-not-collapsed::before": { background: theme.color.secondary } }, ".rejt-collapsed::after, .rejt-not-collapsed::after": { content: '""', position: "absolute", display: "inline-block", pointerEvents: "none", width: 0, height: 0 }, ".rejt-collapsed::after": { left: -8, top: 8, borderTop: "3px solid transparent", borderBottom: "3px solid transparent", borderLeft: "3px solid rgba(153,153,153,0.6)" }, ".rejt-not-collapsed::after": { left: -10, top: 10, borderTop: "3px solid rgba(153,153,153,0.6)", borderLeft: "3px solid transparent", borderRight: "3px solid transparent" }, ".rejt-value": { display: "inline-block", border: "1px solid transparent", borderRadius: 4, margin: "1px 0", padding: "0 4px", cursor: "text", color: theme.color.defaultText }, ".rejt-value-node:hover > .rejt-value": { background: theme.color.lighter, borderColor: theme.appBorderColor } }));
var ButtonInline = Tr.button(({ theme, primary }) => ({ border: 0, height: 20, margin: 1, borderRadius: 4, background: primary ? theme.color.secondary : "transparent", color: primary ? theme.color.lightest : theme.color.dark, fontWeight: primary ? "bold" : "normal", cursor: "pointer", order: primary ? "initial" : 9 }));
var ActionAddIcon = Tr(AddIcon)(({ theme, disabled }) => ({ display: "inline-block", verticalAlign: "middle", width: 15, height: 15, padding: 3, marginLeft: 5, cursor: disabled ? "not-allowed" : "pointer", color: theme.textMutedColor, "&:hover": disabled ? {} : { color: theme.color.ancillary }, "svg + &": { marginLeft: 0 } }));
var ActionSubstractIcon = Tr(SubtractIcon)(({ theme, disabled }) => ({ display: "inline-block", verticalAlign: "middle", width: 15, height: 15, padding: 3, marginLeft: 5, cursor: disabled ? "not-allowed" : "pointer", color: theme.textMutedColor, "&:hover": disabled ? {} : { color: theme.color.negative }, "svg + &": { marginLeft: 0 } }));
var Input = Tr.input(({ theme, placeholder }) => ({ outline: 0, margin: placeholder ? 1 : "1px 0", padding: "3px 4px", color: theme.color.defaultText, background: theme.background.app, border: `1px solid ${theme.appBorderColor}`, borderRadius: 4, lineHeight: "14px", width: placeholder === "Key" ? 80 : 120, "&:focus": { border: `1px solid ${theme.color.secondary}` } }));
var RawButton = Tr(Dl)(({ theme }) => ({ position: "absolute", zIndex: 2, top: 2, right: 2, height: 21, padding: "0 3px", background: theme.background.bar, border: `1px solid ${theme.appBorderColor}`, borderRadius: 3, color: theme.textMutedColor, fontSize: "9px", fontWeight: "bold", textDecoration: "none", span: { marginLeft: 3, marginTop: 1 } }));
var RawInput = Tr(wL.Textarea)(({ theme }) => ({ flex: 1, padding: "7px 6px", fontFamily: theme.typography.fonts.mono, fontSize: "12px", lineHeight: "18px", "&::placeholder": { fontFamily: theme.typography.fonts.base, fontSize: "13px" }, "&:placeholder-shown": { padding: "7px 10px" } }));
var ENTER_EVENT = { bubbles: true, cancelable: true, key: "Enter", code: "Enter", keyCode: 13 };
var dispatchEnterKey = (event) => {
  event.currentTarget.dispatchEvent(new globalWindow2.KeyboardEvent("keydown", ENTER_EVENT));
};
var selectValue = (event) => {
  event.currentTarget.select();
};
var getCustomStyleFunction = (theme) => () => ({ name: { color: theme.color.secondary }, collapsed: { color: theme.color.dark }, ul: { listStyle: "none", margin: "0 0 0 1rem", padding: 0 }, li: { outline: 0 } });
var ObjectControl = ({ name, value: value2, onChange, argType }) => {
  var _a;
  let theme = Mt(), data = (0, import_react.useMemo)(() => value2 && (0, import_cloneDeep.default)(value2), [value2]), hasData = data != null, [showRaw, setShowRaw] = (0, import_react.useState)(!hasData), [parseError, setParseError] = (0, import_react.useState)(null), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly), updateRaw = (0, import_react.useCallback)((raw) => {
    try {
      raw && onChange(JSON.parse(raw)), setParseError(void 0);
    } catch (e) {
      setParseError(e);
    }
  }, [onChange]), [forceVisible, setForceVisible] = (0, import_react.useState)(false), onForceVisible = (0, import_react.useCallback)(() => {
    onChange({}), setForceVisible(true);
  }, [setForceVisible]), htmlElRef = (0, import_react.useRef)(null);
  if ((0, import_react.useEffect)(() => {
    forceVisible && htmlElRef.current && htmlElRef.current.select();
  }, [forceVisible]), !hasData) return import_react.default.createElement(Ao, { disabled: readonly, id: getControlSetterButtonId(name), onClick: onForceVisible }, "Set object");
  let rawJSONForm = import_react.default.createElement(RawInput, { ref: htmlElRef, id: getControlId(name), name, defaultValue: value2 === null ? "" : JSON.stringify(value2, null, 2), onBlur: (event) => updateRaw(event.target.value), placeholder: "Edit JSON string...", autoFocus: forceVisible, valid: parseError ? "error" : null, readOnly: readonly }), isObjectOrArray = Array.isArray(value2) || typeof value2 == "object" && (value2 == null ? void 0 : value2.constructor) === Object;
  return import_react.default.createElement(Wrapper6, { "aria-readonly": readonly }, isObjectOrArray && import_react.default.createElement(RawButton, { onClick: (e) => {
    e.preventDefault(), setShowRaw((v) => !v);
  } }, showRaw ? import_react.default.createElement(EyeCloseIcon, null) : import_react.default.createElement(EyeIcon, null), import_react.default.createElement("span", null, "RAW")), showRaw ? rawJSONForm : import_react.default.createElement(JsonTree, { readOnly: readonly || !isObjectOrArray, isCollapsed: isObjectOrArray ? void 0 : () => true, data, rootName: name, onFullyUpdate: onChange, getStyle: getCustomStyleFunction(theme), cancelButtonElement: import_react.default.createElement(ButtonInline, { type: "button" }, "Cancel"), editButtonElement: import_react.default.createElement(ButtonInline, { type: "submit" }, "Save"), addButtonElement: import_react.default.createElement(ButtonInline, { type: "submit", primary: true }, "Save"), plusMenuElement: import_react.default.createElement(ActionAddIcon, null), minusMenuElement: import_react.default.createElement(ActionSubstractIcon, null), inputElement: (_, __, ___, key) => key ? import_react.default.createElement(Input, { onFocus: selectValue, onBlur: dispatchEnterKey }) : import_react.default.createElement(Input, null), fallback: rawJSONForm }));
};
var RangeInput = Tr.input(({ theme, min, max, value: value2, disabled }) => ({ "&": { width: "100%", backgroundColor: "transparent", appearance: "none" }, "&::-webkit-slider-runnable-track": { background: theme.base === "light" ? `linear-gradient(to right, 
            ${theme.color.green} 0%, ${theme.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme.color.green} 0%, ${theme.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme.input.background)} 100%)`, boxShadow: `${theme.appBorderColor} 0 0 0 1px inset`, borderRadius: 6, width: "100%", height: 6, cursor: disabled ? "not-allowed" : "pointer" }, "&::-webkit-slider-thumb": { marginTop: "-6px", width: 16, height: 16, border: `1px solid ${rgba(theme.appBorderColor, 0.2)}`, borderRadius: "50px", boxShadow: `0 1px 3px 0px ${rgba(theme.appBorderColor, 0.2)}`, cursor: disabled ? "not-allowed" : "grab", appearance: "none", background: `${theme.input.background}`, transition: "all 150ms ease-out", "&:hover": { background: `${curriedDarken$1(0.05, theme.input.background)}`, transform: "scale3d(1.1, 1.1, 1.1) translateY(-1px)", transition: "all 50ms ease-out" }, "&:active": { background: `${theme.input.background}`, transform: "scale3d(1, 1, 1) translateY(0px)", cursor: disabled ? "not-allowed" : "grab" } }, "&:focus": { outline: "none", "&::-webkit-slider-runnable-track": { borderColor: rgba(theme.color.secondary, 0.4) }, "&::-webkit-slider-thumb": { borderColor: theme.color.secondary, boxShadow: `0 0px 5px 0px ${theme.color.secondary}` } }, "&::-moz-range-track": { background: theme.base === "light" ? `linear-gradient(to right, 
            ${theme.color.green} 0%, ${theme.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme.color.green} 0%, ${theme.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme.input.background)} 100%)`, boxShadow: `${theme.appBorderColor} 0 0 0 1px inset`, borderRadius: 6, width: "100%", height: 6, cursor: disabled ? "not-allowed" : "pointer", outline: "none" }, "&::-moz-range-thumb": { width: 16, height: 16, border: `1px solid ${rgba(theme.appBorderColor, 0.2)}`, borderRadius: "50px", boxShadow: `0 1px 3px 0px ${rgba(theme.appBorderColor, 0.2)}`, cursor: disabled ? "not-allowed" : "grap", background: `${theme.input.background}`, transition: "all 150ms ease-out", "&:hover": { background: `${curriedDarken$1(0.05, theme.input.background)}`, transform: "scale3d(1.1, 1.1, 1.1) translateY(-1px)", transition: "all 50ms ease-out" }, "&:active": { background: `${theme.input.background}`, transform: "scale3d(1, 1, 1) translateY(0px)", cursor: "grabbing" } }, "&::-ms-track": { background: theme.base === "light" ? `linear-gradient(to right, 
            ${theme.color.green} 0%, ${theme.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedDarken$1(0.02, theme.input.background)} 100%)` : `linear-gradient(to right, 
            ${theme.color.green} 0%, ${theme.color.green} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme.input.background)} ${(value2 - min) / (max - min) * 100}%, 
            ${curriedLighten$1(0.02, theme.input.background)} 100%)`, boxShadow: `${theme.appBorderColor} 0 0 0 1px inset`, color: "transparent", width: "100%", height: "6px", cursor: "pointer" }, "&::-ms-fill-lower": { borderRadius: 6 }, "&::-ms-fill-upper": { borderRadius: 6 }, "&::-ms-thumb": { width: 16, height: 16, background: `${theme.input.background}`, border: `1px solid ${rgba(theme.appBorderColor, 0.2)}`, borderRadius: 50, cursor: "grab", marginTop: 0 }, "@supports (-ms-ime-align:auto)": { "input[type=range]": { margin: "0" } } }));
var RangeLabel = Tr.span({ paddingLeft: 5, paddingRight: 5, fontSize: 12, whiteSpace: "nowrap", fontFeatureSettings: "tnum", fontVariantNumeric: "tabular-nums", "[aria-readonly=true] &": { opacity: 0.5 } });
var RangeCurrentAndMaxLabel = Tr(RangeLabel)(({ numberOFDecimalsPlaces, max }) => ({ width: `${numberOFDecimalsPlaces + max.toString().length * 2 + 3}ch`, textAlign: "right", flexShrink: 0 }));
var RangeWrapper = Tr.div({ display: "flex", alignItems: "center", width: "100%" });
function getNumberOfDecimalPlaces(number) {
  let match = number.toString().match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  return match ? Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0)) : 0;
}
var RangeControl = ({ name, value: value2, onChange, min = 0, max = 100, step = 1, onBlur, onFocus, argType }) => {
  var _a;
  let handleChange = (event) => {
    onChange(parse2(event.target.value));
  }, hasValue = value2 !== void 0, numberOFDecimalsPlaces = (0, import_react.useMemo)(() => getNumberOfDecimalPlaces(step), [step]), readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly);
  return import_react.default.createElement(RangeWrapper, { "aria-readonly": readonly }, import_react.default.createElement(RangeLabel, null, min), import_react.default.createElement(RangeInput, { id: getControlId(name), type: "range", disabled: readonly, onChange: handleChange, name, value: value2, min, max, step, onFocus, onBlur }), import_react.default.createElement(RangeCurrentAndMaxLabel, { numberOFDecimalsPlaces, max }, hasValue ? value2.toFixed(numberOFDecimalsPlaces) : "--", " / ", max));
};
var Wrapper7 = Tr.label({ display: "flex" });
var MaxLength = Tr.div(({ isMaxed }) => ({ marginLeft: "0.75rem", paddingTop: "0.35rem", color: isMaxed ? "red" : void 0 }));
var TextControl = ({ name, value: value2, onChange, onFocus, onBlur, maxLength, argType }) => {
  var _a;
  let handleChange = (event) => {
    onChange(event.target.value);
  }, readonly = !!((_a = argType == null ? void 0 : argType.table) == null ? void 0 : _a.readonly), [forceVisible, setForceVisible] = (0, import_react.useState)(false), onForceVisible = (0, import_react.useCallback)(() => {
    onChange(""), setForceVisible(true);
  }, [setForceVisible]);
  if (value2 === void 0) return import_react.default.createElement(Ao, { variant: "outline", size: "medium", disabled: readonly, id: getControlSetterButtonId(name), onClick: onForceVisible }, "Set string");
  let isValid = typeof value2 == "string";
  return import_react.default.createElement(Wrapper7, null, import_react.default.createElement(wL.Textarea, { id: getControlId(name), maxLength, onChange: handleChange, disabled: readonly, size: "flex", placeholder: "Edit string...", autoFocus: forceVisible, valid: isValid ? null : "error", name, value: isValid ? value2 : "", onFocus, onBlur }), maxLength && import_react.default.createElement(MaxLength, { isMaxed: (value2 == null ? void 0 : value2.length) === maxLength }, (value2 == null ? void 0 : value2.length) ?? 0, " / ", maxLength));
};
var FileInput = Tr(wL.Input)({ padding: 10 });
function revokeOldUrls(urls) {
  urls.forEach((url) => {
    url.startsWith("blob:") && URL.revokeObjectURL(url);
  });
}
var FilesControl = ({ onChange, name, accept = "image/*", value: value2, argType }) => {
  var _a;
  let inputElement = (0, import_react.useRef)(null), readonly = (_a = argType == null ? void 0 : argType.control) == null ? void 0 : _a.readOnly;
  function handleFileChange(e) {
    if (!e.target.files) return;
    let fileUrls = Array.from(e.target.files).map((file) => URL.createObjectURL(file));
    onChange(fileUrls), revokeOldUrls(value2);
  }
  return (0, import_react.useEffect)(() => {
    value2 == null && inputElement.current && (inputElement.current.value = null);
  }, [value2, name]), import_react.default.createElement(FileInput, { ref: inputElement, id: getControlId(name), type: "file", name, multiple: true, disabled: readonly, onChange: handleFileChange, accept, size: "flex" });
};
var LazyColorControl = (0, import_react.lazy)(() => import("./Color-KGDBMAHA-TLSKNIGF.js"));
var ColorControl = (props) => import_react.default.createElement(import_react.Suspense, { fallback: import_react.default.createElement("div", null) }, import_react.default.createElement(LazyColorControl, { ...props }));
var Controls2 = { array: ObjectControl, object: ObjectControl, boolean: BooleanControl, color: ColorControl, date: DateControl, number: NumberControl, check: OptionsControl, "inline-check": OptionsControl, radio: OptionsControl, "inline-radio": OptionsControl, select: OptionsControl, "multi-select": OptionsControl, range: RangeControl, text: TextControl, file: FilesControl };
var NoControl = () => import_react.default.createElement(import_react.default.Fragment, null, "-");
var ArgControl = ({ row, arg, updateArgs, isHovered }) => {
  var _a;
  let { key, control } = row, [isFocused, setFocused] = (0, import_react.useState)(false), [boxedValue, setBoxedValue] = (0, import_react.useState)({ value: arg });
  (0, import_react.useEffect)(() => {
    isFocused || setBoxedValue({ value: arg });
  }, [isFocused, arg]);
  let onChange = (0, import_react.useCallback)((argVal) => (setBoxedValue({ value: argVal }), updateArgs({ [key]: argVal }), argVal), [updateArgs, key]), onBlur = (0, import_react.useCallback)(() => setFocused(false), []), onFocus = (0, import_react.useCallback)(() => setFocused(true), []);
  if (!control || control.disable) {
    let canBeSetup = (control == null ? void 0 : control.disable) !== true && ((_a = row == null ? void 0 : row.type) == null ? void 0 : _a.name) !== "function";
    return isHovered && canBeSetup ? import_react.default.createElement(Bu, { href: "https://storybook.js.org/docs/react/essentials/controls", target: "_blank", withArrow: true }, "Setup controls") : import_react.default.createElement(NoControl, null);
  }
  let props = { name: key, argType: row, value: boxedValue.value, onChange, onBlur, onFocus }, Control = Controls2[control.type] || NoControl;
  return import_react.default.createElement(Control, { ...props, ...control, controlType: control.type });
};
var Name = Tr.span({ fontWeight: "bold" });
var Required = Tr.span(({ theme }) => ({ color: theme.color.negative, fontFamily: theme.typography.fonts.mono, cursor: "help" }));
var Description = Tr.div(({ theme }) => ({ "&&": { p: { margin: "0 0 10px 0" }, a: { color: theme.color.secondary } }, code: { ...At({ theme }), fontSize: 12, fontFamily: theme.typography.fonts.mono }, "& code": { margin: 0, display: "inline-block" }, "& pre > code": { whiteSpace: "pre-wrap" } }));
var Type = Tr.div(({ theme, hasDescription }) => ({ color: theme.base === "light" ? curriedTransparentize$1(0.1, theme.color.defaultText) : curriedTransparentize$1(0.2, theme.color.defaultText), marginTop: hasDescription ? 4 : 0 }));
var TypeWithJsDoc = Tr.div(({ theme, hasDescription }) => ({ color: theme.base === "light" ? curriedTransparentize$1(0.1, theme.color.defaultText) : curriedTransparentize$1(0.2, theme.color.defaultText), marginTop: hasDescription ? 12 : 0, marginBottom: 12 }));
var StyledTd = Tr.td(({ theme, expandable }) => ({ paddingLeft: expandable ? "40px !important" : "20px !important" }));
var toSummary = (value2) => value2 && { summary: typeof value2 == "string" ? value2 : value2.name };
var ArgRow = (props) => {
  var _a;
  let [isHovered, setIsHovered] = (0, import_react.useState)(false), { row, updateArgs, compact, expandable, initialExpandedArgs } = props, { name, description } = row, table = row.table || {}, type = table.type || toSummary(row.type), defaultValue = table.defaultValue || row.defaultValue, required = (_a = row.type) == null ? void 0 : _a.required, hasDescription = description != null && description !== "";
  return import_react.default.createElement("tr", { onMouseEnter: () => setIsHovered(true), onMouseLeave: () => setIsHovered(false) }, import_react.default.createElement(StyledTd, { expandable }, import_react.default.createElement(Name, null, name), required ? import_react.default.createElement(Required, { title: "Required" }, "*") : null), compact ? null : import_react.default.createElement("td", null, hasDescription && import_react.default.createElement(Description, null, import_react.default.createElement(index_modern_default, null, description)), table.jsDocTags != null ? import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(TypeWithJsDoc, { hasDescription }, import_react.default.createElement(ArgValue, { value: type, initialExpandedArgs })), import_react.default.createElement(ArgJsDoc, { tags: table.jsDocTags })) : import_react.default.createElement(Type, { hasDescription }, import_react.default.createElement(ArgValue, { value: type, initialExpandedArgs }))), compact ? null : import_react.default.createElement("td", null, import_react.default.createElement(ArgValue, { value: defaultValue, initialExpandedArgs })), updateArgs ? import_react.default.createElement("td", null, import_react.default.createElement(ArgControl, { ...props, isHovered })) : null);
};
var ExpanderIconDown = Tr(ChevronDownIcon)(({ theme }) => ({ marginRight: 8, marginLeft: -10, marginTop: -2, height: 12, width: 12, color: theme.base === "light" ? curriedTransparentize$1(0.25, theme.color.defaultText) : curriedTransparentize$1(0.3, theme.color.defaultText), border: "none", display: "inline-block" }));
var ExpanderIconRight = Tr(ChevronRightIcon)(({ theme }) => ({ marginRight: 8, marginLeft: -10, marginTop: -2, height: 12, width: 12, color: theme.base === "light" ? curriedTransparentize$1(0.25, theme.color.defaultText) : curriedTransparentize$1(0.3, theme.color.defaultText), border: "none", display: "inline-block" }));
var FlexWrapper = Tr.span(({ theme }) => ({ display: "flex", lineHeight: "20px", alignItems: "center" }));
var Section = Tr.td(({ theme }) => ({ position: "relative", letterSpacing: "0.35em", textTransform: "uppercase", fontWeight: theme.typography.weight.bold, fontSize: theme.typography.size.s1 - 1, color: theme.base === "light" ? curriedTransparentize$1(0.4, theme.color.defaultText) : curriedTransparentize$1(0.6, theme.color.defaultText), background: `${theme.background.app} !important`, "& ~ td": { background: `${theme.background.app} !important` } }));
var Subsection = Tr.td(({ theme }) => ({ position: "relative", fontWeight: theme.typography.weight.bold, fontSize: theme.typography.size.s2 - 1, background: theme.background.app }));
var StyledTd2 = Tr.td(() => ({ position: "relative" }));
var StyledTr = Tr.tr(({ theme }) => ({ "&:hover > td": { backgroundColor: `${curriedLighten$1(5e-3, theme.background.app)} !important`, boxShadow: `${theme.color.mediumlight} 0 - 1px 0 0 inset`, cursor: "row-resize" } }));
var ClickIntercept = Tr.button(() => ({ background: "none", border: "none", padding: "0", font: "inherit", position: "absolute", top: 0, bottom: 0, left: 0, right: 0, height: "100%", width: "100%", color: "transparent", cursor: "row-resize !important" }));
var SectionRow = ({ level = "section", label, children, initialExpanded = true, colSpan = 3 }) => {
  let [expanded, setExpanded] = (0, import_react.useState)(initialExpanded), Level = level === "subsection" ? Subsection : Section, itemCount = (children == null ? void 0 : children.length) || 0, caption = level === "subsection" ? `${itemCount} item${itemCount !== 1 ? "s" : ""}` : "", helperText = `${expanded ? "Hide" : "Show"} ${level === "subsection" ? itemCount : label} item${itemCount !== 1 ? "s" : ""}`;
  return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(StyledTr, { title: helperText }, import_react.default.createElement(Level, { colSpan: 1 }, import_react.default.createElement(ClickIntercept, { onClick: (e) => setExpanded(!expanded), tabIndex: 0 }, helperText), import_react.default.createElement(FlexWrapper, null, expanded ? import_react.default.createElement(ExpanderIconDown, null) : import_react.default.createElement(ExpanderIconRight, null), label)), import_react.default.createElement(StyledTd2, { colSpan: colSpan - 1 }, import_react.default.createElement(ClickIntercept, { onClick: (e) => setExpanded(!expanded), tabIndex: -1, style: { outline: "none" } }, helperText), expanded ? null : caption)), expanded ? children : null);
};
var Row = Tr.div(({ theme }) => ({ display: "flex", gap: 16, borderBottom: `1px solid ${theme.appBorderColor}`, "&:last-child": { borderBottom: 0 } }));
var Column = Tr.div(({ numColumn }) => ({ display: "flex", flexDirection: "column", flex: numColumn || 1, gap: 5, padding: "12px 20px" }));
var SkeletonText = Tr.div(({ theme, width, height }) => ({ animation: `${theme.animation.glow} 1.5s ease-in-out infinite`, background: theme.appBorderColor, width: width || "100%", height: height || 16, borderRadius: 3 }));
var columnWidth = [2, 4, 2, 2];
var Skeleton = () => import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(Row, null, import_react.default.createElement(Column, { numColumn: columnWidth[0] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[1] }, import_react.default.createElement(SkeletonText, { width: "30%" })), import_react.default.createElement(Column, { numColumn: columnWidth[2] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[3] }, import_react.default.createElement(SkeletonText, { width: "60%" }))), import_react.default.createElement(Row, null, import_react.default.createElement(Column, { numColumn: columnWidth[0] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[1] }, import_react.default.createElement(SkeletonText, { width: "80%" }), import_react.default.createElement(SkeletonText, { width: "30%" })), import_react.default.createElement(Column, { numColumn: columnWidth[2] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[3] }, import_react.default.createElement(SkeletonText, { width: "60%" }))), import_react.default.createElement(Row, null, import_react.default.createElement(Column, { numColumn: columnWidth[0] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[1] }, import_react.default.createElement(SkeletonText, { width: "80%" }), import_react.default.createElement(SkeletonText, { width: "30%" })), import_react.default.createElement(Column, { numColumn: columnWidth[2] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[3] }, import_react.default.createElement(SkeletonText, { width: "60%" }))), import_react.default.createElement(Row, null, import_react.default.createElement(Column, { numColumn: columnWidth[0] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[1] }, import_react.default.createElement(SkeletonText, { width: "80%" }), import_react.default.createElement(SkeletonText, { width: "30%" })), import_react.default.createElement(Column, { numColumn: columnWidth[2] }, import_react.default.createElement(SkeletonText, { width: "60%" })), import_react.default.createElement(Column, { numColumn: columnWidth[3] }, import_react.default.createElement(SkeletonText, { width: "60%" }))));
var Wrapper8 = Tr.div(({ inAddonPanel, theme }) => ({ height: inAddonPanel ? "100%" : "auto", display: "flex", border: inAddonPanel ? "none" : `1px solid ${theme.appBorderColor}`, borderRadius: inAddonPanel ? 0 : theme.appBorderRadius, padding: inAddonPanel ? 0 : 40, alignItems: "center", justifyContent: "center", flexDirection: "column", gap: 15, background: theme.background.content, boxShadow: "rgba(0, 0, 0, 0.10) 0 1px 3px 0" }));
var Links = Tr.div(({ theme }) => ({ display: "flex", fontSize: theme.typography.size.s2 - 1, gap: 25 }));
var Divider = Tr.div(({ theme }) => ({ width: 1, height: 16, backgroundColor: theme.appBorderColor }));
var Empty = ({ inAddonPanel }) => {
  let [isLoading, setIsLoading] = (0, import_react.useState)(true);
  return (0, import_react.useEffect)(() => {
    let load = setTimeout(() => {
      setIsLoading(false);
    }, 100);
    return () => clearTimeout(load);
  }, []), isLoading ? null : import_react.default.createElement(Wrapper8, { inAddonPanel }, import_react.default.createElement(b1, { title: inAddonPanel ? "Interactive story playground" : "Args table with interactive controls couldn't be auto-generated", description: import_react.default.createElement(import_react.default.Fragment, null, "Controls give you an easy to use interface to test your components. Set your story args and you'll see controls appearing here automatically."), footer: import_react.default.createElement(Links, null, inAddonPanel && import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(Bu, { href: "https://youtu.be/0gOfS6K0x0E", target: "_blank", withArrow: true }, import_react.default.createElement(VideoIcon, null), " Watch 5m video"), import_react.default.createElement(Divider, null), import_react.default.createElement(Bu, { href: "https://storybook.js.org/docs/essentials/controls", target: "_blank", withArrow: true }, import_react.default.createElement(DocumentIcon, null), " Read docs")), !inAddonPanel && import_react.default.createElement(Bu, { href: "https://storybook.js.org/docs/essentials/controls", target: "_blank", withArrow: true }, import_react.default.createElement(DocumentIcon, null), " Learn how to set that up")) }));
};
var TableWrapper = Tr.table(({ theme, compact, inAddonPanel }) => ({ "&&": { borderSpacing: 0, color: theme.color.defaultText, "td, th": { padding: 0, border: "none", verticalAlign: "top", textOverflow: "ellipsis" }, fontSize: theme.typography.size.s2 - 1, lineHeight: "20px", textAlign: "left", width: "100%", marginTop: inAddonPanel ? 0 : 25, marginBottom: inAddonPanel ? 0 : 40, "thead th:first-of-type, td:first-of-type": { width: "25%" }, "th:first-of-type, td:first-of-type": { paddingLeft: 20 }, "th:nth-of-type(2), td:nth-of-type(2)": { ...compact ? null : { width: "35%" } }, "td:nth-of-type(3)": { ...compact ? null : { width: "15%" } }, "th:last-of-type, td:last-of-type": { paddingRight: 20, ...compact ? null : { width: "25%" } }, th: { color: theme.base === "light" ? curriedTransparentize$1(0.25, theme.color.defaultText) : curriedTransparentize$1(0.45, theme.color.defaultText), paddingTop: 10, paddingBottom: 10, paddingLeft: 15, paddingRight: 15 }, td: { paddingTop: "10px", paddingBottom: "10px", "&:not(:first-of-type)": { paddingLeft: 15, paddingRight: 15 }, "&:last-of-type": { paddingRight: 20 } }, marginLeft: inAddonPanel ? 0 : 1, marginRight: inAddonPanel ? 0 : 1, tbody: { ...inAddonPanel ? null : { filter: theme.base === "light" ? "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.10))" : "drop-shadow(0px 1px 3px rgba(0, 0, 0, 0.20))" }, "> tr > *": { background: theme.background.content, borderTop: `1px solid ${theme.appBorderColor}` }, ...inAddonPanel ? null : { "> tr:first-of-type > *": { borderBlockStart: `1px solid ${theme.appBorderColor}` }, "> tr:last-of-type > *": { borderBlockEnd: `1px solid ${theme.appBorderColor}` }, "> tr > *:first-of-type": { borderInlineStart: `1px solid ${theme.appBorderColor}` }, "> tr > *:last-of-type": { borderInlineEnd: `1px solid ${theme.appBorderColor}` }, "> tr:first-of-type > td:first-of-type": { borderTopLeftRadius: theme.appBorderRadius }, "> tr:first-of-type > td:last-of-type": { borderTopRightRadius: theme.appBorderRadius }, "> tr:last-of-type > td:first-of-type": { borderBottomLeftRadius: theme.appBorderRadius }, "> tr:last-of-type > td:last-of-type": { borderBottomRightRadius: theme.appBorderRadius } } } } }));
var StyledIconButton = Tr(Dl)(({ theme }) => ({ margin: "-4px -12px -4px 0" }));
var ControlHeadingWrapper = Tr.span({ display: "flex", justifyContent: "space-between" });
var sortFns = { alpha: (a, b) => a.name.localeCompare(b.name), requiredFirst: (a, b) => {
  var _a, _b;
  return +!!((_a = b.type) == null ? void 0 : _a.required) - +!!((_b = a.type) == null ? void 0 : _b.required) || a.name.localeCompare(b.name);
}, none: void 0 };
var groupRows = (rows, sort) => {
  let sections = { ungrouped: [], ungroupedSubsections: {}, sections: {} };
  if (!rows) return sections;
  Object.entries(rows).forEach(([key, row]) => {
    let { category, subcategory } = (row == null ? void 0 : row.table) || {};
    if (category) {
      let section = sections.sections[category] || { ungrouped: [], subsections: {} };
      if (!subcategory) section.ungrouped.push({ key, ...row });
      else {
        let subsection = section.subsections[subcategory] || [];
        subsection.push({ key, ...row }), section.subsections[subcategory] = subsection;
      }
      sections.sections[category] = section;
    } else if (subcategory) {
      let subsection = sections.ungroupedSubsections[subcategory] || [];
      subsection.push({ key, ...row }), sections.ungroupedSubsections[subcategory] = subsection;
    } else sections.ungrouped.push({ key, ...row });
  });
  let sortFn = sortFns[sort], sortSubsection = (record) => sortFn ? Object.keys(record).reduce((acc, cur) => ({ ...acc, [cur]: record[cur].sort(sortFn) }), {}) : record;
  return { ungrouped: sections.ungrouped.sort(sortFn), ungroupedSubsections: sortSubsection(sections.ungroupedSubsections), sections: Object.keys(sections.sections).reduce((acc, cur) => ({ ...acc, [cur]: { ungrouped: sections.sections[cur].ungrouped.sort(sortFn), subsections: sortSubsection(sections.sections[cur].subsections) } }), {}) };
};
var safeIncludeConditionalArg = (row, args, globals) => {
  try {
    return P(row, args, globals);
  } catch (err) {
    return import_client_logger.once.warn(err.message), false;
  }
};
var ArgsTable = (props) => {
  let { updateArgs, resetArgs, compact, inAddonPanel, initialExpandedArgs, sort = "none", isLoading } = props;
  if ("error" in props) {
    let { error } = props;
    return import_react.default.createElement(EmptyBlock, null, error, "", import_react.default.createElement(Bu, { href: "http://storybook.js.org/docs/", target: "_blank", withArrow: true }, import_react.default.createElement(DocumentIcon, null), " Read the docs"));
  }
  if (isLoading) return import_react.default.createElement(Skeleton, null);
  let { rows, args, globals } = "rows" in props && props, groups = groupRows((0, import_pickBy.default)(rows, (row) => {
    var _a;
    return !((_a = row == null ? void 0 : row.table) == null ? void 0 : _a.disable) && safeIncludeConditionalArg(row, args || {}, globals || {});
  }), sort), hasNoUngrouped = groups.ungrouped.length === 0, hasNoSections = Object.entries(groups.sections).length === 0, hasNoUngroupedSubsections = Object.entries(groups.ungroupedSubsections).length === 0;
  if (hasNoUngrouped && hasNoSections && hasNoUngroupedSubsections) return import_react.default.createElement(Empty, { inAddonPanel });
  let colSpan = 1;
  updateArgs && (colSpan += 1), compact || (colSpan += 2);
  let expandable = Object.keys(groups.sections).length > 0, common = { updateArgs, compact, inAddonPanel, initialExpandedArgs };
  return import_react.default.createElement(z5, null, import_react.default.createElement(TableWrapper, { compact, inAddonPanel, className: "docblock-argstable sb-unstyled" }, import_react.default.createElement("thead", { className: "docblock-argstable-head" }, import_react.default.createElement("tr", null, import_react.default.createElement("th", null, import_react.default.createElement("span", null, "Name")), compact ? null : import_react.default.createElement("th", null, import_react.default.createElement("span", null, "Description")), compact ? null : import_react.default.createElement("th", null, import_react.default.createElement("span", null, "Default")), updateArgs ? import_react.default.createElement("th", null, import_react.default.createElement(ControlHeadingWrapper, null, "Control", " ", !isLoading && resetArgs && import_react.default.createElement(StyledIconButton, { onClick: () => resetArgs(), title: "Reset controls" }, import_react.default.createElement(UndoIcon, { "aria-hidden": true })))) : null)), import_react.default.createElement("tbody", { className: "docblock-argstable-body" }, groups.ungrouped.map((row) => import_react.default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(groups.ungroupedSubsections).map(([subcategory, subsection]) => import_react.default.createElement(SectionRow, { key: subcategory, label: subcategory, level: "subsection", colSpan }, subsection.map((row) => import_react.default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], expandable, ...common })))), Object.entries(groups.sections).map(([category, section]) => import_react.default.createElement(SectionRow, { key: category, label: category, level: "section", colSpan }, section.ungrouped.map((row) => import_react.default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], ...common })), Object.entries(section.subsections).map(([subcategory, subsection]) => import_react.default.createElement(SectionRow, { key: subcategory, label: subcategory, level: "subsection", colSpan }, subsection.map((row) => import_react.default.createElement(ArgRow, { key: row.key, row, arg: args && args[row.key], expandable, ...common })))))))));
};
var TabbedArgsTable = ({ tabs, ...props }) => {
  let entries = Object.entries(tabs);
  return entries.length === 1 ? import_react.default.createElement(ArgsTable, { ...entries[0][1], ...props }) : import_react.default.createElement(w1, null, entries.map((entry, index) => {
    let [label, table] = entry, id = `prop_table_div_${label}`, Component4 = "div", argsTableProps = index === 0 ? props : { sort: props.sort };
    return import_react.default.createElement(Component4, { key: id, id, title: label }, ({ active }) => active ? import_react.default.createElement(ArgsTable, { key: `prop_table_${label}`, ...table, ...argsTableProps }) : null);
  }));
};
var Label4 = Tr.div(({ theme }) => ({ marginRight: 30, fontSize: `${theme.typography.size.s1}px`, color: theme.base === "light" ? curriedTransparentize$1(0.4, theme.color.defaultText) : curriedTransparentize$1(0.6, theme.color.defaultText) }));
var Sample = Tr.div({ overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis" });
var TypeSpecimen = Tr.div({ display: "flex", flexDirection: "row", alignItems: "baseline", "&:not(:last-child)": { marginBottom: "1rem" } });
var Wrapper9 = Tr.div(j, ({ theme }) => ({ ...getBlockBackgroundStyle(theme), margin: "25px 0 40px", padding: "30px 20px" }));
var Typeset = ({ fontFamily, fontSizes, fontWeight, sampleText, ...props }) => import_react.default.createElement(Wrapper9, { ...props, className: "docblock-typeset sb-unstyled" }, fontSizes.map((size) => import_react.default.createElement(TypeSpecimen, { key: size }, import_react.default.createElement(Label4, null, size), import_react.default.createElement(Sample, { style: { fontFamily, fontSize: size, fontWeight, lineHeight: 1.2 } }, sampleText || "Was he a beast if music could move him so?"))));
var ItemTitle = Tr.div(({ theme }) => ({ fontWeight: theme.typography.weight.bold, color: theme.color.defaultText }));
var ItemSubtitle = Tr.div(({ theme }) => ({ color: theme.base === "light" ? curriedTransparentize$1(0.2, theme.color.defaultText) : curriedTransparentize$1(0.6, theme.color.defaultText) }));
var ItemDescription = Tr.div({ flex: "0 0 30%", lineHeight: "20px", marginTop: 5 });
var SwatchLabel = Tr.div(({ theme }) => ({ flex: 1, textAlign: "center", fontFamily: theme.typography.fonts.mono, fontSize: theme.typography.size.s1, lineHeight: 1, overflow: "hidden", color: theme.base === "light" ? curriedTransparentize$1(0.4, theme.color.defaultText) : curriedTransparentize$1(0.6, theme.color.defaultText), "> div": { display: "inline-block", overflow: "hidden", maxWidth: "100%", textOverflow: "ellipsis" }, span: { display: "block", marginTop: 2 } }));
var SwatchLabels = Tr.div({ display: "flex", flexDirection: "row" });
var Swatch = Tr.div(({ background }) => ({ position: "relative", flex: 1, "&::before": { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", background, content: '""' } }));
var SwatchColors = Tr.div(({ theme }) => ({ ...getBlockBackgroundStyle(theme), display: "flex", flexDirection: "row", height: 50, marginBottom: 5, overflow: "hidden", backgroundColor: "white", backgroundImage: "repeating-linear-gradient(-45deg, #ccc, #ccc 1px, #fff 1px, #fff 16px)", backgroundClip: "padding-box" }));
var SwatchSpecimen = Tr.div({ display: "flex", flexDirection: "column", flex: 1, position: "relative", marginBottom: 30 });
var Swatches = Tr.div({ flex: 1, display: "flex", flexDirection: "row" });
var Item = Tr.div({ display: "flex", alignItems: "flex-start" });
var ListName = Tr.div({ flex: "0 0 30%" });
var ListSwatches = Tr.div({ flex: 1 });
var ListHeading = Tr.div(({ theme }) => ({ display: "flex", flexDirection: "row", alignItems: "center", paddingBottom: 20, fontWeight: theme.typography.weight.bold, color: theme.base === "light" ? curriedTransparentize$1(0.4, theme.color.defaultText) : curriedTransparentize$1(0.6, theme.color.defaultText) }));
var List = Tr.div(({ theme }) => ({ fontSize: theme.typography.size.s2, lineHeight: "20px", display: "flex", flexDirection: "column" }));
function renderSwatch(color, index) {
  return import_react.default.createElement(Swatch, { key: `${color}-${index}`, title: color, background: color });
}
function renderSwatchLabel(color, index, colorDescription) {
  return import_react.default.createElement(SwatchLabel, { key: `${color}-${index}`, title: color }, import_react.default.createElement("div", null, color, colorDescription && import_react.default.createElement("span", null, colorDescription)));
}
function renderSwatchSpecimen(colors) {
  if (Array.isArray(colors)) return import_react.default.createElement(SwatchSpecimen, null, import_react.default.createElement(SwatchColors, null, colors.map((color, index) => renderSwatch(color, index))), import_react.default.createElement(SwatchLabels, null, colors.map((color, index) => renderSwatchLabel(color, index))));
  let swatchElements = [], labelElements = [];
  for (let colorKey in colors) {
    let colorValue = colors[colorKey];
    swatchElements.push(renderSwatch(colorValue, swatchElements.length)), labelElements.push(renderSwatchLabel(colorKey, labelElements.length, colorValue));
  }
  return import_react.default.createElement(SwatchSpecimen, null, import_react.default.createElement(SwatchColors, null, swatchElements), import_react.default.createElement(SwatchLabels, null, labelElements));
}
var ColorItem = ({ title, subtitle, colors }) => import_react.default.createElement(Item, null, import_react.default.createElement(ItemDescription, null, import_react.default.createElement(ItemTitle, null, title), import_react.default.createElement(ItemSubtitle, null, subtitle)), import_react.default.createElement(Swatches, null, renderSwatchSpecimen(colors)));
var ColorPalette = ({ children, ...props }) => import_react.default.createElement(z5, null, import_react.default.createElement(List, { ...props, className: "docblock-colorpalette sb-unstyled" }, import_react.default.createElement(ListHeading, null, import_react.default.createElement(ListName, null, "Name"), import_react.default.createElement(ListSwatches, null, "Swatches")), children));
var ItemLabel = Tr.div(({ theme }) => ({ fontFamily: theme.typography.fonts.base, fontSize: theme.typography.size.s2, color: theme.color.defaultText, marginLeft: 10, lineHeight: 1.2 }));
var ItemSpecimen = Tr.div(({ theme }) => ({ ...getBlockBackgroundStyle(theme), overflow: "hidden", height: 40, width: 40, display: "flex", alignItems: "center", justifyContent: "center", flex: "none", "> img, > svg": { width: 20, height: 20 } }));
var Item2 = Tr.div({ display: "inline-flex", flexDirection: "row", alignItems: "center", flex: "0 1 calc(20% - 10px)", minWidth: 120, margin: "0px 10px 30px 0" });
var List2 = Tr.div({ display: "flex", flexFlow: "row wrap" });
var IconItem = ({ name, children }) => import_react.default.createElement(Item2, null, import_react.default.createElement(ItemSpecimen, null, children), import_react.default.createElement(ItemLabel, null, name));
var IconGallery = ({ children, ...props }) => import_react.default.createElement(z5, null, import_react.default.createElement(List2, { ...props, className: "docblock-icongallery sb-unstyled" }, children));
var anchorBlockIdFromId = (storyId) => `anchor--${storyId}`;
var Anchor = ({ storyId, children }) => import_react.default.createElement("div", { id: anchorBlockIdFromId(storyId), className: "sb-anchor" }, children);
import_global.global && import_global.global.__DOCS_CONTEXT__ === void 0 && (import_global.global.__DOCS_CONTEXT__ = (0, import_react.createContext)(null), import_global.global.__DOCS_CONTEXT__.displayName = "DocsContext");
var DocsContext = import_global.global ? import_global.global.__DOCS_CONTEXT__ : (0, import_react.createContext)(null);
var useOf = (moduleExportOrType, validTypes) => (0, import_react.useContext)(DocsContext).resolveOf(moduleExportOrType, validTypes);
var titleCase = (str) => str.split("-").map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join("");
var getComponentName = (component) => {
  if (component) return typeof component == "string" ? component.includes("-") ? titleCase(component) : component : component.__docgenInfo && component.__docgenInfo.displayName ? component.__docgenInfo.displayName : component.name;
};
function scrollToElement(element, block = "start") {
  element.scrollIntoView({ behavior: "smooth", block, inline: "nearest" });
}
function extractComponentArgTypes(component, parameters) {
  let { extractArgTypes } = parameters.docs || {};
  if (!extractArgTypes) throw new Error("Args unsupported. See Args documentation for your framework.");
  return extractArgTypes(component);
}
function getArgTypesFromResolved(resolved) {
  if (resolved.type === "component") {
    let { component: component2, projectAnnotations: { parameters: parameters2 } } = resolved;
    return { argTypes: extractComponentArgTypes(component2, parameters2), parameters: parameters2, component: component2 };
  }
  if (resolved.type === "meta") {
    let { preparedMeta: { argTypes: argTypes2, parameters: parameters2, component: component2, subcomponents: subcomponents2 } } = resolved;
    return { argTypes: argTypes2, parameters: parameters2, component: component2, subcomponents: subcomponents2 };
  }
  let { story: { argTypes, parameters, component, subcomponents } } = resolved;
  return { argTypes, parameters, component, subcomponents };
}
var ArgTypes = (props) => {
  var _a;
  let { of } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  let resolved = useOf(of || "meta"), { argTypes, parameters, component, subcomponents } = getArgTypesFromResolved(resolved), argTypesParameters = ((_a = parameters.docs) == null ? void 0 : _a.argTypes) || {}, include = props.include ?? argTypesParameters.include, exclude = props.exclude ?? argTypesParameters.exclude, sort = props.sort ?? argTypesParameters.sort, filteredArgTypes = (0, import_preview_api2.filterArgTypes)(argTypes, include, exclude);
  if (!(!!subcomponents && Object.keys(subcomponents).length > 0)) return import_react.default.createElement(ArgsTable, { rows: filteredArgTypes, sort });
  let mainComponentName = getComponentName(component), subcomponentTabs = Object.fromEntries(Object.entries(subcomponents).map(([key, comp]) => [key, { rows: (0, import_preview_api2.filterArgTypes)(extractComponentArgTypes(comp, parameters), include, exclude), sort }])), tabs = { [mainComponentName]: { rows: filteredArgTypes, sort }, ...subcomponentTabs };
  return import_react.default.createElement(TabbedArgsTable, { tabs, sort });
};
function argsHash(args) {
  return stringify(args, { allowFunction: false });
}
var SourceContext = (0, import_react.createContext)({ sources: {} });
var UNKNOWN_ARGS_HASH = "--unknown--";
var SourceContainer = ({ children, channel }) => {
  let [sources, setSources] = (0, import_react.useState)({});
  return (0, import_react.useEffect)(() => {
    let handleSnippetRendered = (idOrEvent, inputSource = null, inputFormat = false) => {
      let { id, args = void 0, source, format: format2 } = typeof idOrEvent == "string" ? { id: idOrEvent, source: inputSource, format: inputFormat } : idOrEvent, hash = args ? argsHash(args) : UNKNOWN_ARGS_HASH;
      setSources((current) => ({ ...current, [id]: { ...current[id], [hash]: { code: source, format: format2 } } }));
    };
    return channel.on(eP, handleSnippetRendered), () => channel.off(eP, handleSnippetRendered);
  }, []), import_react.default.createElement(SourceContext.Provider, { value: { sources } }, children);
};
var getStorySource = (storyId, args, sourceContext) => {
  let { sources } = sourceContext, sourceMap = sources == null ? void 0 : sources[storyId];
  return (sourceMap == null ? void 0 : sourceMap[argsHash(args)]) || (sourceMap == null ? void 0 : sourceMap[UNKNOWN_ARGS_HASH]) || { code: "" };
};
var getSnippet = ({ snippet, storyContext, typeFromProps, transformFromProps }) => {
  var _a, _b;
  let { __isArgsStory: isArgsStory } = storyContext.parameters, sourceParameters = ((_a = storyContext.parameters.docs) == null ? void 0 : _a.source) || {}, type = typeFromProps || sourceParameters.type || sT.AUTO;
  if (sourceParameters.code !== void 0) return sourceParameters.code;
  let code = type === sT.DYNAMIC || type === sT.AUTO && snippet && isArgsStory ? snippet : sourceParameters.originalSource || "";
  return ((_b = transformFromProps ?? sourceParameters.transform) == null ? void 0 : _b(code, storyContext)) || code;
};
var useSourceProps = (props, docsContext, sourceContext) => {
  var _a, _b, _c, _d;
  let story, { of } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  if (of) story = docsContext.resolveOf(of, ["story"]).story;
  else try {
    story = docsContext.storyById();
  } catch {
  }
  let sourceParameters = ((_b = (_a = story == null ? void 0 : story.parameters) == null ? void 0 : _a.docs) == null ? void 0 : _b.source) || {}, { code } = props, format2 = props.format ?? sourceParameters.format, language = props.language ?? sourceParameters.language ?? "jsx", dark = props.dark ?? sourceParameters.dark ?? false;
  if (!code && !story) return { error: "Oh no! The source is not available." };
  if (code) return { code, format: format2, language, dark };
  let storyContext = docsContext.getStoryContext(story), argsForSource = props.__forceInitialArgs ? storyContext.initialArgs : storyContext.unmappedArgs, source = getStorySource(story.id, argsForSource, sourceContext);
  return format2 = source.format ?? ((_d = (_c = story.parameters.docs) == null ? void 0 : _c.source) == null ? void 0 : _d.format) ?? false, { code: getSnippet({ snippet: source.code, storyContext: { ...storyContext, args: argsForSource }, typeFromProps: props.type, transformFromProps: props.transform }), format: format2, language, dark };
};
var Source2 = (props) => {
  let sourceContext = (0, import_react.useContext)(SourceContext), docsContext = (0, import_react.useContext)(DocsContext), sourceProps = useSourceProps(props, docsContext, sourceContext);
  return import_react.default.createElement(Source, { ...sourceProps });
};
function useStory(storyId, context) {
  let stories = useStories([storyId], context);
  return stories && stories[0];
}
function useStories(storyIds, context) {
  let [storiesById, setStories] = (0, import_react.useState)({});
  return (0, import_react.useEffect)(() => {
    Promise.all(storyIds.map(async (storyId) => {
      let story = await context.loadStory(storyId);
      setStories((current) => current[storyId] === story ? current : { ...current, [storyId]: story });
    }));
  }), storyIds.map((storyId) => {
    if (storiesById[storyId]) return storiesById[storyId];
    try {
      return context.storyById(storyId);
    } catch {
      return null;
    }
  });
}
var getStoryId2 = (props, context) => {
  let { of, meta } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  return meta && context.referenceMeta(meta, false), context.resolveOf(of || "story", ["story"]).story.id;
};
var getStoryProps = (props, story, context) => {
  let { parameters = {} } = story || {}, { docs = {} } = parameters, storyParameters = docs.story || {};
  if (docs.disable) return null;
  if (props.inline ?? storyParameters.inline ?? false) {
    let height2 = props.height ?? storyParameters.height, autoplay = props.autoplay ?? storyParameters.autoplay ?? false;
    return { story, inline: true, height: height2, autoplay, forceInitialArgs: !!props.__forceInitialArgs, primary: !!props.__primary, renderStoryToElement: context.renderStoryToElement };
  }
  let height = props.height ?? storyParameters.height ?? storyParameters.iframeHeight ?? "100px";
  return { story, inline: false, height, primary: !!props.__primary };
};
var Story2 = (props = { __forceInitialArgs: false, __primary: false }) => {
  let context = (0, import_react.useContext)(DocsContext), storyId = getStoryId2(props, context), story = useStory(storyId, context);
  if (!story) return import_react.default.createElement(StorySkeleton, null);
  let storyProps = getStoryProps(props, story, context);
  return storyProps ? import_react.default.createElement(Story, { ...storyProps }) : null;
};
var Canvas = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i2, _j;
  let docsContext = (0, import_react.useContext)(DocsContext), sourceContext = (0, import_react.useContext)(SourceContext), { of, source } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  let { story } = useOf(of || "story", ["story"]), sourceProps = useSourceProps({ ...source, ...of && { of } }, docsContext, sourceContext), layout = props.layout ?? story.parameters.layout ?? ((_b = (_a = story.parameters.docs) == null ? void 0 : _a.canvas) == null ? void 0 : _b.layout) ?? "padded", withToolbar = props.withToolbar ?? ((_d = (_c = story.parameters.docs) == null ? void 0 : _c.canvas) == null ? void 0 : _d.withToolbar) ?? false, additionalActions = props.additionalActions ?? ((_f = (_e = story.parameters.docs) == null ? void 0 : _e.canvas) == null ? void 0 : _f.additionalActions), sourceState = props.sourceState ?? ((_h = (_g = story.parameters.docs) == null ? void 0 : _g.canvas) == null ? void 0 : _h.sourceState) ?? "hidden", className = props.className ?? ((_j = (_i2 = story.parameters.docs) == null ? void 0 : _i2.canvas) == null ? void 0 : _j.className);
  return import_react.default.createElement(Preview, { withSource: sourceState === "none" ? void 0 : sourceProps, isExpanded: sourceState === "shown", withToolbar, additionalActions, className, layout }, import_react.default.createElement(Story2, { of: of || story.moduleExport, meta: props.meta, ...props.story }));
};
var useGlobals = (story, context) => {
  let storyContext = context.getStoryContext(story), [globals, setGlobals] = (0, import_react.useState)(storyContext.globals);
  return (0, import_react.useEffect)(() => {
    let onGlobalsUpdated = (changed) => {
      setGlobals(changed.globals);
    };
    return context.channel.on(import_core_events.GLOBALS_UPDATED, onGlobalsUpdated), () => context.channel.off(import_core_events.GLOBALS_UPDATED, onGlobalsUpdated);
  }, [context.channel]), [globals];
};
var useArgs = (story, context) => {
  let result = useArgsIfDefined(story, context);
  if (!result) throw new Error("No result when story was defined");
  return result;
};
var useArgsIfDefined = (story, context) => {
  let storyContext = story ? context.getStoryContext(story) : { args: {} }, { id: storyId } = story || { id: "none" }, [args, setArgs] = (0, import_react.useState)(storyContext.args);
  (0, import_react.useEffect)(() => {
    let onArgsUpdated = (changed) => {
      changed.storyId === storyId && setArgs(changed.args);
    };
    return context.channel.on(import_core_events.STORY_ARGS_UPDATED, onArgsUpdated), () => context.channel.off(import_core_events.STORY_ARGS_UPDATED, onArgsUpdated);
  }, [storyId, context.channel]);
  let updateArgs = (0, import_react.useCallback)((updatedArgs) => context.channel.emit(import_core_events.UPDATE_STORY_ARGS, { storyId, updatedArgs }), [storyId, context.channel]), resetArgs = (0, import_react.useCallback)((argNames) => context.channel.emit(import_core_events.RESET_STORY_ARGS, { storyId, argNames }), [storyId, context.channel]);
  return story && [args, updateArgs, resetArgs];
};
function extractComponentArgTypes2(component, parameters) {
  let { extractArgTypes } = parameters.docs || {};
  if (!extractArgTypes) throw new Error("Args unsupported. See Args documentation for your framework.");
  return extractArgTypes(component);
}
var Controls3 = (props) => {
  var _a;
  let { of } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  let context = (0, import_react.useContext)(DocsContext), { story } = context.resolveOf(of || "story", ["story"]), { parameters, argTypes, component, subcomponents } = story, controlsParameters = ((_a = parameters.docs) == null ? void 0 : _a.controls) || {}, include = props.include ?? controlsParameters.include, exclude = props.exclude ?? controlsParameters.exclude, sort = props.sort ?? controlsParameters.sort, [args, updateArgs, resetArgs] = useArgs(story, context), [globals] = useGlobals(story, context), filteredArgTypes = (0, import_preview_api2.filterArgTypes)(argTypes, include, exclude);
  if (!(!!subcomponents && Object.keys(subcomponents).length > 0)) return Object.keys(filteredArgTypes).length > 0 || Object.keys(args).length > 0 ? import_react.default.createElement(ArgsTable, { rows: filteredArgTypes, sort, args, globals, updateArgs, resetArgs }) : null;
  let mainComponentName = getComponentName(component), subcomponentTabs = Object.fromEntries(Object.entries(subcomponents).map(([key, comp]) => [key, { rows: (0, import_preview_api2.filterArgTypes)(extractComponentArgTypes2(comp, parameters), include, exclude), sort }])), tabs = { [mainComponentName]: { rows: filteredArgTypes, sort }, ...subcomponentTabs };
  return import_react.default.createElement(TabbedArgsTable, { tabs, sort, args, globals, updateArgs, resetArgs });
};
var { document: document2 } = import_global.global;
var assertIsFn = (val) => {
  if (typeof val != "function") throw new Error(`Expected story function, got: ${val}`);
  return val;
};
var AddContext = (props) => {
  let { children, ...rest } = props, parentContext = import_react.default.useContext(DocsContext);
  return import_react.default.createElement(DocsContext.Provider, { value: { ...parentContext, ...rest } }, children);
};
var CodeOrSourceMdx = ({ className, children, ...rest }) => {
  if (typeof className != "string" && (typeof children != "string" || !children.match(/[\n\r]/g))) return import_react.default.createElement(lu, null, children);
  let language = className && className.split("-");
  return import_react.default.createElement(Source, { language: language && language[1] || "text", format: false, code: children, ...rest });
};
function navigate(context, url) {
  context.channel.emit(import_core_events.NAVIGATE_URL, url);
}
var A = uJ.a;
var AnchorInPage = ({ hash, children }) => {
  let context = (0, import_react.useContext)(DocsContext);
  return import_react.default.createElement(A, { href: hash, target: "_self", onClick: (event) => {
    let id = hash.substring(1);
    document2.getElementById(id) && navigate(context, hash);
  } }, children);
};
var AnchorMdx = (props) => {
  let { href, target, children, ...rest } = props, context = (0, import_react.useContext)(DocsContext);
  return !href || target === "_blank" || /^https?:\/\//.test(href) ? import_react.default.createElement(A, { ...props }) : href.startsWith("#") ? import_react.default.createElement(AnchorInPage, { hash: href }, children) : import_react.default.createElement(A, { href, onClick: (event) => {
    event.button === 0 && !event.altKey && !event.ctrlKey && !event.metaKey && !event.shiftKey && (event.preventDefault(), navigate(context, event.currentTarget.getAttribute("href")));
  }, target, ...rest }, children);
};
var SUPPORTED_MDX_HEADERS = ["h1", "h2", "h3", "h4", "h5", "h6"];
var OcticonHeaders = SUPPORTED_MDX_HEADERS.reduce((acc, headerType) => ({ ...acc, [headerType]: Tr(headerType)({ "& svg": { position: "relative", top: "-0.1em", visibility: "hidden" }, "&:hover svg": { visibility: "visible" } }) }), {});
var OcticonAnchor = Tr.a(() => ({ float: "left", lineHeight: "inherit", paddingRight: "10px", marginLeft: "-24px", color: "inherit" }));
var HeaderWithOcticonAnchor = ({ as: as2, id, children, ...rest }) => {
  let context = (0, import_react.useContext)(DocsContext), OcticonHeader = OcticonHeaders[as2], hash = `#${id}`;
  return import_react.default.createElement(OcticonHeader, { id, ...rest }, import_react.default.createElement(OcticonAnchor, { "aria-hidden": "true", href: hash, tabIndex: -1, target: "_self", onClick: (event) => {
    document2.getElementById(id) && navigate(context, hash);
  } }, import_react.default.createElement(LinkIcon, null)), children);
};
var HeaderMdx = (props) => {
  let { as: as2, id, children, ...rest } = props;
  if (id) return import_react.default.createElement(HeaderWithOcticonAnchor, { as: as2, id, ...rest }, children);
  let Component4 = as2, { as: omittedAs, ...withoutAs } = props;
  return import_react.default.createElement(Component4, { ...ee(withoutAs, as2) });
};
var HeadersMdx = SUPPORTED_MDX_HEADERS.reduce((acc, headerType) => ({ ...acc, [headerType]: (props) => import_react.default.createElement(HeaderMdx, { as: headerType, ...props }) }), {});
var Markdown2 = (props) => {
  var _a;
  if (!props.children) return null;
  if (typeof props.children != "string") throw new Error(dedent`The Markdown block only accepts children as a single string, but children were of type: '${typeof props.children}'
        This is often caused by not wrapping the child in a template string.
        
        This is invalid:
        <Markdown>
          # Some heading
          A paragraph
        </Markdown>

        Instead do:
        <Markdown>
        {\`
          # Some heading
          A paragraph
        \`}
        </Markdown>
      `);
  return import_react.default.createElement(index_modern_default, { ...props, options: { forceBlock: true, overrides: { code: CodeOrSourceMdx, a: AnchorMdx, ...HeadersMdx, ...(_a = props == null ? void 0 : props.options) == null ? void 0 : _a.overrides }, ...props == null ? void 0 : props.options } });
};
var DescriptionType = ((DescriptionType2) => (DescriptionType2.INFO = "info", DescriptionType2.NOTES = "notes", DescriptionType2.DOCGEN = "docgen", DescriptionType2.AUTO = "auto", DescriptionType2))(DescriptionType || {});
var getDescriptionFromResolvedOf = (resolvedOf) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  switch (resolvedOf.type) {
    case "story":
      return ((_b = (_a = resolvedOf.story.parameters.docs) == null ? void 0 : _a.description) == null ? void 0 : _b.story) || null;
    case "meta": {
      let { parameters, component } = resolvedOf.preparedMeta, metaDescription = (_d = (_c = parameters.docs) == null ? void 0 : _c.description) == null ? void 0 : _d.component;
      return metaDescription || ((_f = (_e = parameters.docs) == null ? void 0 : _e.extractComponentDescription) == null ? void 0 : _f.call(_e, component, { component, parameters })) || null;
    }
    case "component": {
      let { component, projectAnnotations: { parameters } } = resolvedOf;
      return ((_h = (_g = parameters.docs) == null ? void 0 : _g.extractComponentDescription) == null ? void 0 : _h.call(_g, component, { component, parameters })) || null;
    }
    default:
      throw new Error(`Unrecognized module type resolved from 'useOf', got: ${resolvedOf.type}`);
  }
};
var DescriptionContainer = (props) => {
  let { of } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  let resolvedOf = useOf(of || "meta"), markdown = getDescriptionFromResolvedOf(resolvedOf);
  return markdown ? import_react.default.createElement(Markdown2, null, markdown) : null;
};
var tocbot = __toESM2(require_js());
var Wrapper10 = Tr.div(({ theme }) => ({ width: "10rem", "@media (max-width: 768px)": { display: "none" } }));
var Content = Tr.div(({ theme }) => ({ position: "fixed", bottom: 0, top: 0, width: "10rem", paddingTop: "4rem", paddingBottom: "2rem", overflowY: "auto", fontFamily: theme.typography.fonts.base, fontSize: theme.typography.size.s2, WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale", WebkitTapHighlightColor: "rgba(0, 0, 0, 0)", WebkitOverflowScrolling: "touch", "& *": { boxSizing: "border-box" }, "& > .toc-wrapper > .toc-list": { paddingLeft: 0, borderLeft: `solid 2px ${theme.color.mediumlight}`, ".toc-list": { paddingLeft: 0, borderLeft: `solid 2px ${theme.color.mediumlight}`, ".toc-list": { paddingLeft: 0, borderLeft: `solid 2px ${theme.color.mediumlight}` } } }, "& .toc-list-item": { position: "relative", listStyleType: "none", marginLeft: 20, paddingTop: 3, paddingBottom: 3 }, "& .toc-list-item::before": { content: '""', position: "absolute", height: "100%", top: 0, left: 0, transform: "translateX(calc(-2px - 20px))", borderLeft: `solid 2px ${theme.color.mediumdark}`, opacity: 0, transition: "opacity 0.2s" }, "& .toc-list-item.is-active-li::before": { opacity: 1 }, "& .toc-list-item > a": { color: theme.color.defaultText, textDecoration: "none" }, "& .toc-list-item.is-active-li > a": { fontWeight: 600, color: theme.color.secondary, textDecoration: "none" } }));
var Heading = Tr.p(({ theme }) => ({ fontWeight: 600, fontSize: "0.875em", color: theme.textColor, textTransform: "uppercase", marginBottom: 10 }));
var OptionalTitle = ({ title }) => title === null ? null : typeof title == "string" ? import_react.default.createElement(Heading, null, title) : title;
var TableOfContents = ({ title, disable, headingSelector, contentsSelector, ignoreSelector, unsafeTocbotOptions }) => ((0, import_react.useEffect)(() => {
  let configuration = { tocSelector: ".toc-wrapper", contentSelector: contentsSelector ?? ".sbdocs-content", headingSelector: headingSelector ?? "h3", ignoreSelector: ignoreSelector ?? ".docs-story *, .skip-toc", headingsOffset: 40, scrollSmoothOffset: -40, orderedList: false, onClick: () => false, ...unsafeTocbotOptions }, timeout = setTimeout(() => tocbot.init(configuration), 100);
  return () => {
    clearTimeout(timeout), tocbot.destroy();
  };
}, [disable]), import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(Wrapper10, null, disable ? null : import_react.default.createElement(Content, null, import_react.default.createElement(OptionalTitle, { title: title || null }), import_react.default.createElement("div", { className: "toc-wrapper" })))));
var { document: document3, window: globalWindow3 } = import_global.global;
var DocsContainer = ({ context, theme, children }) => {
  var _a, _b, _c, _d, _e;
  let toc;
  try {
    toc = (_b = (_a = context.resolveOf("meta", ["meta"]).preparedMeta.parameters) == null ? void 0 : _a.docs) == null ? void 0 : _b.toc;
  } catch {
    toc = (_e = (_d = (_c = context == null ? void 0 : context.projectAnnotations) == null ? void 0 : _c.parameters) == null ? void 0 : _d.docs) == null ? void 0 : _e.toc;
  }
  return (0, import_react.useEffect)(() => {
    let url;
    try {
      if (url = new URL(globalWindow3.parent.location.toString()), url.hash) {
        let element = document3.getElementById(url.hash.substring(1));
        element && setTimeout(() => {
          scrollToElement(element);
        }, 200);
      }
    } catch {
    }
  }), import_react.default.createElement(DocsContext.Provider, { value: context }, import_react.default.createElement(SourceContainer, { channel: context.channel }, import_react.default.createElement(jt, { theme: pc(theme) }, import_react.default.createElement(DocsPageWrapper, { toc: toc ? import_react.default.createElement(TableOfContents, { className: "sbdocs sbdocs-toc--custom", ...toc }) : null }, children))));
};
var STORY_KIND_PATH_SEPARATOR = /\s*\/\s*/;
var extractTitle = (title) => {
  let groups = title.trim().split(STORY_KIND_PATH_SEPARATOR);
  return (groups == null ? void 0 : groups[(groups == null ? void 0 : groups.length) - 1]) || title;
};
var Title2 = (props) => {
  let { children, of } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  let preparedMeta;
  try {
    preparedMeta = useOf(of || "meta", ["meta"]).preparedMeta;
  } catch (error) {
    if (children && !error.message.includes("did you forget to use <Meta of={} />?")) throw error;
  }
  let content = children || extractTitle(preparedMeta == null ? void 0 : preparedMeta.title);
  return content ? import_react.default.createElement(Title, { className: "sbdocs-title sb-unstyled" }, content) : null;
};
var DEPRECATION_MIGRATION_LINK = "https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#subtitle-block-and-parameterscomponentsubtitle";
var Subtitle2 = (props) => {
  let { of, children } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  let preparedMeta;
  try {
    preparedMeta = useOf(of || "meta", ["meta"]).preparedMeta;
  } catch (error) {
    if (children && !error.message.includes("did you forget to use <Meta of={} />?")) throw error;
  }
  let { componentSubtitle, docs } = (preparedMeta == null ? void 0 : preparedMeta.parameters) || {};
  componentSubtitle && (0, import_client_logger.deprecate)(`Using 'parameters.componentSubtitle' property to subtitle stories is deprecated. See ${DEPRECATION_MIGRATION_LINK}`);
  let content = children || (docs == null ? void 0 : docs.subtitle) || componentSubtitle;
  return content ? import_react.default.createElement(Subtitle, { className: "sbdocs-subtitle sb-unstyled" }, content) : null;
};
var Subheading = ({ children, disableAnchor }) => {
  if (disableAnchor || typeof children != "string") return import_react.default.createElement(du, null, children);
  let tagID = globalThis.encodeURIComponent(children.toLowerCase());
  return import_react.default.createElement(HeaderMdx, { as: "h3", id: tagID }, children);
};
var DocsStory = ({ of, expanded = true, withToolbar: withToolbarProp = false, __forceInitialArgs = false, __primary = false }) => {
  var _a, _b;
  let { story } = useOf(of || "story", ["story"]), withToolbar = ((_b = (_a = story.parameters.docs) == null ? void 0 : _a.canvas) == null ? void 0 : _b.withToolbar) ?? withToolbarProp;
  return import_react.default.createElement(Anchor, { storyId: story.id }, expanded && import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(Subheading, null, story.name), import_react.default.createElement(DescriptionContainer, { of })), import_react.default.createElement(Canvas, { of, withToolbar, story: { __forceInitialArgs, __primary }, source: { __forceInitialArgs } }));
};
var Primary = (props) => {
  let { of } = props;
  if ("of" in props && of === void 0) throw new Error("Unexpected `of={undefined}`, did you mistype a CSF file reference?");
  let { csfFile } = useOf(of || "meta", ["meta"]), primaryStory = (0, import_react.useContext)(DocsContext).componentStoriesFromCSFFile(csfFile)[0];
  return primaryStory ? import_react.default.createElement(DocsStory, { of: primaryStory.moduleExport, expanded: false, __primary: true, withToolbar: true }) : null;
};
var Heading2 = ({ children, disableAnchor, ...props }) => {
  if (disableAnchor || typeof children != "string") return import_react.default.createElement(pu, null, children);
  let tagID = children.toLowerCase().replace(/[^a-z0-9]/gi, "-");
  return import_react.default.createElement(HeaderMdx, { as: "h2", id: tagID, ...props }, children);
};
var StyledHeading = Tr(Heading2)(({ theme }) => ({ fontSize: `${theme.typography.size.s2 - 1}px`, fontWeight: theme.typography.weight.bold, lineHeight: "16px", letterSpacing: "0.35em", textTransform: "uppercase", color: theme.textMutedColor, border: 0, marginBottom: "12px", "&:first-of-type": { marginTop: "56px" } }));
var Stories = ({ title = "Stories", includePrimary = true }) => {
  var _a;
  let { componentStories, projectAnnotations, getStoryContext } = (0, import_react.useContext)(DocsContext), stories = componentStories(), { stories: { filter } = { filter: void 0 } } = ((_a = projectAnnotations.parameters) == null ? void 0 : _a.docs) || {};
  return filter && (stories = stories.filter((story) => filter(story, getStoryContext(story)))), stories.some((story) => {
    var _a2;
    return (_a2 = story.tags) == null ? void 0 : _a2.includes("autodocs");
  }) && (stories = stories.filter((story) => {
    var _a2;
    return ((_a2 = story.tags) == null ? void 0 : _a2.includes("autodocs")) && !story.usesMount;
  })), includePrimary || (stories = stories.slice(1)), !stories || stories.length === 0 ? null : import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(StyledHeading, null, title), stories.map((story) => story && import_react.default.createElement(DocsStory, { key: story.id, of: story.moduleExport, expanded: true, __forceInitialArgs: true })));
};
var DocsPage = () => {
  let resolvedOf = useOf("meta", ["meta"]), { stories } = resolvedOf.csfFile, isSingleStory = Object.keys(stories).length === 1;
  return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(Title2, null), import_react.default.createElement(Subtitle2, null), import_react.default.createElement(DescriptionContainer, { of: "meta" }), isSingleStory ? import_react.default.createElement(DescriptionContainer, { of: "story" }) : null, import_react.default.createElement(Primary, null), import_react.default.createElement(Controls3, null), isSingleStory ? null : import_react.default.createElement(Stories, null));
};
function Docs({ context, docsParameter }) {
  let Container = docsParameter.container || DocsContainer, Page = docsParameter.page || DocsPage;
  return import_react.default.createElement(Container, { context, theme: docsParameter.theme }, import_react.default.createElement(Page, null));
}
var ExternalDocsContext = class extends import_preview_api2.DocsContext {
  constructor(channel, store, renderStoryToElement, processMetaExports) {
    super(channel, store, renderStoryToElement, []);
    this.channel = channel;
    this.store = store;
    this.renderStoryToElement = renderStoryToElement;
    this.processMetaExports = processMetaExports;
    this.referenceMeta = (metaExports, attach) => {
      let csfFile = this.processMetaExports(metaExports);
      this.referenceCSFFile(csfFile), super.referenceMeta(metaExports, attach);
    };
  }
};
var ConstantMap = class {
  constructor(prefix) {
    this.prefix = prefix;
    this.entries = /* @__PURE__ */ new Map();
  }
  get(key) {
    return this.entries.has(key) || this.entries.set(key, `${this.prefix}${this.entries.size}`), this.entries.get(key);
  }
};
var ExternalPreview = class extends import_preview_api2.Preview {
  constructor(projectAnnotations) {
    super((path) => Promise.resolve(this.moduleExportsByImportPath[path]), () => (0, import_preview_api2.composeConfigs)([{ parameters: { docs: { story: { inline: true } } } }, this.projectAnnotations]), new import_channels.Channel({}));
    this.projectAnnotations = projectAnnotations;
    this.importPaths = new ConstantMap("./importPath/");
    this.titles = new ConstantMap("title-");
    this.storyIndex = { v: 5, entries: {} };
    this.moduleExportsByImportPath = {};
    this.processMetaExports = (metaExports) => {
      let importPath = this.importPaths.get(metaExports);
      this.moduleExportsByImportPath[importPath] = metaExports;
      let title = metaExports.default.title || this.titles.get(metaExports), csfFile = this.storyStoreValue.processCSFFileWithCache(metaExports, importPath, title);
      return Object.values(csfFile.stories).forEach(({ id, name }) => {
        this.storyIndex.entries[id] = { id, importPath, title, name, type: "story" };
      }), this.onStoriesChanged({ storyIndex: this.storyIndex }), csfFile;
    };
    this.docsContext = () => new ExternalDocsContext(this.channel, this.storyStoreValue, this.renderStoryToElement.bind(this), this.processMetaExports.bind(this));
  }
  async getStoryIndexFromServer() {
    return this.storyIndex;
  }
};
function usePreview(projectAnnotations) {
  let previewRef = (0, import_react.useRef)();
  return previewRef.current || (previewRef.current = new ExternalPreview(projectAnnotations)), previewRef.current;
}
function ExternalDocs({ projectAnnotationsList, children }) {
  var _a;
  let projectAnnotations = (0, import_preview_api2.composeConfigs)(projectAnnotationsList), preview2 = usePreview(projectAnnotations), docsParameter = { ...(_a = projectAnnotations.parameters) == null ? void 0 : _a.docs, page: () => children };
  return import_react.default.createElement(Docs, { docsParameter, context: preview2.docsContext() });
}
var preview;
var ExternalDocsContainer = ({ projectAnnotations, children }) => (preview || (preview = new ExternalPreview(projectAnnotations)), import_react.default.createElement(DocsContext.Provider, { value: preview.docsContext() }, import_react.default.createElement(jt, { theme: pc(Ne.light) }, children)));
var Meta = ({ of }) => {
  let context = (0, import_react.useContext)(DocsContext);
  of && context.referenceMeta(of, true);
  try {
    let primary = context.storyById();
    return import_react.default.createElement(Anchor, { storyId: primary.id });
  } catch {
    return null;
  }
};
var Unstyled = (props) => import_react.default.createElement("div", { ...props, className: "sb-unstyled" });
var Wrapper11 = ({ children }) => import_react.default.createElement("div", { style: { fontFamily: "sans-serif" } }, children);
var PRIMARY_STORY = "^";

// node_modules/@storybook/addon-docs/dist/chunk-HLWAVYOI.mjs
var defaultComponents = { code: CodeOrSourceMdx, a: AnchorMdx, ...HeadersMdx };
var ErrorBoundary = class extends import_react2.Component {
  constructor() {
    super(...arguments);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(err) {
    let { showException } = this.props;
    showException(err);
  }
  render() {
    let { hasError } = this.state, { children } = this.props;
    return hasError ? null : import_react2.default.createElement(import_react2.default.Fragment, null, children);
  }
};
var DocsRenderer = class {
  constructor() {
    this.render = async (context, docsParameter, element) => {
      let components = { ...defaultComponents, ...docsParameter == null ? void 0 : docsParameter.components }, TDocs = Docs;
      return new Promise((resolve, reject) => {
        import("./@mdx-js_react.js").then(({ MDXProvider }) => renderElement(import_react2.default.createElement(ErrorBoundary, { showException: reject, key: Math.random() }, import_react2.default.createElement(MDXProvider, { components }, import_react2.default.createElement(TDocs, { context, docsParameter }))), element)).then(() => resolve());
      });
    }, this.unmount = (element) => {
      unmountElement(element);
    };
  }
};
export {
  AddContext,
  Anchor,
  AnchorMdx,
  ArgTypes,
  BooleanControl,
  Canvas,
  CodeOrSourceMdx,
  ColorControl,
  ColorItem,
  ColorPalette,
  Controls3 as Controls,
  DateControl,
  DescriptionContainer as Description,
  DescriptionType,
  Docs,
  DocsContainer,
  DocsContext,
  DocsPage,
  DocsRenderer,
  DocsStory,
  ExternalDocs,
  ExternalDocsContainer,
  FilesControl,
  HeaderMdx,
  HeadersMdx,
  Heading2 as Heading,
  IconGallery,
  IconItem,
  Markdown2 as Markdown,
  Meta,
  NumberControl,
  ObjectControl,
  OptionsControl,
  PRIMARY_STORY,
  Primary,
  ArgsTable as PureArgsTable,
  RangeControl,
  Source2 as Source,
  SourceContainer,
  SourceContext,
  Stories,
  Story2 as Story,
  Subheading,
  Subtitle2 as Subtitle,
  TextControl,
  Title2 as Title,
  Typeset,
  UNKNOWN_ARGS_HASH,
  Unstyled,
  Wrapper11 as Wrapper,
  anchorBlockIdFromId,
  argsHash,
  assertIsFn,
  extractTitle,
  format,
  formatDate,
  formatTime,
  getStoryId2 as getStoryId,
  getStoryProps,
  parse2 as parse,
  parseDate,
  parseTime,
  useOf,
  useSourceProps
};
//# sourceMappingURL=@storybook_addon-docs.js.map
